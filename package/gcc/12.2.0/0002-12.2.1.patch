diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 685332623b2..9e3b205825b 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-12.2.0
+12.2.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index f267a27b057..e9e0b550e93 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,1123 @@
+2023-01-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/108199
+	* tree-sra.cc (sra_modify_expr): Deal with reverse storage order
+	for bit-field references.
+
+2023-01-11  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-12-28  Martin Liska  <mliska@suse.cz>
+
+	PR tree-optimization/108137
+	* tree-ssa-strlen.cc (get_range_strlen_phi): Reject anything
+	different from INTEGER_CST.
+
+2023-01-10  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	Backported from master:
+	2022-12-30  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	PR target/107714
+	* config/arm/arm-protos.h (mve_struct_mem_operand): New protoype.
+	* config/arm/arm.cc (mve_struct_mem_operand): New function.
+	* config/arm/constraints.md (Ug): New constraint.
+	* config/arm/mve.md (mve_vst4q<mode>): Change constraint.
+	(mve_vst2q<mode>): Likewise.
+	(mve_vld4q<mode>): Likewise.
+	(mve_vld2q<mode>): Likewise.
+	* config/arm/predicates.md (mve_struct_operand): New predicate.
+
+2023-01-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2022-12-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/108140
+	* config/aarch64/aarch64-builtins.cc
+	(aarch64_expand_builtin_data_intrinsic): Handle NULL target.
+
+2023-01-05  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106736
+	* config/rs6000/mma.md (define_expand movoo): Call function
+	rs6000_opaque_type_invalid_use_p to check and emit error message for
+	the invalid use of opaque type.
+	(define_expand movxo): Likewise.
+	* config/rs6000/rs6000-protos.h
+	(rs6000_opaque_type_invalid_use_p): New function declaration.
+	(currently_expanding_gimple_stmt): New extern declaration.
+	* config/rs6000/rs6000.cc (rs6000_opaque_type_invalid_use_p): New
+	function.
+
+2022-12-22  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-12-22  Richard Biener  <rguenther@suse.de>
+
+	PR bootstrap/106482
+	* doc/install.texi (ISO C++11 Compiler): Document GCC version
+	known to work.
+
+2022-12-22  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-08-10  Martin Liska  <mliska@suse.cz>
+
+	* opts-jobserver.h: Add one member.
+	* opts-common.cc (jobserver_info::jobserver_info): Parse FIFO
+	format of --jobserver-auth.
+
+2022-12-22  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-08-10  Martin Liska  <mliska@suse.cz>
+
+	* gcc.cc (driver::detect_jobserver): Remove and move to
+	jobserver.h.
+	* lto-wrapper.cc (jobserver_active_p): Likewise.
+	(run_gcc): Likewise.
+	* opts-jobserver.h: New file.
+	* opts-common.cc (jobserver_info::jobserver_info): New function.
+
+2022-12-20  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-12-20  Richard Biener  <rguenther@suse.de>
+
+	PR d/104749
+	* doc/install.texi (GDC): Document GDC 9.4 or later is required
+	to build the D language frontend.
+
+2022-12-20  Hongyu Wang  <hongyu.wang@intel.com>
+
+	* config/i386/x86-tune.def (X86_TUNE_AVOID_256FMA_CHAINS): Add
+	m_SAPPHIRERAPIDS, m_ALDERLAKE.
+
+2022-12-15  Sebastian Pop  <spop@amazon.com>
+
+	PR target/98776
+	* config/aarch64/aarch64-protos.h (aarch64_output_patchable_area):
+	Declared.
+	* config/aarch64/aarch64.cc (aarch64_print_patchable_function_entry):
+	Emit an UNSPECV_PATCHABLE_AREA pseudo instruction.
+	(aarch64_output_patchable_area): New.
+	* config/aarch64/aarch64.md (UNSPECV_PATCHABLE_AREA): New.
+	(patchable_area): Define.
+
+2022-12-13  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2022-12-01  Alex Coplan  <alex.coplan@arm.com>
+
+	* varasm.cc (assemble_variable): Fix type confusion bug when
+	checking for ".vtable_map_vars" section.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107898
+	* gimple-ssa-warn-alloca.cc (alloca_call_type): Check
+	the type of the alloca argument is compatible with size_t
+	before querying ranges.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107865
+	* tree-cfg.cc (move_sese_region_to_fn): Free the number of
+	iterations of moved loops.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-12-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107833
+	PR tree-optimization/107839
+	* cfghooks.cc: Include tree.h.
+	* tree-ssa-loop-im.cc (movement_possibility): Wrap and
+	make stmts using any ssa_name_maybe_undef_p operand
+	to preserve execution.
+	(loop_invariant_motion_in_fun): Call mark_ssa_maybe_undefs
+	to init maybe-undefined status.
+	* tree-ssa-loop-ivopts.cc (ssa_name_maybe_undef_p,
+	ssa_name_set_maybe_undef, ssa_name_any_use_dominates_bb_p,
+	mark_ssa_maybe_undefs): Move ...
+	* tree-ssa.cc: ... here.
+	* tree-ssa.h (ssa_name_any_use_dominates_bb_p,
+	mark_ssa_maybe_undefs): Declare.
+	(ssa_name_maybe_undef_p, ssa_name_set_maybe_undef): Define.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107686
+	* tree-ssa-forwprop.cc (optimize_vector_load): Restrict
+	VEC_UNPACK support to integral typed bitfield refs.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107766
+	* tree-vect-slp-patterns.cc (complex_mul_pattern::matches):
+	Use *node to check for FP vector types.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107647
+	* tree-vect-slp-patterns.cc (addsub_pattern::recognize): Only
+	allow FMA generation with -ffp-contract=fast for FP types.
+	(complex_mul_pattern::matches): Likewise.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107407
+	* tree-ssa-dse.cc (dse_classify_store): Perform backedge
+	varying index check when collecting PHI uses rather than
+	after optimizing processing of the candidate defs.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-12-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106868
+	* gimple-ssa-warn-access.cc (pass_waccess::gimple_call_return_arg_ref):
+	Inline into single user ...
+	(pass_waccess::check_dangling_uses): ... here and adjust the
+	call and the PHI case to require that ref.aref is the address
+	of the decl.
+
+2022-12-09  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-12-09  Martin Liska  <mliska@suse.cz>
+
+	* config/i386/i386-builtins.cc (fold_builtin_cpu): Use same path
+	as for PR103661.
+	* doc/extend.texi: Fix "x86-64" use.
+
+2022-12-09  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-05-11  Martin Liska  <mliska@suse.cz>
+
+	* common/config/i386/cpuinfo.h (has_cpu_feature): Directly
+	compute index in cpu_features2.
+	(set_cpu_feature): Likewise.
+	* config/i386/i386-builtins.cc (fold_builtin_cpu): Also remove
+	loop for cpu_features2 and use NOP_EXPRs.
+
+2022-12-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2022-11-30  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64.md (aarch64_cpymemdi): Specify clobber of CC reg.
+	(*aarch64_cpymemdi): Likewise.
+	(aarch64_movmemdi): Likewise.
+	(aarch64_setmemdi): Likewise.
+	(*aarch64_setmemdi): Likewise.
+
+2022-12-05  Andrew Pinski  <pinskia@gmail.com>
+
+	Backported from master:
+	2022-12-05  Andrew Pinski  <pinskia@gmail.com>
+
+	PR tree-optimization/107956
+	* tree-vect-patterns.cc (vect_recog_mask_conversion_pattern):
+	Check for NULL LHS on masked loads.
+
+2022-12-01  liuhongt  <hongtao.liu@intel.com>
+
+	PR target/107863
+	* config/i386/i386-expand.cc (ix86_expand_vec_set_builtin):
+	Convert op1 to target mode whenever mode mismatch.
+
+2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-09-08  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* config/darwin-d.cc: Include tm.h.
+	* config/dragonfly-d.cc: Likewise.
+	* config/freebsd-d.cc: Remove memmodel.h.
+	* config/glibc-d.cc: Likewise.
+	* config/netbsd-d.cc: Include tm.h.
+	* config/openbsd-d.cc: Likewise.
+	* config/sol2-d.cc: Likewise.
+
+2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-09-02  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/105659
+	* config.gcc: Set tm_d_file to ${cpu_type}/${cpu_type}-d.h.
+	* config/aarch64/aarch64-d.cc: Include tm_d.h.
+	* config/aarch64/aarch64-protos.h (aarch64_d_target_versions): Move to
+	config/aarch64/aarch64-d.h.
+	(aarch64_d_register_target_info): Likewise.
+	* config/aarch64/aarch64.h (TARGET_D_CPU_VERSIONS): Likewise.
+	(TARGET_D_REGISTER_CPU_TARGET_INFO): Likewise.
+	* config/arm/arm-d.cc: Include tm_d.h and arm-protos.h instead of
+	tm_p.h.
+	* config/arm/arm-protos.h (arm_d_target_versions): Move to
+	config/arm/arm-d.h.
+	(arm_d_register_target_info): Likewise.
+	* config/arm/arm.h (TARGET_D_CPU_VERSIONS): Likewise.
+	(TARGET_D_REGISTER_CPU_TARGET_INFO): Likewise.
+	* config/default-d.cc: Remove memmodel.h include.
+	* config/freebsd-d.cc: Include tm_d.h instead of tm_p.h.
+	* config/glibc-d.cc: Likewise.
+	* config/i386/i386-d.cc: Include tm_d.h.
+	* config/i386/i386-protos.h (ix86_d_target_versions): Move to
+	config/i386/i386-d.h.
+	(ix86_d_register_target_info): Likewise.
+	(ix86_d_has_stdcall_convention): Likewise.
+	* config/i386/i386.h (TARGET_D_CPU_VERSIONS): Likewise.
+	(TARGET_D_REGISTER_CPU_TARGET_INFO): Likewise.
+	(TARGET_D_HAS_STDCALL_CONVENTION): Likewise.
+	* config/i386/winnt-d.cc: Include tm_d.h instead of tm_p.h.
+	* config/mips/mips-d.cc: Include tm_d.h.
+	* config/mips/mips-protos.h (mips_d_target_versions): Move to
+	config/mips/mips-d.h.
+	(mips_d_register_target_info): Likewise.
+	* config/mips/mips.h (TARGET_D_CPU_VERSIONS): Likewise.
+	(TARGET_D_REGISTER_CPU_TARGET_INFO): Likewise.
+	* config/netbsd-d.cc: Include tm_d.h instead of tm.h and memmodel.h.
+	* config/openbsd-d.cc: Likewise.
+	* config/pa/pa-d.cc: Include tm_d.h.
+	* config/pa/pa-protos.h (pa_d_target_versions): Move to
+	config/pa/pa-d.h.
+	(pa_d_register_target_info): Likewise.
+	* config/pa/pa.h (TARGET_D_CPU_VERSIONS): Likewise.
+	(TARGET_D_REGISTER_CPU_TARGET_INFO): Likewise.
+	* config/riscv/riscv-d.cc: Include tm_d.h.
+	* config/riscv/riscv-protos.h (riscv_d_target_versions): Move to
+	config/riscv/riscv-d.h.
+	(riscv_d_register_target_info): Likewise.
+	* config/riscv/riscv.h (TARGET_D_CPU_VERSIONS): Likewise.
+	(TARGET_D_REGISTER_CPU_TARGET_INFO): Likewise.
+	* config/rs6000/rs6000-d.cc: Include tm_d.h.
+	* config/rs6000/rs6000-protos.h (rs6000_d_target_versions): Move to
+	config/rs6000/rs6000-d.h.
+	(rs6000_d_register_target_info): Likewise.
+	* config/rs6000/rs6000.h (TARGET_D_CPU_VERSIONS) Likewise.:
+	(TARGET_D_REGISTER_CPU_TARGET_INFO) Likewise.:
+	* config/s390/s390-d.cc: Include tm_d.h.
+	* config/s390/s390-protos.h (s390_d_target_versions): Move to
+	config/s390/s390-d.h.
+	(s390_d_register_target_info): Likewise.
+	* config/s390/s390.h (TARGET_D_CPU_VERSIONS): Likewise.
+	(TARGET_D_REGISTER_CPU_TARGET_INFO): Likewise.
+	* config/sol2-d.cc: Include tm_d.h instead of tm.h and memmodel.h.
+	* config/sparc/sparc-d.cc: Include tm_d.h.
+	* config/sparc/sparc-protos.h (sparc_d_target_versions): Move to
+	config/sparc/sparc-d.h.
+	(sparc_d_register_target_info): Likewise.
+	* config/sparc/sparc.h (TARGET_D_CPU_VERSIONS): Likewise.
+	(TARGET_D_REGISTER_CPU_TARGET_INFO): Likewise.
+	* configure: Regenerate.
+	* configure.ac (tm_d_file): Remove defaults.h.
+	(tm_d_include_list): Remove options.h and insn-constants.h.
+	* config/aarch64/aarch64-d.h: New file.
+	* config/arm/arm-d.h: New file.
+	* config/i386/i386-d.h: New file.
+	* config/mips/mips-d.h: New file.
+	* config/pa/pa-d.h: New file.
+	* config/riscv/riscv-d.h: New file.
+	* config/rs6000/rs6000-d.h: New file.
+	* config/s390/s390-d.h: New file.
+	* config/sparc/sparc-d.h: New file.
+
+2022-11-30  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (addvdi3): Force operand 2 to a register.
+	Remove "addi,tsv,*" instruction from unamed pattern.
+	(subvdi3): Force operand 1 to a register.
+	Remove "subi,tsv" instruction from from unamed pattern.
+
+2022-11-29  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backported from master:
+	2022-11-08  Max Filippov  <jcmvbkbc@gmail.com>
+
+	PR rtl-optimization/107482
+	* ira-color.cc (assign_hard_reg): Only call
+	update_costs_from_copies when retry_p is false.
+
+2022-11-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* range-op.cc (operator_bitwise_xor::op1_range): Fix thinko.
+
+2022-11-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-loop-distribution.cc (loop_distribution::classify_builtin_ldst):
+	Bail out if source and destination do not have the same storage order.
+
+2022-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/107748
+	* config/i386/avx512fp16intrin.h (_mm512_castph512_ph128,
+	_mm512_castph512_ph256, _mm512_castph128_ph512,
+	_mm512_castph256_ph512, _mm512_set1_pch): Uglify names of local
+	variables and union members.
+	* config/i386/avx512fp16vlintrin.h (_mm256_castph256_ph128,
+	_mm256_castph128_ph256, _mm256_set1_pch, _mm_set1_pch): Likewise.
+	* config/i386/smmintrin.h (_mm_extract_ps): Likewise.
+	* config/i386/avx512bf16intrin.h (_mm_cvtsbh_ss): Likewise.
+
+2022-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/107183
+	* reg-stack.cc (next_flags_user): Add DEBUG_SEEN argument.
+	If >= 0 and a DEBUG_INSN would be otherwise returned, set
+	DEBUG_SEEN to 1 and ignore it.
+	(swap_rtx_condition): Add DEBUG_SEEN argument.  In >= 0
+	mode only set DEBUG_SEEN to 1 if problematic DEBUG_ISNSs
+	were seen and revert all changes on success in that case.
+	Don't try to recog_memoized DEBUG_INSNs.
+	(compare_for_stack_reg): Adjust swap_rtx_condition caller.
+	If it returns true and debug_seen is 1, call swap_rtx_condition
+	again with debug_seen -1.
+
+2022-11-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2022-11-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* config/nvptx/nvptx.h (STARTFILE_SPEC): Fix 'crt0.o' for
+	'-mmainkernel'.
+
+2022-11-19  Jinyang He  <hejinyang@loongson.cn>
+
+	Backported from master:
+	2022-11-18  Jinyang He  <hejinyang@loongson.cn>
+
+	PR target/107713
+	* config/loongarch/sync.md
+	(atomic_cas_value_exchange_7_<mode>): New define_insn.
+	(atomic_exchange): Use atomic_cas_value_exchange_7_si instead of
+	atomic_cas_value_cmp_and_7_si.
+
+2022-11-16  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2022-11-14  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	* config/aarch64/aarch64-cores.def (AARCH64_CORE): Add ampere1a.
+	* config/aarch64/aarch64-cost-tables.h: Add ampere1a_extra_costs.
+	* config/aarch64/aarch64-fusion-pairs.def (AARCH64_FUSION_PAIR):
+	Define a new fusion pair for A+B+1/A-B-1 (i.e., add/subtract two
+	registers and then +1/-1).
+	* config/aarch64/aarch64-tune.md: Regenerate.
+	* config/aarch64/aarch64.cc (aarch_macro_fusion_pair_p): Implement
+	idiom-matcher for the new fusion pair.
+	* doc/invoke.texi: Add ampere1a.
+
+2022-11-16  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-10-19  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/107206
+	* tree-sra.cc (struct access): New field grp_result_of_prop_from_lhs.
+	(analyze_access_subtree): Do not create replacements for accesses with
+	this flag when not toally scalarizing.
+	(propagate_subaccesses_from_lhs): Set the new flag.
+
+2022-11-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* alias.cc (init_alias_analysis): Do not record sets to the hard
+	frame pointer if the frame pointer has not been eliminated.
+
+2022-11-08  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-10-25  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107304
+	* expr.cc (get_inner_reference): Always use TYPE_MODE for vector
+	field with vector raw mode.
+
+2022-11-07  Cui,Lili  <lili.cui@intel.com>
+
+	* config/i386/driver-i386.cc (host_detect_local_cpu):
+	Move sapphirerapids out of AVX512_VP2INTERSECT.
+	* config/i386/i386.h: Remove AVX512_VP2INTERSECT from PTA_SAPPHIRERAPIDS
+	* doc/invoke.texi: Remove AVX512_VP2INTERSECT from SAPPHIRERAPIDS
+
+2022-11-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c/41041
+	* doc/cppopts.texi: Document -fwide-exec-charset defaults
+	correctly.
+
+2022-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* fold-const.cc (operand_compare::operand_equal_p) <COMPONENT_REF>:
+	Do not take into account operand 2.
+	(operand_compare::hash_operand) <COMPONENT_REF>: Likewise.
+
+2022-11-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-11-03  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/107404
+	* config/i386/i386.md (eliminate reg-reg move by inverting the
+	condition of a cmove #2 peephole2): Check if eliminated move
+	initialized a register, used in the moved instruction.
+
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-10-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/107121
+	* tree-cfg.cc (verify_gimple_call): Fix a typo in diagnostics,
+	DEFFERED_INIT -> DEFERRED_INIT.
+
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107001
+	* omp-low.cc (lower_omp_taskgroup): Don't add GOMP_RETURN statement
+	at the end.
+	* omp-expand.cc (build_omp_regions_1): Clarify GF_OMP_TARGET_KIND_DATA
+	is not stand-alone directive.  For GIMPLE_OMP_TASKGROUP, also don't
+	update parent.
+	(omp_make_gimple_edges) <case GIMPLE_OMP_TASKGROUP>: Reset
+	cur_region back after new_omp_region.
+
+2022-10-28  Julian Brown  <julian@codesourcery.com>
+
+	Backported from master:
+	2022-10-28  Julian Brown  <julian@codesourcery.com>
+		    Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR middle-end/90115
+	* omp-low.cc (oacc_privatization_candidate_p): Artificial vars are not
+	privatization candidates.
+
+2022-10-27  Torbjörn SVENSSON  <torbjorn.svensson@foss.st.com>
+
+	Backported from master:
+	2022-10-27  Torbjörn SVENSSON  <torbjorn.svensson@foss.st.com>
+		    Yvan ROUX  <yvan.roux@foss.st.com>
+
+	* ira.cc: Resize array after reg number increased.
+
+2022-10-26  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2022-10-06  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	* config/aarch64/aarch64-cores.def (AARCH64_CORE): Update
+	Ampere-1 core entry.
+
+2022-10-26  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2022-10-06  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	* config/aarch64/driver-aarch64.cc (readline): Fix off-by-one.
+
+2022-10-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* profile.cc (branch_prob): Be prepared for ignored functions with
+	DECL_SOURCE_LOCATION set to UNKNOWN_LOCATION.
+
+2022-10-25  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2022-10-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	PR target/106355
+	* config/s390/s390.cc (s390_call_saved_register_used): For a
+	parameter with BLKmode fix determining number of consecutive
+	registers.
+
+2022-10-25  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-10-25  Martin Liska  <mliska@suse.cz>
+
+	PR target/107364
+	* common/config/i386/i386-cpuinfo.h (enum processor_vendor):
+	Fix pedantic warning.
+
+2022-10-25  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-10-24  Martin Liska  <mliska@suse.cz>
+
+	PR target/107364
+	* common/config/i386/i386-cpuinfo.h (enum processor_vendor):
+	  Reorder enum values as BUILTIN_VENDOR_MAX should not point
+	  in the middle of the valid enum values.
+
+2022-10-21  Julian Brown  <julian@codesourcery.com>
+
+	Backported from master:
+	2022-10-20  Julian Brown  <julian@codesourcery.com>
+
+	PR target/105421
+	* config/gcn/gcn.cc (gcn_detect_incoming_pointer_arg): Any pointer
+	argument forces FLAT addressing mode, not just
+	pointer-to-non-aggregate.
+
+2022-10-21  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107323
+	* tree-loop-distribution.cc (pg_unmark_merged_alias_ddrs):
+	New function.
+	(loop_distribution::break_alias_scc_partitions): Revert
+	postorder save/restore from the PR94125 fix.  Instead
+	make sure to not ignore edges from SCCs we are going to
+	merge.
+
+2022-10-20  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2022-05-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR middle-end/100400
+	* omp-oacc-kernels-decompose.cc
+	(visit_loops_in_gang_single_region) <GIMPLE_OMP_FOR>: Explicitly
+	call 'internal_error'.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64-sve.md (*aarch64_brk<brk_op>_cc): Remove
+	merging alternative.
+	(*aarch64_brk<brk_op>_ptest): Likewise.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/iterators.md (SVE_BRKP): New iterator.
+	* config/aarch64/aarch64-sve.md (*aarch64_brkn_cc): New pattern.
+	(*aarch64_brkn_ptest): Likewise.
+	(*aarch64_brk<brk_op>_cc): Restrict to SVE_BRKP.
+	(*aarch64_brk<brk_op>_ptest): Likewise.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (AARCH64_FL_FOR_ARCH8_3): Add
+	AARCH64_FL_RCPC.
+	(AARCH64_ISA_RCPC): New macro.
+	* config/aarch64/aarch64-cores.def (thunderx3t110, zeus, neoverse-v1)
+	(neoverse-512tvb, saphira): Remove RCPC from these Armv8.3-A+ cores.
+	* config/aarch64/aarch64-c.cc (aarch64_update_cpp_builtins): Define
+	__ARM_FEATURE_RCPC when appropriate.
+
+2022-10-19  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/96072
+	* config/rs6000/rs6000-logue.cc (rs6000_emit_epilogue): Update the
+	condition for adding REG_CFA_DEF_CFA reg note with
+	frame_pointer_needed_indeed.
+
+2022-10-19  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/100645
+	* config/rs6000/vector.md (vec_shr_<mode>): Replace condition
+	TARGET_ALTIVEC with VECTOR_UNIT_ALTIVEC_OR_VSX_P.
+
+2022-10-17  Pat Haugen  <pthaugen@linux.ibm.com>
+
+	Backported from master:
+	2022-05-17  Pat Haugen  <pthaugen@linux.ibm.com>
+
+	PR target/99685
+	* config/rs6000/rs6000-call.cc (rs6000_function_arg_advance_1): Bump
+	register count when not splitting IEEE 128-bit Complex.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107254
+	* tree-vect-slp.cc (vect_slp_analyze_node_operations_1):
+	For permutes also analyze live lanes.
+	(vect_schedule_slp_node): For permutes also code generate
+	live lane extracts.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107212
+	* tree-vect-loop.cc (vectorizable_reduction): Make sure to
+	set STMT_VINFO_REDUC_DEF for all live lanes in a SLP
+	reduction.
+	(vectorizable_live_operation): Do not pun to the SLP
+	node representative for reduction epilogue generation.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107160
+	* tree-vect-loop.cc (vect_create_epilog_for_reduction):
+	Do not register accumulator if we failed to reduce it
+	to a single vector.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107107
+	* tree-ssa-sccvn.cc (visit_reference_op_store): Do not
+	affect value-numbering when doing the tail merging
+	MODIFY_EXPR lookup.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106922
+	* tree-ssa-sccvn.cc (vn_reference_lookup_3): Allow
+	an arbitrary number of same valued skipped stores.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106922
+	* tree-ssa-sccvn.cc (vn_walk_cb_data::same_val): New member.
+	(vn_walk_cb_data::finish): Perform delayed verification of
+	a skipped may-alias.
+	(vn_reference_lookup_pieces): Likewise.
+	(vn_reference_lookup): Likewise.
+	(vn_reference_lookup_3): When skipping stores of the same
+	value also handle constant stores that are more than a
+	single VDEF away by delaying the verification.
+
+2022-10-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/107248
+	* config/sparc/sparc.cc (sparc_expand_prologue): Emit a frame
+	blockage for leaf functions.
+	(sparc_flat_expand_prologue): Emit frame instead of full blockage.
+	(sparc_expand_epilogue): Emit a frame blockage for leaf functions.
+	(sparc_flat_expand_epilogue): Emit frame instead of full blockage.
+
+2022-10-13  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-10-04  Tobias Burnus  <tobias@codesourcery.com>
+
+	* doc/install.texi (Specific): Add missing items to bullet list.
+	(amdgcn): Update LLVM requirements, use version not date for newlib.
+	(nvptx): Use version not git hash for newlib.
+
+2022-10-11  Christophe Lyon  <christophe.lyon@arm.com>
+
+	* config/arm/mve.md (mve_vqshluq_n_s<mode>): Use
+	MVE_pred/MVE_constraint instead of mve_imm_7/Ra.
+	(mve_vqshluq_m_n_s<mode>): Likewise.
+	(mve_vqrshrnbq_n_<supf><mode>): Use MVE_pred3/MVE_constraint3
+	instead of mve_imm_8/Rb.
+	(mve_vqrshrunbq_n_s<mode>): Likewise.
+	(mve_vqrshrntq_n_<supf><mode>): Likewise.
+	(mve_vqrshruntq_n_s<mode>): Likewise.
+	(mve_vrshrnbq_n_<supf><mode>): Likewise.
+	(mve_vrshrntq_n_<supf><mode>): Likewise.
+	(mve_vqrshrnbq_m_n_<supf><mode>): Likewise.
+	(mve_vqrshrntq_m_n_<supf><mode>): Likewise.
+	(mve_vrshrnbq_m_n_<supf><mode>): Likewise.
+	(mve_vrshrntq_m_n_<supf><mode>): Likewise.
+	(mve_vqrshrunbq_m_n_s<mode>): Likewise.
+	(mve_vsriq_n_<supf><mode): Use MVE_pred2/MVE_constraint2 instead
+	of mve_imm_selective_upto_8/Rg.
+	(mve_vsriq_m_n_<supf><mode>): Likewise.
+	(cherry-picked from c3fb6658c7670e446f2fd00984404d971e416b3c)
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106934
+	* tree-ssa.cc (non_rewritable_mem_ref_base): Avoid BIT_FIELD_REFs
+	of bitfields.
+	(maybe_rewrite_mem_ref_base): Likewise.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106922
+	* tree-ssa-pre.cc (translate_vuse_through_block): Only
+	keep the VUSE if its def dominates PHIBLOCK.
+	(prune_clobbered_mems): Rewrite logic so we check whether
+	a value dies in a block when the VUSE def doesn't dominate it.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106892
+	* tree-predcom.cc (ref_at_iteration): Do not associate the
+	constant part of the offset into the MEM_REF offset
+	operand, across a non-zero offset.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-08-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105937
+	* tree-ssa-uninit.cc (find_uninit_use): Do not queue PHIs
+	on backedges.
+	(execute_late_warn_uninitialized): Mark backedges.
+
+2022-10-03  Sergei Trofimovich  <siarheit@google.com>
+
+	Backported from master:
+	2022-10-03  Sergei Trofimovich  <siarheit@google.com>
+
+	PR target/107064
+	* config/i386/t-i386: Add build-time dependencies against
+	i386-builtin-types.inc to i386-builtins.o, i386-expand.o,
+	i386-features.o.
+
+2022-09-29  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-09-28  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107061
+	* config/i386/predicates.md (encodekey128_operation): Check
+	XMM4-XMM6 as clobbered.
+	(encodekey256_operation): Likewise.
+	* config/i386/sse.md (encodekey128u32): Clobber XMM4-XMM6.
+	(encodekey256u32): Likewise.
+
+2022-09-29  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-09-26  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR middle-end/106982
+	* omp-low.cc (lower_oacc_reductions): Add some unshare_expr.
+
+2022-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2022-09-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64-cores.def (neoverse-v2): New entry.
+	(demeter): Update tunings to neoversev2.
+	* config/aarch64/aarch64-tune.md: Regenerate.
+	* config/aarch64/aarch64.cc (demeter_addrcost_table): Rename to
+	neoversev2_addrcost_table.
+	(demeter_regmove_cost): Rename to neoversev2_addrcost_table.
+	(demeter_advsimd_vector_cost): Rename to neoversev2_advsimd_vector_cost.
+	(demeter_sve_vector_cost): Rename to neoversev2_sve_vector_cost.
+	(demeter_scalar_issue_info): Rename to neoversev2_scalar_issue_info.
+	(demeter_advsimd_issue_info): Rename to neoversev2_advsimd_issue_info.
+	(demeter_sve_issue_info): Rename to neoversev2_sve_issue_info.
+	(demeter_vec_issue_info): Rename to neoversev2_vec_issue_info.
+	Update references to above.
+	(demeter_vector_cost): Rename to neoversev2_vector_cost.
+	(demeter_tunings): Rename to neoversev2_tunings.
+	(aarch64_vec_op_count::rename_cycles_per_iter): Use
+	neoversev2_sve_issue_info instead of demeter_sve_issue_info.
+	* doc/invoke.texi (AArch64 Options): Document neoverse-v2.
+
+2022-09-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-09-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/106491
+	* config/aarch64/aarch64-sve-builtins.cc (scalar_types)
+	(acle_vector_types, acle_svpattern, acle_svprfop): Add GTY
+	markup to (new) extern declarations instead of to the main
+	definition.
+
+2022-09-21  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-13  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/104482
+	* config/rs6000/rs6000-c.cc (altivec_resolve_overloaded_builtin): Fix
+	the equality check for argument number, and move this hunk ahead.
+
+2022-09-21  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-13  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	PR target/105485
+	* config/rs6000/rs6000-builtin.cc (rs6000_gimple_fold_builtin): Add
+	the handling for unresolved overloaded builtin function.
+	(rs6000_expand_builtin): Likewise.
+
+2022-09-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106860
+	* tree-ssa-loop-split.cc (split_loop): Find the exit to
+	latch edge from the loop exit edge instead of from the
+	latch.  Verify we're going to find it.
+
+2022-09-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106841
+	* tree-vect-slp.cc (vect_detect_hybrid_slp): Also process
+	scatter/gather offset.
+
+2022-09-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106809
+	* tree-ssa-sccvn.cc (dominaged_by_p_w_unex): Check we have
+	more than one successor before doing extra work.
+
+2022-09-08  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rs6000/rtems.h (CPP_OS_DEFAULT_SPEC): Define __PPC_VRSAVE__ if
+	-mvrsave is present.
+	* config/rs6000/t-rtems: Add -mvrsave multilib variants for
+	-mcpu=e6500.
+
+2022-09-03  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-09-01  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/101322
+	* config/rs6000/rs6000-builtin.cc (rs6000_gimple_fold_mma_builtin):
+	Enforce the use of a valid MMA pointer type.
+
+2022-09-02  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2022-08-03  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR rtl-optimization/106187
+	* alias.h (mems_same_for_tbaa_p): Declare.
+	* alias.cc (mems_same_for_tbaa_p): New function.
+	* dse.cc (record_store): Use it instead of open-coding
+	alias check.
+	* cselib.h (cselib_redundant_set_p): Declare.
+	* cselib.cc: Include alias.h
+	(cselib_redundant_set_p): New function.
+	* cfgcleanup.cc: (mark_effect): Use cselib_redundant_set_p instead
+	of rtx_equal_for_cselib_p.
+	* postreload.cc (reload_cse_simplify): Use cselib_redundant_set_p.
+	(reload_cse_noop_set_p): Delete.
+
+2022-09-02  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2022-05-13  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/105463
+	* config/arm/mve.md (*movmisalign<mode>_mve_store): Use
+	mve_memory_operand.
+	(*movmisalign<mode>_mve_load): Likewise.
+	* config/arm/vec-common.md (movmisalign<mode>): Convert to generator
+	form...
+	(@movmisalign<mode>): ... thus.  Use generic predicates and then
+	rework operands if they are not valid.  For MVE rework to a
+	narrower element size if the alignment is not high enough.
+
+2022-09-02  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2022-09-01  Tamar Christina  <tamar.christina@arm.com>
+
+	PR other/106782
+	* config/aarch64/aarch64.cc
+	(aarch64_vector_costs::prefer_unrolled_loop): Replace %u with
+	HOST_WIDE_INT_PRINT_UNSIGNED.
+
+2022-09-01  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR other/106782
+	* tree-vect-slp.cc (vect_print_slp_tree): Use
+	HOST_WIDE_INT_PRINT_UNSIGNED instead of %u.
+	* tree-vect-loop.cc (vect_estimate_min_profitable_iters): Use
+	HOST_WIDE_INT_PRINT_UNSIGNED instead of %d.
+	* tree-vect-slp-patterns.cc (vect_pattern_validate_optab): Use %G
+	instead of %T and STMT_VINFO_STMT (SLP_TREE_REPRESENTATIVE (node))
+	instead of SLP_TREE_DEF_TYPE (node).
+
+2022-08-30  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2022-08-12  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/106524
+	* config/aarch64/aarch64-sve.md (*fcmuo<mode>_nor_combine,
+	*fcmuo<mode>_bic_combine): Don't accept comparisons against zero.
+
+2022-08-29  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-08-28  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/106017
+	* config/rs6000/rs6000.cc (rs6000_invalid_conversion): Remove handling
+	of MMA pointer conversions.
+
+2022-08-29  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-08-23  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/106714
+	* config/i386/amxtileintrin.h (_tile_loadd_internal): Cast to
+	__PTRDIFF_TYPE__.
+	(_tile_stream_loadd_internal): Likewise.
+	(_tile_stored_internal): Likewise.
+
+2022-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-08-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/106721
+	* config/i386/sse.md (i128vldq): Add V16HF entry.
+	(avx512er_vmrcp28<mode><mask_name><round_saeonly_name>): Fix typo,
+	mask_opernad3 -> mask_operand3.
+
+2022-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-08-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/106590
+	* ifcvt.cc (check_for_cc_cmp_clobbers): New function.
+	(noce_convert_multiple_sets_1): If SEQ sets or clobbers any regs
+	mentioned in cc_cmp or rev_cc_cmp, don't consider seq2 for any
+	further conditional moves.
+
+2022-08-26  liuhongt  <hongtao.liu@intel.com>
+
+	PR target/106704
+	* config/i386/i386-builtin.def (BDESC): Add
+	CODE_FOR_avx_blendvpd256/CODE_FOR_avx_blendvps256 to
+	corresponding builtins.
+	* config/i386/i386.cc (ix86_gimple_fold_builtin):
+	Don't fold IX86_BUILTIN_PBLENDVB256, IX86_BUILTIN_BLENDVPS256,
+	IX86_BUILTIN_BLENDVPD256 w/o TARGET_AVX2.
+
+2022-08-25  Chenghua Xu  <xuchenghua@loongson.cn>
+
+	Backported from master:
+	2022-08-25  Chenghua Xu  <xuchenghua@loongson.cn>
+
+	PR target/106459
+	* config/loongarch/loongarch.cc (loongarch_build_integer):
+	Use HOST_WIDE_INT.
+	* config/loongarch/loongarch.h (IMM_REACH): Likewise.
+	(HWIT_1U): New Defined.
+	(LU12I_OPERAND): Use HOST_WIDE_INT.
+	(LU32I_OPERAND): Likewise.
+	(LU52I_OPERAND): Likewise.
+	(HWIT_UC_0xFFF): Likwise.
+
+2022-08-24  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-08-16  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR tree-optimization/106322
+	* tree-vect-stmts.cc (vectorizable_call): Don't allow
+	vect_emulated_vector_p type for both vectype_in and vectype_out.
+
+2022-08-24  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	Backported from master:
+	2022-08-16  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	PR target/103353
+	* config/rs6000/mma.md (define_expand movoo): Move TARGET_MMA condition
+	check to preparation statements and add handlings for !TARGET_MMA.
+	(define_expand movxo): Likewise.
+
+2022-08-23  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-08-19  Tobias Burnus  <tobias@codesourcery.com>
+
+	* config/gcn/mkoffload.cc (main): Add dbgobj to files_to_cleanup.
+
+2022-08-23  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-08-17  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR middle-end/106548
+	* omp-low.cc (lower_rec_input_clauses): Use build_outer_var_ref
+	for 'simd' linear-step values that are variable.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
index 918be360b57..847dee113d4 100644
--- a/gcc/DATESTAMP
+++ b/gcc/DATESTAMP
@@ -1 +1 @@
-20220819
+20230119
diff --git a/gcc/alias.cc b/gcc/alias.cc
index 8c08452e0ac..c62837dd854 100644
--- a/gcc/alias.cc
+++ b/gcc/alias.cc
@@ -389,6 +389,20 @@ refs_same_for_tbaa_p (tree earlier, tree later)
 	  || alias_set_subset_of (later_base_set, earlier_base_set));
 }
 
+/* Similar to refs_same_for_tbaa_p() but for use on MEM rtxs.  */
+bool
+mems_same_for_tbaa_p (rtx earlier, rtx later)
+{
+  gcc_assert (MEM_P (earlier));
+  gcc_assert (MEM_P (later));
+
+  return ((MEM_ALIAS_SET (earlier) == MEM_ALIAS_SET (later)
+	   || alias_set_subset_of (MEM_ALIAS_SET (later),
+				   MEM_ALIAS_SET (earlier)))
+	  && (!MEM_EXPR (earlier)
+	      || refs_same_for_tbaa_p (MEM_EXPR (earlier), MEM_EXPR (later))));
+}
+
 /* Returns a pointer to the alias set entry for ALIAS_SET, if there is
    such an entry, or NULL otherwise.  */
 
@@ -3355,6 +3369,10 @@ memory_modified_in_insn_p (const_rtx mem, const_rtx insn)
 void
 init_alias_analysis (void)
 {
+  const bool frame_pointer_eliminated
+    = reload_completed
+      && !frame_pointer_needed
+      && targetm.can_eliminate (FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM);
   unsigned int maxreg = max_reg_num ();
   int changed, pass;
   int i;
@@ -3432,12 +3450,8 @@ init_alias_analysis (void)
       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
 	if (static_reg_base_value[i]
 	    /* Don't treat the hard frame pointer as special if we
-	       eliminated the frame pointer to the stack pointer instead.  */
-	    && !(i == HARD_FRAME_POINTER_REGNUM
-		 && reload_completed
-		 && !frame_pointer_needed
-		 && targetm.can_eliminate (FRAME_POINTER_REGNUM,
-					   STACK_POINTER_REGNUM)))
+	       eliminated the frame pointer to the stack pointer.  */
+	    && !(i == HARD_FRAME_POINTER_REGNUM && frame_pointer_eliminated))
 	  {
 	    new_reg_base_value[i] = static_reg_base_value[i];
 	    bitmap_set_bit (reg_seen, i);
@@ -3453,10 +3467,15 @@ init_alias_analysis (void)
 		{
 		  rtx note, set;
 
+		  /* Treat the hard frame pointer as special unless we
+		     eliminated the frame pointer to the stack pointer.  */
+		  if (!frame_pointer_eliminated
+		      && modified_in_p (hard_frame_pointer_rtx, insn))
+		    continue;
+
 		  /* If this insn has a noalias note, process it,  Otherwise,
 		     scan for sets.  A simple set will have no side effects
 		     which could change the base value of any other register.  */
-
 		  if (GET_CODE (PATTERN (insn)) == SET
 		      && REG_NOTES (insn) != 0
 		      && find_reg_note (insn, REG_NOALIAS, NULL_RTX))
diff --git a/gcc/alias.h b/gcc/alias.h
index b2596518ac9..ee3db466763 100644
--- a/gcc/alias.h
+++ b/gcc/alias.h
@@ -40,6 +40,7 @@ tree reference_alias_ptr_type_1 (tree *);
 bool alias_ptr_types_compatible_p (tree, tree);
 int compare_base_decls (tree, tree);
 bool refs_same_for_tbaa_p (tree, tree);
+bool mems_same_for_tbaa_p (rtx, rtx);
 
 /* This alias set can be used to force a memory to conflict with all
    other memories, creating a barrier across which no memory reference
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index 6fe340fbb73..97fa7792343 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,15 @@
+2022-12-19  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-12-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c/98487
+	* c-format.cc (check_function_format): Use get_attribute_name.
+
+2022-09-27  Marek Polacek  <polacek@redhat.com>
+
+	* c-format.cc (c_keywords): Drop nothrow.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/gcc/c-family/c-format.cc b/gcc/c-family/c-format.cc
index ebdac57f943..fe5ed48b86b 100644
--- a/gcc/c-family/c-format.cc
+++ b/gcc/c-family/c-format.cc
@@ -1205,7 +1205,7 @@ check_function_format (const_tree fntype, tree attrs, int nargs,
 	      for (c = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));
 		   c;
 		   c = TREE_CHAIN (c))
-		if (is_attribute_p ("format", TREE_PURPOSE (c))
+		if (is_attribute_p ("format", get_attribute_name (c))
 		    && (decode_format_type (IDENTIFIER_POINTER
 					    (TREE_VALUE (TREE_VALUE (c))))
 			== info.format_type))
@@ -2933,7 +2933,6 @@ static const token_t c_keywords[] =
    NAME ("noinline", NULL),
    NAME ("nonnull", NULL),
    NAME ("noreturn", NULL),
-   NAME ("nothrow", NULL),
    NAME ("offsetof", NULL),
    NAME ("readonly", "read-only"),
    NAME ("readwrite", "read-write"),
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index ed54905e78b..9ca66f0b2d5 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,31 @@
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-10-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/107358
+	* c-typeck.cc (build_binary_op): Pass operands before excess precision
+	promotions to scalar_to_vector call.
+
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/106981
+	* c-typeck.cc (c_tree_equal): Only strip NON_LVALUE_EXPRs at the
+	start.  For CONSTANT_CLASS_P or CASE_CONVERT: return false if t1 and
+	t2 have different types.
+
+2022-09-19  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-09-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c/106947
+	* c-typeck.cc (maybe_warn_for_null_address): Don't emit stray
+	notes.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/gcc/c/c-typeck.cc b/gcc/c/c-typeck.cc
index e130196a3a7..603b03fe1a5 100644
--- a/gcc/c/c-typeck.cc
+++ b/gcc/c/c-typeck.cc
@@ -11681,18 +11681,19 @@ maybe_warn_for_null_address (location_t loc, tree op, tree_code code)
       || from_macro_expansion_at (loc))
     return;
 
+  bool w;
   if (code == EQ_EXPR)
-    warning_at (loc, OPT_Waddress,
-		"the comparison will always evaluate as %<false%> "
-		"for the address of %qE will never be NULL",
-		op);
+    w = warning_at (loc, OPT_Waddress,
+		    "the comparison will always evaluate as %<false%> "
+		    "for the address of %qE will never be NULL",
+		    op);
   else
-    warning_at (loc, OPT_Waddress,
-		"the comparison will always evaluate as %<true%> "
-		"for the address of %qE will never be NULL",
-		op);
+    w = warning_at (loc, OPT_Waddress,
+		    "the comparison will always evaluate as %<true%> "
+		    "for the address of %qE will never be NULL",
+		    op);
 
-  if (DECL_P (op))
+  if (w && DECL_P (op))
     inform (DECL_SOURCE_LOCATION (op), "%qD declared here", op);
 }
 
@@ -11917,8 +11918,8 @@ build_binary_op (location_t location, enum tree_code code,
   if ((gnu_vector_type_p (type0) && code1 != VECTOR_TYPE)
       || (gnu_vector_type_p (type1) && code0 != VECTOR_TYPE))
     {
-      enum stv_conv convert_flag = scalar_to_vector (location, code, op0, op1,
-						     true);
+      enum stv_conv convert_flag = scalar_to_vector (location, code, orig_op0,
+						     orig_op1, true);
 
       switch (convert_flag)
 	{
@@ -15921,14 +15922,10 @@ c_tree_equal (tree t1, tree t2)
   if (!t1 || !t2)
     return false;
 
-  for (code1 = TREE_CODE (t1);
-       CONVERT_EXPR_CODE_P (code1)
-	 || code1 == NON_LVALUE_EXPR;
+  for (code1 = TREE_CODE (t1); code1 == NON_LVALUE_EXPR;
        code1 = TREE_CODE (t1))
     t1 = TREE_OPERAND (t1, 0);
-  for (code2 = TREE_CODE (t2);
-       CONVERT_EXPR_CODE_P (code2)
-	 || code2 == NON_LVALUE_EXPR;
+  for (code2 = TREE_CODE (t2); code2 == NON_LVALUE_EXPR;
        code2 = TREE_CODE (t2))
     t2 = TREE_OPERAND (t2, 0);
 
@@ -15939,6 +15936,9 @@ c_tree_equal (tree t1, tree t2)
   if (code1 != code2)
     return false;
 
+  if (CONSTANT_CLASS_P (t1) && !comptypes (TREE_TYPE (t1), TREE_TYPE (t2)))
+    return false;
+
   switch (code1)
     {
     case INTEGER_CST:
@@ -16058,6 +16058,11 @@ c_tree_equal (tree t1, tree t2)
 	return true;
       }
 
+    CASE_CONVERT:
+      if (!comptypes (TREE_TYPE (t1), TREE_TYPE (t2)))
+	return false;
+      break;
+
     default:
       break;
     }
diff --git a/gcc/cfgcleanup.cc b/gcc/cfgcleanup.cc
index 335af4911bb..446718d5ecf 100644
--- a/gcc/cfgcleanup.cc
+++ b/gcc/cfgcleanup.cc
@@ -208,7 +208,7 @@ mark_effect (rtx exp, regset nonequal)
       return false;
 
     case SET:
-      if (rtx_equal_for_cselib_p (SET_DEST (exp), SET_SRC (exp)))
+      if (cselib_redundant_set_p (exp))
 	return false;
       dest = SET_DEST (exp);
       if (dest == pc_rtx)
diff --git a/gcc/cfghooks.cc b/gcc/cfghooks.cc
index e435891fac6..c0b7bdcd9b2 100644
--- a/gcc/cfghooks.cc
+++ b/gcc/cfghooks.cc
@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "diagnostic-core.h"
 #include "dumpfile.h"
 #include "cfganal.h"
+#include "tree.h"
 #include "tree-ssa.h"
 #include "cfgloop.h"
 #include "sreal.h"
diff --git a/gcc/common/config/i386/cpuinfo.h b/gcc/common/config/i386/cpuinfo.h
index 4abd5480d28..8843f43be54 100644
--- a/gcc/common/config/i386/cpuinfo.h
+++ b/gcc/common/config/i386/cpuinfo.h
@@ -55,43 +55,49 @@ struct __processor_model2
 static inline int
 has_cpu_feature (struct __processor_model *cpu_model,
 		 unsigned int *cpu_features2,
-		 enum processor_features f)
+		 enum processor_features feature)
 {
-  unsigned int i;
+  unsigned index, offset;
+  unsigned f = feature;
+
   if (f < 32)
     {
       /* The first 32 features.  */
-      return cpu_model->__cpu_features[0] & (1U << (f & 31));
+      return cpu_model->__cpu_features[0] & (1U << f);
+    }
+  else
+    {
+      /* The rest of features.  cpu_features2[i] contains features from
+	 (32 + i * 32) to (31 + 32 + i * 32), inclusively.  */
+      f -= 32;
+      index = f / 32;
+      offset = f % 32;
+      return cpu_features2[index] & (1U << offset);
     }
-  /* The rest of features.  cpu_features2[i] contains features from
-     (32 + i * 32) to (31 + 32 + i * 32), inclusively.  */
-  for (i = 0; i < SIZE_OF_CPU_FEATURES; i++)
-    if (f < (32 + 32 + i * 32))
-    return cpu_features2[i] & (1U << ((f - (32 + i * 32)) & 31));
-  gcc_unreachable ();
 }
 
 static inline void
 set_cpu_feature (struct __processor_model *cpu_model,
 		 unsigned int *cpu_features2,
-		 enum processor_features f)
+		 enum processor_features feature)
 {
-  unsigned int i;
+  unsigned index, offset;
+  unsigned f = feature;
+
   if (f < 32)
     {
       /* The first 32 features.  */
-      cpu_model->__cpu_features[0] |= (1U << (f & 31));
-      return;
+      cpu_model->__cpu_features[0] |= (1U << f);
+    }
+  else
+    {
+      /* The rest of features.  cpu_features2[i] contains features from
+	 (32 + i * 32) to (31 + 32 + i * 32), inclusively.  */
+      f -= 32;
+      index = f / 32;
+      offset = f % 32;
+      cpu_features2[index] |= (1U << offset);
     }
-  /* The rest of features.  cpu_features2[i] contains features from
-     (32 + i * 32) to (31 + 32 + i * 32), inclusively.  */
-  for (i = 0; i < SIZE_OF_CPU_FEATURES; i++)
-    if (f < (32 + 32 + i * 32))
-      {
-	cpu_features2[i] |= (1U << ((f - (32 + i * 32)) & 31));
-	return;
-      }
-  gcc_unreachable ();
 }
 
 /* Get the specific type of AMD CPU and return AMD CPU name.  Return
diff --git a/gcc/common/config/i386/i386-cpuinfo.h b/gcc/common/config/i386/i386-cpuinfo.h
index 3f6d2013daf..12830a610ca 100644
--- a/gcc/common/config/i386/i386-cpuinfo.h
+++ b/gcc/common/config/i386/i386-cpuinfo.h
@@ -33,8 +33,10 @@ enum processor_vendor
   VENDOR_CENTAUR,
   VENDOR_CYRIX,
   VENDOR_NSC,
-  BUILTIN_VENDOR_MAX = VENDOR_OTHER,
-  VENDOR_MAX
+
+  /* Maximum values must be at the end of this enum.  */
+  VENDOR_MAX,
+  BUILTIN_VENDOR_MAX = VENDOR_OTHER
 };
 
 /* Any new types or subtypes have to be inserted at the end. */
diff --git a/gcc/config.gcc b/gcc/config.gcc
index c5064dd3766..58136821afc 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -566,11 +566,15 @@ tilepro*-*-*)
 esac
 
 tm_file=${cpu_type}/${cpu_type}.h
-tm_d_file=${cpu_type}/${cpu_type}.h
 if test -f ${srcdir}/config/${cpu_type}/${cpu_type}-protos.h
 then
 	tm_p_file=${cpu_type}/${cpu_type}-protos.h
-	tm_d_file="${tm_d_file} ${cpu_type}/${cpu_type}-protos.h"
+fi
+
+tm_d_file=
+if test -f ${srcdir}/config/${cpu_type}/${cpu_type}-d.h
+then
+	tm_d_file="${tm_d_file} ${cpu_type}/${cpu_type}-d.h"
 fi
 
 extra_modes=
@@ -676,7 +680,6 @@ case ${target} in
 *-*-darwin*)
   tmake_file="t-darwin "
   tm_file="${tm_file} darwin.h"
-  tm_d_file="${tm_d_file} tm-dwarf2.h"
   darwin_os=`echo ${target} | sed 's/.*darwin\([0-9.]*\).*$/\1/'`
   darwin_maj=`expr "$darwin_os" : '\([0-9]*\).*'`
   macos_min=`expr "$darwin_os" : '[0-9]*\.\([0-9]*\).*'`
@@ -3552,7 +3555,6 @@ xstormy16-*-elf)
 	# For historical reasons, the target files omit the 'x'.
 	tm_file="dbxelf.h elfos.h newlib-stdint.h stormy16/stormy16.h"
 	tm_p_file=stormy16/stormy16-protos.h
-	tm_d_file="elfos.h stormy16/stormy16.h"
 	md_file=stormy16/stormy16.md
 	out_file=stormy16/stormy16.cc
 	extra_options=stormy16/stormy16.opt
diff --git a/gcc/config/aarch64/aarch64-builtins.cc b/gcc/config/aarch64/aarch64-builtins.cc
index 1b0db677f34..60966fef099 100644
--- a/gcc/config/aarch64/aarch64-builtins.cc
+++ b/gcc/config/aarch64/aarch64-builtins.cc
@@ -2437,7 +2437,7 @@ static rtx
 aarch64_expand_builtin_data_intrinsic (unsigned int fcode, tree exp, rtx target)
 {
   expand_operand ops[2];
-  machine_mode mode = GET_MODE (target);
+  machine_mode mode = TYPE_MODE (TREE_TYPE (exp));
   create_output_operand (&ops[0], target, mode);
   create_input_operand (&ops[1], expand_normal (CALL_EXPR_ARG (exp, 0)), mode);
   enum insn_code icode;
diff --git a/gcc/config/aarch64/aarch64-c.cc b/gcc/config/aarch64/aarch64-c.cc
index 767ee0c763c..a4c407724a7 100644
--- a/gcc/config/aarch64/aarch64-c.cc
+++ b/gcc/config/aarch64/aarch64-c.cc
@@ -202,6 +202,7 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)
 			"__ARM_FEATURE_BF16_SCALAR_ARITHMETIC", pfile);
   aarch64_def_or_undef (TARGET_LS64,
 			"__ARM_FEATURE_LS64", pfile);
+  aarch64_def_or_undef (AARCH64_ISA_RCPC, "__ARM_FEATURE_RCPC", pfile);
 
   /* Not for ACLE, but required to keep "float.h" correct if we switch
      target between implementations that do or do not support ARMv8.2-A
diff --git a/gcc/config/aarch64/aarch64-cores.def b/gcc/config/aarch64/aarch64-cores.def
index 41d95354b6a..70b11eb8044 100644
--- a/gcc/config/aarch64/aarch64-cores.def
+++ b/gcc/config/aarch64/aarch64-cores.def
@@ -69,7 +69,8 @@ AARCH64_CORE("thunderxt81",   thunderxt81,   thunderx,  8A,  AARCH64_FL_FOR_ARCH
 AARCH64_CORE("thunderxt83",   thunderxt83,   thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  0x43, 0x0a3, -1)
 
 /* Ampere Computing ('\xC0') cores. */
-AARCH64_CORE("ampere1", ampere1, cortexa57, 8_6A, AARCH64_FL_FOR_ARCH8_6, ampere1, 0xC0, 0xac3, -1)
+AARCH64_CORE("ampere1", ampere1, cortexa57, 8_6A, AARCH64_FL_FOR_ARCH8_6 | AARCH64_FL_CRYPTO | AARCH64_FL_F16 | AARCH64_FL_RNG | AARCH64_FL_SHA3, ampere1, 0xC0, 0xac3, -1)
+AARCH64_CORE("ampere1a", ampere1a, cortexa57, 8_6A, AARCH64_FL_FOR_ARCH8_6 | AARCH64_FL_CRYPTO | AARCH64_FL_F16 | AARCH64_FL_RNG | AARCH64_FL_SHA3 | AARCH64_FL_MEMTAG, ampere1a, 0xC0, 0xac4, -1)
 /* Do not swap around "emag" and "xgene1",
    this order is required to handle variant correctly. */
 AARCH64_CORE("emag",        emag,      xgene1,    8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, emag, 0x50, 0x000, 3)
@@ -133,17 +134,17 @@ AARCH64_CORE("tsv110",  tsv110, tsv110, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_
 /* ARMv8.3-A Architecture Processors.  */
 
 /* Marvell cores (TX3). */
-AARCH64_CORE("thunderx3t110",  thunderx3t110,  thunderx3t110, 8_3A,  AARCH64_FL_FOR_ARCH8_3 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC | AARCH64_FL_SM4 | AARCH64_FL_SHA3 | AARCH64_FL_F16FML | AARCH64_FL_RCPC8_4, thunderx3t110, 0x43, 0x0b8, 0x0a)
+AARCH64_CORE("thunderx3t110",  thunderx3t110,  thunderx3t110, 8_3A,  AARCH64_FL_FOR_ARCH8_3 | AARCH64_FL_CRYPTO | AARCH64_FL_SM4 | AARCH64_FL_SHA3 | AARCH64_FL_F16FML | AARCH64_FL_RCPC8_4, thunderx3t110, 0x43, 0x0b8, 0x0a)
 
 /* ARMv8.4-A Architecture Processors.  */
 
 /* Arm ('A') cores.  */
-AARCH64_CORE("zeus", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
-AARCH64_CORE("neoverse-v1", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
-AARCH64_CORE("neoverse-512tvb", neoverse512tvb, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoverse512tvb, INVALID_IMP, INVALID_CORE, -1)
+AARCH64_CORE("zeus", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
+AARCH64_CORE("neoverse-v1", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
+AARCH64_CORE("neoverse-512tvb", neoverse512tvb, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoverse512tvb, INVALID_IMP, INVALID_CORE, -1)
 
 /* Qualcomm ('Q') cores. */
-AARCH64_CORE("saphira",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC, saphira,   0x51, 0xC01, -1)
+AARCH64_CORE("saphira",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO, saphira,   0x51, 0xC01, -1)
 
 /* ARMv8-A big.LITTLE implementations.  */
 
@@ -163,7 +164,8 @@ AARCH64_CORE("cortex-r82", cortexr82, cortexa53, 8R, AARCH64_FL_FOR_ARCH8_R, cor
 /* Armv9.0-A Architecture Processors.  */
 
 /* Arm ('A') cores. */
-AARCH64_CORE("cortex-a510",  cortexa510, cortexa55, 9A,  AARCH64_FL_FOR_ARCH9 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_MEMTAG | AARCH64_FL_I8MM | AARCH64_FL_BF16, cortexa53, 0x41, 0xd46, -1)
+AARCH64_CORE("cortex-a510",  cortexa510, cortexa55, 9A,  AARCH64_FL_FOR_ARCH9 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_MEMTAG
+ | AARCH64_FL_I8MM | AARCH64_FL_BF16, cortexa53, 0x41, 0xd46, -1)
 
 AARCH64_CORE("cortex-a710",  cortexa710, cortexa57, 9A,  AARCH64_FL_FOR_ARCH9 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_MEMTAG | AARCH64_FL_I8MM | AARCH64_FL_BF16, neoversen2, 0x41, 0xd47, -1)
 
@@ -171,6 +173,7 @@ AARCH64_CORE("cortex-x2",  cortexx2, cortexa57, 9A,  AARCH64_FL_FOR_ARCH9 | AARC
 
 AARCH64_CORE("neoverse-n2", neoversen2, cortexa57, 9A, AARCH64_FL_FOR_ARCH9 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG | AARCH64_FL_PROFILE, neoversen2, 0x41, 0xd49, -1)
 
-AARCH64_CORE("demeter", demeter, cortexa57, 9A, AARCH64_FL_FOR_ARCH9 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG | AARCH64_FL_PROFILE, demeter, 0x41, 0xd4f, -1)
+AARCH64_CORE("demeter", demeter, cortexa57, 9A, AARCH64_FL_FOR_ARCH9 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG | AARCH64_FL_PROFILE, neoversev2, 0x41, 0xd4f, -1)
+AARCH64_CORE("neoverse-v2", neoversev2, cortexa57, 9A, AARCH64_FL_FOR_ARCH9 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG | AARCH64_FL_PROFILE, neoversev2, 0x41, 0xd4f, -1)
 
 #undef AARCH64_CORE
diff --git a/gcc/config/aarch64/aarch64-cost-tables.h b/gcc/config/aarch64/aarch64-cost-tables.h
index 760d7b30368..48522606fbe 100644
--- a/gcc/config/aarch64/aarch64-cost-tables.h
+++ b/gcc/config/aarch64/aarch64-cost-tables.h
@@ -775,4 +775,111 @@ const struct cpu_cost_table ampere1_extra_costs =
   }
 };
 
+const struct cpu_cost_table ampere1a_extra_costs =
+{
+  /* ALU */
+  {
+    0,                 /* arith.  */
+    0,                 /* logical.  */
+    0,                 /* shift.  */
+    COSTS_N_INSNS (1), /* shift_reg.  */
+    0,                 /* arith_shift.  */
+    COSTS_N_INSNS (1), /* arith_shift_reg.  */
+    0,                 /* log_shift.  */
+    COSTS_N_INSNS (1), /* log_shift_reg.  */
+    0,                 /* extend.  */
+    COSTS_N_INSNS (1), /* extend_arith.  */
+    0,                 /* bfi.  */
+    0,                 /* bfx.  */
+    0,                 /* clz.  */
+    0,                 /* rev.  */
+    0,                 /* non_exec.  */
+    true               /* non_exec_costs_exec.  */
+  },
+  {
+    /* MULT SImode */
+    {
+      COSTS_N_INSNS (3),       /* simple.  */
+      COSTS_N_INSNS (3),       /* flag_setting.  */
+      COSTS_N_INSNS (3),       /* extend.  */
+      COSTS_N_INSNS (4),       /* add.  */
+      COSTS_N_INSNS (4),       /* extend_add.  */
+      COSTS_N_INSNS (19)       /* idiv.  */
+    },
+    /* MULT DImode */
+    {
+      COSTS_N_INSNS (3),       /* simple.  */
+      0,                       /* flag_setting (N/A).  */
+      COSTS_N_INSNS (3),       /* extend.  */
+      COSTS_N_INSNS (4),       /* add.  */
+      COSTS_N_INSNS (4),       /* extend_add.  */
+      COSTS_N_INSNS (35)       /* idiv.  */
+    }
+  },
+  /* LD/ST */
+  {
+    COSTS_N_INSNS (4),         /* load.  */
+    COSTS_N_INSNS (4),         /* load_sign_extend.  */
+    0,                         /* ldrd (n/a).  */
+    0,                         /* ldm_1st.  */
+    0,                         /* ldm_regs_per_insn_1st.  */
+    0,                         /* ldm_regs_per_insn_subsequent.  */
+    COSTS_N_INSNS (5),         /* loadf.  */
+    COSTS_N_INSNS (5),         /* loadd.  */
+    COSTS_N_INSNS (5),         /* load_unaligned.  */
+    0,                         /* store.  */
+    0,                         /* strd.  */
+    0,                         /* stm_1st.  */
+    0,                         /* stm_regs_per_insn_1st.  */
+    0,                         /* stm_regs_per_insn_subsequent.  */
+    COSTS_N_INSNS (2),         /* storef.  */
+    COSTS_N_INSNS (2),         /* stored.  */
+    COSTS_N_INSNS (2),         /* store_unaligned.  */
+    COSTS_N_INSNS (3),         /* loadv.  */
+    COSTS_N_INSNS (3)          /* storev.  */
+  },
+  {
+    /* FP SFmode */
+    {
+      COSTS_N_INSNS (25),      /* div.  */
+      COSTS_N_INSNS (4),       /* mult.  */
+      COSTS_N_INSNS (4),       /* mult_addsub.  */
+      COSTS_N_INSNS (4),       /* fma.  */
+      COSTS_N_INSNS (4),       /* addsub.  */
+      COSTS_N_INSNS (2),       /* fpconst.  */
+      COSTS_N_INSNS (4),       /* neg.  */
+      COSTS_N_INSNS (4),       /* compare.  */
+      COSTS_N_INSNS (4),       /* widen.  */
+      COSTS_N_INSNS (4),       /* narrow.  */
+      COSTS_N_INSNS (4),       /* toint.  */
+      COSTS_N_INSNS (4),       /* fromint.  */
+      COSTS_N_INSNS (4)        /* roundint.  */
+    },
+    /* FP DFmode */
+    {
+      COSTS_N_INSNS (34),      /* div.  */
+      COSTS_N_INSNS (5),       /* mult.  */
+      COSTS_N_INSNS (5),       /* mult_addsub.  */
+      COSTS_N_INSNS (5),       /* fma.  */
+      COSTS_N_INSNS (5),       /* addsub.  */
+      COSTS_N_INSNS (2),       /* fpconst.  */
+      COSTS_N_INSNS (5),       /* neg.  */
+      COSTS_N_INSNS (5),       /* compare.  */
+      COSTS_N_INSNS (5),       /* widen.  */
+      COSTS_N_INSNS (5),       /* narrow.  */
+      COSTS_N_INSNS (6),       /* toint.  */
+      COSTS_N_INSNS (6),       /* fromint.  */
+      COSTS_N_INSNS (5)        /* roundint.  */
+    }
+  },
+  /* Vector */
+  {
+    COSTS_N_INSNS (3),  /* alu.  */
+    COSTS_N_INSNS (3),  /* mult.  */
+    COSTS_N_INSNS (2),  /* movi.  */
+    COSTS_N_INSNS (2),  /* dup.  */
+    COSTS_N_INSNS (2)   /* extract.  */
+  }
+};
+
 #endif
diff --git a/gcc/config/aarch64/aarch64-d.cc b/gcc/config/aarch64/aarch64-d.cc
index d3fcc0b881e..e0e0401631e 100644
--- a/gcc/config/aarch64/aarch64-d.cc
+++ b/gcc/config/aarch64/aarch64-d.cc
@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/aarch64/aarch64-d.h b/gcc/config/aarch64/aarch64-d.h
new file mode 100644
index 00000000000..c605a68ef9f
--- /dev/null
+++ b/gcc/config/aarch64/aarch64-d.h
@@ -0,0 +1,24 @@
+/* Definitions for the D front end on the AArch64 architecture.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Defined in aarch64-d.cc  */
+extern void aarch64_d_target_versions (void);
+extern void aarch64_d_register_target_info (void);
+
+/* Target hooks for D language.  */
+#define TARGET_D_CPU_VERSIONS aarch64_d_target_versions
+#define TARGET_D_REGISTER_CPU_TARGET_INFO aarch64_d_register_target_info
diff --git a/gcc/config/aarch64/aarch64-fusion-pairs.def b/gcc/config/aarch64/aarch64-fusion-pairs.def
index c064fb9b85d..d91f8a2babd 100644
--- a/gcc/config/aarch64/aarch64-fusion-pairs.def
+++ b/gcc/config/aarch64/aarch64-fusion-pairs.def
@@ -36,5 +36,6 @@ AARCH64_FUSION_PAIR ("cmp+branch", CMP_BRANCH)
 AARCH64_FUSION_PAIR ("aes+aesmc", AES_AESMC)
 AARCH64_FUSION_PAIR ("alu+branch", ALU_BRANCH)
 AARCH64_FUSION_PAIR ("alu+cbz", ALU_CBZ)
+AARCH64_FUSION_PAIR ("addsub_2reg_const1", ADDSUB_2REG_CONST1)
 
 #undef AARCH64_FUSION_PAIR
diff --git a/gcc/config/aarch64/aarch64-protos.h b/gcc/config/aarch64/aarch64-protos.h
index df311812e8d..82c8896c7fe 100644
--- a/gcc/config/aarch64/aarch64-protos.h
+++ b/gcc/config/aarch64/aarch64-protos.h
@@ -1049,10 +1049,6 @@ enum aarch64_parse_opt_result aarch64_parse_extension (const char *,
 void aarch64_get_all_extension_candidates (auto_vec<const char *> *candidates);
 std::string aarch64_get_extension_string_for_isa_flags (uint64_t, uint64_t);
 
-/* Defined in aarch64-d.cc  */
-extern void aarch64_d_target_versions (void);
-extern void aarch64_d_register_target_info (void);
-
 rtl_opt_pass *make_pass_fma_steering (gcc::context *);
 rtl_opt_pass *make_pass_track_speculation (gcc::context *);
 rtl_opt_pass *make_pass_tag_collision_avoidance (gcc::context *);
@@ -1083,4 +1079,6 @@ const char *aarch64_indirect_call_asm (rtx);
 extern bool aarch64_harden_sls_retbr_p (void);
 extern bool aarch64_harden_sls_blr_p (void);
 
+extern void aarch64_output_patchable_area (unsigned int, bool);
+
 #endif /* GCC_AARCH64_PROTOS_H */
diff --git a/gcc/config/aarch64/aarch64-sve-builtins.cc b/gcc/config/aarch64/aarch64-sve-builtins.cc
index 9d78b270e47..12d9beee4da 100644
--- a/gcc/config/aarch64/aarch64-sve-builtins.cc
+++ b/gcc/config/aarch64/aarch64-sve-builtins.cc
@@ -530,7 +530,8 @@ static CONSTEXPR const function_group_info function_groups[] = {
 };
 
 /* The scalar type associated with each vector type.  */
-GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
+extern GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
+tree scalar_types[NUM_VECTOR_TYPES];
 
 /* The single-predicate and single-vector types, with their built-in
    "__SV..._t" name.  Allow an index of NUM_VECTOR_TYPES, which always
@@ -538,13 +539,16 @@ GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
 static GTY(()) tree abi_vector_types[NUM_VECTOR_TYPES + 1];
 
 /* Same, but with the arm_sve.h "sv..._t" name.  */
-GTY(()) tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
+extern GTY(()) tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
+tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
 
 /* The svpattern enum type.  */
-GTY(()) tree acle_svpattern;
+extern GTY(()) tree acle_svpattern;
+tree acle_svpattern;
 
 /* The svprfop enum type.  */
-GTY(()) tree acle_svprfop;
+extern GTY(()) tree acle_svprfop;
+tree acle_svprfop;
 
 /* The list of all registered function decls, indexed by code.  */
 static GTY(()) vec<registered_function *, va_gc> *registered_functions;
diff --git a/gcc/config/aarch64/aarch64-sve.md b/gcc/config/aarch64/aarch64-sve.md
index bd60e65b0c3..b8cc47ef5fc 100644
--- a/gcc/config/aarch64/aarch64-sve.md
+++ b/gcc/config/aarch64/aarch64-sve.md
@@ -8231,7 +8231,7 @@
 	        [(match_operand:<VPRED> 1)
 	         (const_int SVE_KNOWN_PTRUE)
 	         (match_operand:SVE_FULL_F 2 "register_operand" "w")
-	         (match_operand:SVE_FULL_F 3 "aarch64_simd_reg_or_zero" "wDz")]
+	         (match_operand:SVE_FULL_F 3 "register_operand" "w")]
 	        UNSPEC_COND_FCMUO))
 	    (match_operand:<VPRED> 4 "register_operand" "Upa"))
 	  (match_dup:<VPRED> 1)))
@@ -8267,7 +8267,7 @@
 	        [(match_operand:<VPRED> 1)
 	         (const_int SVE_KNOWN_PTRUE)
 	         (match_operand:SVE_FULL_F 2 "register_operand" "w")
-	         (match_operand:SVE_FULL_F 3 "aarch64_simd_reg_or_zero" "wDz")]
+	         (match_operand:SVE_FULL_F 3 "register_operand" "w")]
 	        UNSPEC_COND_FCMUO))
 	    (not:<VPRED>
 	      (match_operand:<VPRED> 4 "register_operand" "Upa")))
@@ -9612,45 +9612,41 @@
 (define_insn "*aarch64_brk<brk_op>_cc"
   [(set (reg:CC_NZC CC_REGNUM)
 	(unspec:CC_NZC
-	  [(match_operand:VNx16BI 1 "register_operand" "Upa, Upa")
+	  [(match_operand:VNx16BI 1 "register_operand" "Upa")
 	   (match_dup 1)
 	   (match_operand:SI 4 "aarch64_sve_ptrue_flag")
 	   (unspec:VNx16BI
 	     [(match_dup 1)
-	      (match_operand:VNx16BI 2 "register_operand" "Upa, Upa")
-	      (match_operand:VNx16BI 3 "aarch64_simd_reg_or_zero" "Dz, 0")]
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "aarch64_simd_imm_zero")]
 	     SVE_BRK_UNARY)]
 	  UNSPEC_PTEST))
-   (set (match_operand:VNx16BI 0 "register_operand" "=Upa, Upa")
+   (set (match_operand:VNx16BI 0 "register_operand" "=Upa")
 	(unspec:VNx16BI
 	  [(match_dup 1)
 	   (match_dup 2)
 	   (match_dup 3)]
 	  SVE_BRK_UNARY))]
   "TARGET_SVE"
-  "@
-   brk<brk_op>s\t%0.b, %1/z, %2.b
-   brk<brk_op>s\t%0.b, %1/m, %2.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b"
 )
 
 ;; Same, but with only the flags result being interesting.
 (define_insn "*aarch64_brk<brk_op>_ptest"
   [(set (reg:CC_NZC CC_REGNUM)
 	(unspec:CC_NZC
-	  [(match_operand:VNx16BI 1 "register_operand" "Upa, Upa")
+	  [(match_operand:VNx16BI 1 "register_operand" "Upa")
 	   (match_dup 1)
 	   (match_operand:SI 4 "aarch64_sve_ptrue_flag")
 	   (unspec:VNx16BI
 	     [(match_dup 1)
-	      (match_operand:VNx16BI 2 "register_operand" "Upa, Upa")
-	      (match_operand:VNx16BI 3 "aarch64_simd_reg_or_zero" "Dz, 0")]
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "aarch64_simd_imm_zero")]
 	     SVE_BRK_UNARY)]
 	  UNSPEC_PTEST))
-   (clobber (match_scratch:VNx16BI 0 "=Upa, Upa"))]
+   (clobber (match_scratch:VNx16BI 0 "=Upa"))]
   "TARGET_SVE"
-  "@
-   brk<brk_op>s\t%0.b, %1/z, %2.b
-   brk<brk_op>s\t%0.b, %1/m, %2.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b"
 )
 
 ;; -------------------------------------------------------------------------
@@ -9677,7 +9673,61 @@
   "brk<brk_op>\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b"
 )
 
-;; Same, but also producing a flags result.
+;; BRKN, producing both a predicate and a flags result.  Unlike other
+;; flag-setting instructions, these flags are always set wrt a ptrue.
+(define_insn_and_rewrite "*aarch64_brkn_cc"
+  [(set (reg:CC_NZC CC_REGNUM)
+	(unspec:CC_NZC
+	  [(match_operand:VNx16BI 4)
+	   (match_operand:VNx16BI 5)
+	   (const_int SVE_KNOWN_PTRUE)
+	   (unspec:VNx16BI
+	     [(match_operand:VNx16BI 1 "register_operand" "Upa")
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "register_operand" "0")]
+	     UNSPEC_BRKN)]
+	  UNSPEC_PTEST))
+   (set (match_operand:VNx16BI 0 "register_operand" "=Upa")
+	(unspec:VNx16BI
+	  [(match_dup 1)
+	   (match_dup 2)
+	   (match_dup 3)]
+	  UNSPEC_BRKN))]
+  "TARGET_SVE"
+  "brkns\t%0.b, %1/z, %2.b, %0.b"
+  "&& (operands[4] != CONST0_RTX (VNx16BImode)
+       || operands[5] != CONST0_RTX (VNx16BImode))"
+  {
+    operands[4] = CONST0_RTX (VNx16BImode);
+    operands[5] = CONST0_RTX (VNx16BImode);
+  }
+)
+
+;; Same, but with only the flags result being interesting.
+(define_insn_and_rewrite "*aarch64_brkn_ptest"
+  [(set (reg:CC_NZC CC_REGNUM)
+	(unspec:CC_NZC
+	  [(match_operand:VNx16BI 4)
+	   (match_operand:VNx16BI 5)
+	   (const_int SVE_KNOWN_PTRUE)
+	   (unspec:VNx16BI
+	     [(match_operand:VNx16BI 1 "register_operand" "Upa")
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "register_operand" "0")]
+	     UNSPEC_BRKN)]
+	  UNSPEC_PTEST))
+   (clobber (match_scratch:VNx16BI 0 "=Upa"))]
+  "TARGET_SVE"
+  "brkns\t%0.b, %1/z, %2.b, %0.b"
+  "&& (operands[4] != CONST0_RTX (VNx16BImode)
+       || operands[5] != CONST0_RTX (VNx16BImode))"
+  {
+    operands[4] = CONST0_RTX (VNx16BImode);
+    operands[5] = CONST0_RTX (VNx16BImode);
+  }
+)
+
+;; BRKPA and BRKPB, producing both a predicate and a flags result.
 (define_insn "*aarch64_brk<brk_op>_cc"
   [(set (reg:CC_NZC CC_REGNUM)
 	(unspec:CC_NZC
@@ -9687,17 +9737,17 @@
 	   (unspec:VNx16BI
 	     [(match_dup 1)
 	      (match_operand:VNx16BI 2 "register_operand" "Upa")
-	      (match_operand:VNx16BI 3 "register_operand" "<brk_reg_con>")]
-	     SVE_BRK_BINARY)]
+	      (match_operand:VNx16BI 3 "register_operand" "Upa")]
+	     SVE_BRKP)]
 	  UNSPEC_PTEST))
    (set (match_operand:VNx16BI 0 "register_operand" "=Upa")
 	(unspec:VNx16BI
 	  [(match_dup 1)
 	   (match_dup 2)
 	   (match_dup 3)]
-	  SVE_BRK_BINARY))]
+	  SVE_BRKP))]
   "TARGET_SVE"
-  "brk<brk_op>s\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b, %3.b"
 )
 
 ;; Same, but with only the flags result being interesting.
@@ -9710,12 +9760,12 @@
 	   (unspec:VNx16BI
 	     [(match_dup 1)
 	      (match_operand:VNx16BI 2 "register_operand" "Upa")
-	      (match_operand:VNx16BI 3 "register_operand" "<brk_reg_con>")]
-	     SVE_BRK_BINARY)]
+	      (match_operand:VNx16BI 3 "register_operand" "Upa")]
+	     SVE_BRKP)]
 	  UNSPEC_PTEST))
    (clobber (match_scratch:VNx16BI 0 "=Upa"))]
   "TARGET_SVE"
-  "brk<brk_op>s\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b, %3.b"
 )
 
 ;; -------------------------------------------------------------------------
diff --git a/gcc/config/aarch64/aarch64-tune.md b/gcc/config/aarch64/aarch64-tune.md
index 27da961475a..9dc9adc7056 100644
--- a/gcc/config/aarch64/aarch64-tune.md
+++ b/gcc/config/aarch64/aarch64-tune.md
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from aarch64-cores.def
 (define_attr "tune"
-	"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,ampere1,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa78,cortexa78ae,cortexa78c,cortexa65,cortexa65ae,cortexx1,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,neoverse512tvb,saphira,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55,cortexr82,cortexa510,cortexa710,cortexx2,neoversen2,demeter"
+	"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,ampere1,ampere1a,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa78,cortexa78ae,cortexa78c,cortexa65,cortexa65ae,cortexx1,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,neoverse512tvb,saphira,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55,cortexr82,cortexa510,cortexa710,cortexx2,neoversen2,demeter,neoversev2"
 	(const (symbol_ref "((enum attr_tune) aarch64_tune)")))
diff --git a/gcc/config/aarch64/aarch64.cc b/gcc/config/aarch64/aarch64.cc
index 5c9e7791a12..263bd138d27 100644
--- a/gcc/config/aarch64/aarch64.cc
+++ b/gcc/config/aarch64/aarch64.cc
@@ -537,7 +537,7 @@ static const struct cpu_addrcost_table neoversen2_addrcost_table =
   0 /* imm_offset  */
 };
 
-static const struct cpu_addrcost_table demeter_addrcost_table =
+static const struct cpu_addrcost_table neoversev2_addrcost_table =
 {
     {
       1, /* hi  */
@@ -680,7 +680,7 @@ static const struct cpu_regmove_cost neoversev1_regmove_cost =
   2 /* FP2FP  */
 };
 
-static const struct cpu_regmove_cost demeter_regmove_cost =
+static const struct cpu_regmove_cost neoversev2_regmove_cost =
 {
   1, /* GP2GP  */
   /* Spilling to int<->fp instead of memory is recommended so set
@@ -1924,6 +1924,43 @@ static const struct tune_params ampere1_tunings =
   &ampere1_prefetch_tune
 };
 
+static const struct tune_params ampere1a_tunings =
+{
+  &ampere1a_extra_costs,
+  &generic_addrcost_table,
+  &generic_regmove_cost,
+  &ampere1_vector_cost,
+  &generic_branch_cost,
+  &generic_approx_modes,
+  SVE_NOT_IMPLEMENTED, /* sve_width  */
+  { 4, /* load_int.  */
+    4, /* store_int.  */
+    4, /* load_fp.  */
+    4, /* store_fp.  */
+    4, /* load_pred.  */
+    4 /* store_pred.  */
+  }, /* memmov_cost.  */
+  4, /* issue_rate  */
+  (AARCH64_FUSE_ADRP_ADD | AARCH64_FUSE_AES_AESMC |
+   AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_MOVK_MOVK |
+   AARCH64_FUSE_ALU_BRANCH /* adds, ands, bics, ccmp, ccmn */ |
+   AARCH64_FUSE_CMP_BRANCH | AARCH64_FUSE_ALU_CBZ |
+   AARCH64_FUSE_ADDSUB_2REG_CONST1),
+  /* fusible_ops  */
+  "32",		/* function_align.  */
+  "4",		/* jump_align.  */
+  "32:16",	/* loop_align.  */
+  2,	/* int_reassoc_width.  */
+  4,	/* fp_reassoc_width.  */
+  2,	/* vec_reassoc_width.  */
+  2,	/* min_div_recip_mul_sf.  */
+  2,	/* min_div_recip_mul_df.  */
+  0,	/* max_case_values.  */
+  tune_params::AUTOPREFETCHER_WEAK,	/* autoprefetcher_model.  */
+  (AARCH64_EXTRA_TUNE_NONE),		/* tune_flags.  */
+  &ampere1_prefetch_tune
+};
+
 static const advsimd_vec_cost neoversev1_advsimd_vector_cost =
 {
   2, /* int_stmt_cost  */
@@ -2429,7 +2466,7 @@ static const struct tune_params neoversen2_tunings =
   &generic_prefetch_tune
 };
 
-static const advsimd_vec_cost demeter_advsimd_vector_cost =
+static const advsimd_vec_cost neoversev2_advsimd_vector_cost =
 {
   2, /* int_stmt_cost  */
   2, /* fp_stmt_cost  */
@@ -2460,7 +2497,7 @@ static const advsimd_vec_cost demeter_advsimd_vector_cost =
   1  /* store_cost  */
 };
 
-static const sve_vec_cost demeter_sve_vector_cost =
+static const sve_vec_cost neoversev2_sve_vector_cost =
 {
   {
     2, /* int_stmt_cost  */
@@ -2517,7 +2554,7 @@ static const sve_vec_cost demeter_sve_vector_cost =
   3 /* scatter_store_elt_cost  */
 };
 
-static const aarch64_scalar_vec_issue_info demeter_scalar_issue_info =
+static const aarch64_scalar_vec_issue_info neoversev2_scalar_issue_info =
 {
   3, /* loads_stores_per_cycle  */
   2, /* stores_per_cycle  */
@@ -2526,7 +2563,7 @@ static const aarch64_scalar_vec_issue_info demeter_scalar_issue_info =
   1 /* fp_simd_store_general_ops  */
 };
 
-static const aarch64_advsimd_vec_issue_info demeter_advsimd_issue_info =
+static const aarch64_advsimd_vec_issue_info neoversev2_advsimd_issue_info =
 {
   {
     3, /* loads_stores_per_cycle  */
@@ -2540,7 +2577,7 @@ static const aarch64_advsimd_vec_issue_info demeter_advsimd_issue_info =
   3 /* ld4_st4_general_ops  */
 };
 
-static const aarch64_sve_vec_issue_info demeter_sve_issue_info =
+static const aarch64_sve_vec_issue_info neoversev2_sve_issue_info =
 {
   {
     {
@@ -2562,15 +2599,15 @@ static const aarch64_sve_vec_issue_info demeter_sve_issue_info =
   1 /* gather_scatter_pair_pred_ops  */
 };
 
-static const aarch64_vec_issue_info demeter_vec_issue_info =
+static const aarch64_vec_issue_info neoversev2_vec_issue_info =
 {
-  &demeter_scalar_issue_info,
-  &demeter_advsimd_issue_info,
-  &demeter_sve_issue_info
+  &neoversev2_scalar_issue_info,
+  &neoversev2_advsimd_issue_info,
+  &neoversev2_sve_issue_info
 };
 
 /* Demeter costs for vector insn classes.  */
-static const struct cpu_vector_cost demeter_vector_cost =
+static const struct cpu_vector_cost neoversev2_vector_cost =
 {
   1, /* scalar_int_stmt_cost  */
   2, /* scalar_fp_stmt_cost  */
@@ -2578,17 +2615,17 @@ static const struct cpu_vector_cost demeter_vector_cost =
   1, /* scalar_store_cost  */
   1, /* cond_taken_branch_cost  */
   1, /* cond_not_taken_branch_cost  */
-  &demeter_advsimd_vector_cost, /* advsimd  */
-  &demeter_sve_vector_cost, /* sve  */
-  &demeter_vec_issue_info /* issue_info  */
+  &neoversev2_advsimd_vector_cost, /* advsimd  */
+  &neoversev2_sve_vector_cost, /* sve  */
+  &neoversev2_vec_issue_info /* issue_info  */
 };
 
-static const struct tune_params demeter_tunings =
+static const struct tune_params neoversev2_tunings =
 {
   &cortexa76_extra_costs,
-  &demeter_addrcost_table,
-  &demeter_regmove_cost,
-  &demeter_vector_cost,
+  &neoversev2_addrcost_table,
+  &neoversev2_regmove_cost,
+  &neoversev2_vector_cost,
   &generic_branch_cost,
   &generic_approx_modes,
   SVE_128, /* sve_width  */
@@ -15532,7 +15569,7 @@ aarch64_vec_op_count::rename_cycles_per_iter () const
 {
   if (sve_issue_info () == &neoverse512tvb_sve_issue_info
       || sve_issue_info () == &neoversen2_sve_issue_info
-      || sve_issue_info () == &demeter_sve_issue_info)
+      || sve_issue_info () == &neoversev2_sve_issue_info)
     /* + 1 for an addition.  We've already counted a general op for each
        store, so we don't need to account for stores separately.  The branch
        reads no registers and so does not need to be counted either.
@@ -16677,7 +16714,8 @@ aarch64_vector_costs::prefer_unrolled_loop () const
 
   if (dump_enabled_p ())
     dump_printf_loc (MSG_NOTE, vect_location, "Number of insns in"
-		     " unrolled Advanced SIMD loop = %d\n",
+		     " unrolled Advanced SIMD loop = "
+		     HOST_WIDE_INT_PRINT_UNSIGNED "\n",
 		     m_unrolled_advsimd_stmts);
 
   /* The balance here is tricky.  On the one hand, we can't be sure whether
@@ -22555,30 +22593,56 @@ aarch64_declare_function_name (FILE *stream, const char* name,
   cfun->machine->label_is_assembled = true;
 }
 
-/* Implement PRINT_PATCHABLE_FUNCTION_ENTRY.  Check if the patch area is after
-   the function label and emit a BTI if necessary.  */
+/* Implement PRINT_PATCHABLE_FUNCTION_ENTRY.  */
 
 void
 aarch64_print_patchable_function_entry (FILE *file,
 					unsigned HOST_WIDE_INT patch_area_size,
 					bool record_p)
 {
-  if (cfun->machine->label_is_assembled
-      && aarch64_bti_enabled ()
-      && !cgraph_node::get (cfun->decl)->only_called_directly_p ())
+  if (!cfun->machine->label_is_assembled)
+    {
+      /* Emit the patching area before the entry label, if any.  */
+      default_print_patchable_function_entry (file, patch_area_size,
+					      record_p);
+      return;
+    }
+
+  rtx pa = gen_patchable_area (GEN_INT (patch_area_size),
+			       GEN_INT (record_p));
+  basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;
+
+  if (!aarch64_bti_enabled ()
+      || cgraph_node::get (cfun->decl)->only_called_directly_p ())
+    {
+      /* Emit the patchable_area at the beginning of the function.  */
+      rtx_insn *insn = emit_insn_before (pa, BB_HEAD (bb));
+      INSN_ADDRESSES_NEW (insn, -1);
+      return;
+    }
+
+  rtx_insn *insn = next_real_nondebug_insn (get_insns ());
+  if (!insn
+      || !INSN_P (insn)
+      || GET_CODE (PATTERN (insn)) != UNSPEC_VOLATILE
+      || XINT (PATTERN (insn), 1) != UNSPECV_BTI_C)
     {
-      /* Remove the BTI that follows the patch area and insert a new BTI
-	 before the patch area right after the function label.  */
-      rtx_insn *insn = next_real_nondebug_insn (get_insns ());
-      if (insn
-	  && INSN_P (insn)
-	  && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE
-	  && XINT (PATTERN (insn), 1) == UNSPECV_BTI_C)
-	delete_insn (insn);
-      asm_fprintf (file, "\thint\t34 // bti c\n");
+      /* Emit a BTI_C.  */
+      insn = emit_insn_before (gen_bti_c (), BB_HEAD (bb));
     }
 
-  default_print_patchable_function_entry (file, patch_area_size, record_p);
+  /* Emit the patchable_area after BTI_C.  */
+  insn = emit_insn_after (pa, insn);
+  INSN_ADDRESSES_NEW (insn, -1);
+}
+
+/* Output patchable area.  */
+
+void
+aarch64_output_patchable_area (unsigned int patch_area_size, bool record_p)
+{
+  default_print_patchable_function_entry (asm_out_file, patch_area_size,
+					  record_p);
 }
 
 /* Implement ASM_OUTPUT_DEF_FROM_DECLS.  Output .variant_pcs for aliases.  */
@@ -25455,6 +25519,33 @@ aarch_macro_fusion_pair_p (rtx_insn *prev, rtx_insn *curr)
 	}
     }
 
+  /* Fuse A+B+1 and A-B-1 */
+  if (simple_sets_p
+      && aarch64_fusion_enabled_p (AARCH64_FUSE_ADDSUB_2REG_CONST1))
+    {
+      /* We're trying to match:
+	  prev == (set (r0) (plus (r0) (r1)))
+	  curr == (set (r0) (plus (r0) (const_int 1)))
+	or:
+	  prev == (set (r0) (minus (r0) (r1)))
+	  curr == (set (r0) (plus (r0) (const_int -1))) */
+
+      rtx prev_src = SET_SRC (prev_set);
+      rtx curr_src = SET_SRC (curr_set);
+
+      int polarity = 1;
+      if (GET_CODE (prev_src) == MINUS)
+	polarity = -1;
+
+      if (GET_CODE (curr_src) == PLUS
+	  && (GET_CODE (prev_src) == PLUS || GET_CODE (prev_src) == MINUS)
+	  && CONST_INT_P (XEXP (curr_src, 1))
+	  && INTVAL (XEXP (curr_src, 1)) == polarity
+	  && REG_P (XEXP (curr_src, 0))
+	  && REGNO (SET_DEST (prev_set)) == REGNO (XEXP (curr_src, 0)))
+	return true;
+    }
+
   return false;
 }
 
diff --git a/gcc/config/aarch64/aarch64.h b/gcc/config/aarch64/aarch64.h
index 359b6e8561f..3bde24674dc 100644
--- a/gcc/config/aarch64/aarch64.h
+++ b/gcc/config/aarch64/aarch64.h
@@ -26,10 +26,6 @@
 #define TARGET_CPU_CPP_BUILTINS()	\
   aarch64_cpu_cpp_builtins (pfile)
 
-/* Target hooks for D language.  */
-#define TARGET_D_CPU_VERSIONS aarch64_d_target_versions
-#define TARGET_D_REGISTER_CPU_TARGET_INFO aarch64_d_register_target_info
-
 
 
 #define REGISTER_TARGET_PRAGMAS() aarch64_register_pragmas ()
@@ -260,7 +256,8 @@ extern unsigned aarch64_architecture_version;
 #define AARCH64_FL_FOR_ARCH8_2			\
   (AARCH64_FL_FOR_ARCH8_1 | AARCH64_FL_V8_2)
 #define AARCH64_FL_FOR_ARCH8_3			\
-  (AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_V8_3 | AARCH64_FL_PAUTH)
+  (AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_V8_3 | AARCH64_FL_PAUTH \
+   | AARCH64_FL_RCPC)
 #define AARCH64_FL_FOR_ARCH8_4			\
   (AARCH64_FL_FOR_ARCH8_3 | AARCH64_FL_V8_4 | AARCH64_FL_F16FML \
    | AARCH64_FL_DOTPROD | AARCH64_FL_RCPC8_4 | AARCH64_FL_FLAGM)
@@ -305,6 +302,7 @@ extern unsigned aarch64_architecture_version;
 #define AARCH64_ISA_SM4	           (aarch64_isa_flags & AARCH64_FL_SM4)
 #define AARCH64_ISA_SHA3	   (aarch64_isa_flags & AARCH64_FL_SHA3)
 #define AARCH64_ISA_F16FML	   (aarch64_isa_flags & AARCH64_FL_F16FML)
+#define AARCH64_ISA_RCPC	   (aarch64_isa_flags & AARCH64_FL_RCPC)
 #define AARCH64_ISA_RCPC8_4	   (aarch64_isa_flags & AARCH64_FL_RCPC8_4)
 #define AARCH64_ISA_RNG		   (aarch64_isa_flags & AARCH64_FL_RNG)
 #define AARCH64_ISA_V8_5	   (aarch64_isa_flags & AARCH64_FL_V8_5)
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index 34b8059b45b..d24c8afcfa6 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -303,6 +303,7 @@
     UNSPEC_TAG_SPACE		; Translate address to MTE tag address space.
     UNSPEC_LD1RO
     UNSPEC_SALT_ADDR
+    UNSPECV_PATCHABLE_AREA
 ])
 
 (define_c_enum "unspecv" [
@@ -1586,6 +1587,7 @@
      [(set (match_operand 2) (const_int 0))
       (clobber (match_dup 3))
       (clobber (match_dup 4))
+      (clobber (reg:CC CC_REGNUM))
       (set (match_operand 0)
 	   (unspec:BLK [(match_operand 1) (match_dup 2)] UNSPEC_CPYMEM))])]
   "TARGET_MOPS"
@@ -1599,6 +1601,7 @@
   [(set (match_operand:DI 2 "register_operand" "+&r") (const_int 0))
    (clobber (match_operand:DI 0 "register_operand" "+&r"))
    (clobber (match_operand:DI 1 "register_operand" "+&r"))
+   (clobber (reg:CC CC_REGNUM))
    (set (mem:BLK (match_dup 0))
         (unspec:BLK [(mem:BLK (match_dup 1)) (match_dup 2)] UNSPEC_CPYMEM))]
   "TARGET_MOPS"
@@ -1629,6 +1632,7 @@
    (set (match_operand:DI 2 "register_operand" "+&r") (const_int 0))
    (clobber (match_operand:DI 0 "register_operand" "+&r"))
    (clobber (match_operand:DI 1 "register_operand" "+&r"))
+   (clobber (reg:CC CC_REGNUM))
    (set (mem:BLK (match_dup 0))
         (unspec:BLK [(mem:BLK (match_dup 1)) (match_dup 2)] UNSPEC_MOVMEM))])]
  "TARGET_MOPS"
@@ -1674,6 +1678,7 @@
   [(parallel
      [(set (match_operand 2) (const_int 0))
       (clobber (match_dup 3))
+      (clobber (reg:CC CC_REGNUM))
       (set (match_operand 0)
 	   (unspec:BLK [(match_operand 1)
 			(match_dup 2)] UNSPEC_SETMEM))])]
@@ -1686,6 +1691,7 @@
 (define_insn "*aarch64_setmemdi"
   [(set (match_operand:DI 2 "register_operand" "+&r") (const_int 0))
    (clobber (match_operand:DI 0 "register_operand" "+&r"))
+   (clobber (reg:CC CC_REGNUM))
    (set (mem:BLK (match_dup 0))
         (unspec:BLK [(match_operand:QI 1 "aarch64_reg_or_zero" "rZ")
 		     (match_dup 2)] UNSPEC_SETMEM))]
@@ -7705,6 +7711,19 @@
   [(set_attr "type" "ls64")]
 )
 
+(define_insn "patchable_area"
+  [(unspec_volatile [(match_operand 0 "const_int_operand")
+		     (match_operand 1 "const_int_operand")]
+		    UNSPECV_PATCHABLE_AREA)]
+  ""
+{
+  aarch64_output_patchable_area (INTVAL (operands[0]),
+			         INTVAL (operands[1]) != 0);
+  return "";
+}
+  [(set (attr "length") (symbol_ref "INTVAL (operands[0])"))]
+)
+
 ;; AdvSIMD Stuff
 (include "aarch64-simd.md")
 
diff --git a/gcc/config/aarch64/driver-aarch64.cc b/gcc/config/aarch64/driver-aarch64.cc
index 8073a0786d9..d714a8bda43 100644
--- a/gcc/config/aarch64/driver-aarch64.cc
+++ b/gcc/config/aarch64/driver-aarch64.cc
@@ -202,9 +202,9 @@ readline (FILE *f)
 	return std::string ();
       /* If we're not at the end of the line then override the
 	 \0 added by fgets.  */
-      last = strnlen (buf, size) - 1;
+      last = strnlen (buf, size);
     }
-  while (!feof (f) && buf[last] != '\n');
+  while (!feof (f) && last > 0 && buf[last - 1] != '\n');
 
   std::string result (buf);
   free (buf);
diff --git a/gcc/config/aarch64/iterators.md b/gcc/config/aarch64/iterators.md
index e72fdf35a82..26a840d7fe9 100644
--- a/gcc/config/aarch64/iterators.md
+++ b/gcc/config/aarch64/iterators.md
@@ -3112,6 +3112,8 @@
 
 (define_int_iterator SVE_BRK_UNARY [UNSPEC_BRKA UNSPEC_BRKB])
 
+(define_int_iterator SVE_BRKP [UNSPEC_BRKPA UNSPEC_BRKPB])
+
 (define_int_iterator SVE_BRK_BINARY [UNSPEC_BRKN UNSPEC_BRKPA UNSPEC_BRKPB])
 
 (define_int_iterator SVE_PITER [UNSPEC_PFIRST UNSPEC_PNEXT])
diff --git a/gcc/config/arm/arm-d.cc b/gcc/config/arm/arm-d.cc
index d65b7524934..5c89f1b1079 100644
--- a/gcc/config/arm/arm-d.cc
+++ b/gcc/config/arm/arm-d.cc
@@ -21,9 +21,10 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
-#include "tm_p.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
+#include "arm-protos.h"
 
 /* Implement TARGET_D_CPU_VERSIONS for ARM targets.  */
 
diff --git a/gcc/config/arm/arm-d.h b/gcc/config/arm/arm-d.h
new file mode 100644
index 00000000000..479a89bb120
--- /dev/null
+++ b/gcc/config/arm/arm-d.h
@@ -0,0 +1,24 @@
+/* Definitions for the D front end on the ARM architecture.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Defined in arm-d.cc  */
+extern void arm_d_target_versions (void);
+extern void arm_d_register_target_info (void);
+
+/* Target hooks for D language.  */
+#define TARGET_D_CPU_VERSIONS arm_d_target_versions
+#define TARGET_D_REGISTER_CPU_TARGET_INFO arm_d_register_target_info
diff --git a/gcc/config/arm/arm-protos.h b/gcc/config/arm/arm-protos.h
index 9d142096cb6..f8a63e98ef4 100644
--- a/gcc/config/arm/arm-protos.h
+++ b/gcc/config/arm/arm-protos.h
@@ -123,6 +123,7 @@ extern int arm_coproc_mem_operand_wb (rtx, int);
 extern int neon_vector_mem_operand (rtx, int, bool);
 extern int mve_vector_mem_operand (machine_mode, rtx, bool);
 extern int neon_struct_mem_operand (rtx);
+extern int mve_struct_mem_operand (rtx);
 
 extern rtx *neon_vcmla_lane_prepare_operands (rtx *);
 
@@ -403,10 +404,6 @@ extern void arm_lang_object_attributes_init (void);
 extern void arm_register_target_pragmas (void);
 extern void arm_cpu_cpp_builtins (struct cpp_reader *);
 
-/* Defined in arm-d.cc  */
-extern void arm_d_target_versions (void);
-extern void arm_d_register_target_info (void);
-
 extern bool arm_is_constant_pool_ref (rtx);
 
 /* The bits in this mask specify which instruction scheduling options should
diff --git a/gcc/config/arm/arm.cc b/gcc/config/arm/arm.cc
index d88086fbd13..b700c23b866 100644
--- a/gcc/config/arm/arm.cc
+++ b/gcc/config/arm/arm.cc
@@ -13657,6 +13657,24 @@ neon_vector_mem_operand (rtx op, int type, bool strict)
   return FALSE;
 }
 
+/* Return TRUE if OP is a mem suitable for loading/storing an MVE struct
+   type.  */
+int
+mve_struct_mem_operand (rtx op)
+{
+  rtx ind = XEXP (op, 0);
+
+  /* Match: (mem (reg)).  */
+  if (REG_P (ind))
+    return arm_address_register_rtx_p (ind, 0);
+
+  /* Allow only post-increment by the mode size.  */
+  if (GET_CODE (ind) == POST_INC)
+    return arm_address_register_rtx_p (XEXP (ind, 0), 0);
+
+  return FALSE;
+}
+
 /* Return TRUE if OP is a mem suitable for loading/storing a Neon struct
    type.  */
 int
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index f479540812a..e15722b0be3 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -47,10 +47,6 @@ extern char arm_arch_name[];
 /* Target CPU builtins.  */
 #define TARGET_CPU_CPP_BUILTINS() arm_cpu_cpp_builtins (pfile)
 
-/* Target hooks for D language.  */
-#define TARGET_D_CPU_VERSIONS arm_d_target_versions
-#define TARGET_D_REGISTER_CPU_TARGET_INFO arm_d_register_target_info
-
 #include "config/arm/arm-opts.h"
 
 /* The processor for which instructions should be scheduled.  */
diff --git a/gcc/config/arm/constraints.md b/gcc/config/arm/constraints.md
index 2b411b0cb0f..db316d81dcc 100644
--- a/gcc/config/arm/constraints.md
+++ b/gcc/config/arm/constraints.md
@@ -466,6 +466,11 @@
  (and (match_code "mem")
       (match_test "TARGET_32BIT && arm_coproc_mem_operand (op, FALSE)")))
 
+(define_memory_constraint "Ug"
+ "@internal
+  In Thumb-2 state a valid MVE struct load/store address."
+ (match_operand 0 "mve_struct_operand"))
+
 (define_memory_constraint "Uj"
  "@internal
   In ARM/Thumb-2 state a VFP load/store address that supports writeback
diff --git a/gcc/config/arm/mve.md b/gcc/config/arm/mve.md
index 369d7a79f6c..01448717b7a 100644
--- a/gcc/config/arm/mve.md
+++ b/gcc/config/arm/mve.md
@@ -92,7 +92,7 @@
 ;; [vst4q])
 ;;
 (define_insn "mve_vst4q<mode>"
-  [(set (match_operand:XI 0 "neon_struct_operand" "=Um")
+  [(set (match_operand:XI 0 "mve_struct_operand" "=Ug")
 	(unspec:XI [(match_operand:XI 1 "s_register_operand" "w")
 		    (unspec:MVE_VLD_ST [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 	 VST4Q))
@@ -1617,7 +1617,7 @@
   [
    (set (match_operand:MVE_2 0 "s_register_operand" "=w")
 	(unspec:MVE_2 [(match_operand:MVE_2 1 "s_register_operand" "w")
-		       (match_operand:SI 2 "mve_imm_7" "Ra")]
+		       (match_operand:SI 2 "<MVE_pred>" "<MVE_constraint>")]
 	 VQSHLUQ_N_S))
   ]
   "TARGET_HAVE_MVE"
@@ -2608,7 +2608,7 @@
    (set (match_operand:<V_narrow_pack> 0 "s_register_operand" "=w")
 	(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 "s_register_operand" "0")
 				 (match_operand:MVE_5 2 "s_register_operand" "w")
-				 (match_operand:SI 3 "mve_imm_8" "Rb")]
+				 (match_operand:SI 3 "<MVE_pred3>" "<MVE_constraint3>")]
 	 VQRSHRNBQ_N))
   ]
   "TARGET_HAVE_MVE"
@@ -2623,7 +2623,7 @@
    (set (match_operand:<V_narrow_pack> 0 "s_register_operand" "=w")
 	(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 "s_register_operand" "0")
 				 (match_operand:MVE_5 2 "s_register_operand" "w")
-				 (match_operand:SI 3 "mve_imm_8" "Rb")]
+				 (match_operand:SI 3 "<MVE_pred3>" "<MVE_constraint3>")]
 	 VQRSHRUNBQ_N_S))
   ]
   "TARGET_HAVE_MVE"
@@ -3563,7 +3563,7 @@
    (set (match_operand:MVE_2 0 "s_register_operand" "=w")
 	(unspec:MVE_2 [(match_operand:MVE_2 1 "s_register_operand" "0")
 		       (match_operand:MVE_2 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_selective_upto_8" "Rg")]
+		       (match_operand:SI 3 "<MVE_pred2>" "<MVE_constraint2>")]
 	 VSRIQ_N))
   ]
   "TARGET_HAVE_MVE"
@@ -4466,7 +4466,7 @@
    (set (match_operand:<V_narrow_pack> 0 "s_register_operand" "=w")
 	(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 "s_register_operand" "0")
 		       (match_operand:MVE_5 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_8" "Rb")]
+		       (match_operand:SI 3 "<MVE_pred3>" "<MVE_constraint3>")]
 	 VQRSHRNTQ_N))
   ]
   "TARGET_HAVE_MVE"
@@ -4482,7 +4482,7 @@
    (set (match_operand:<V_narrow_pack> 0 "s_register_operand" "=w")
 	(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 "s_register_operand" "0")
 		       (match_operand:MVE_5 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_8" "Rb")]
+		       (match_operand:SI 3 "<MVE_pred3>" "<MVE_constraint3>")]
 	 VQRSHRUNTQ_N_S))
   ]
   "TARGET_HAVE_MVE"
@@ -4770,7 +4770,7 @@
    (set (match_operand:<V_narrow_pack> 0 "s_register_operand" "=w")
 	(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 "s_register_operand" "0")
 		       (match_operand:MVE_5 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_8" "Rb")]
+		       (match_operand:SI 3 "<MVE_pred3>" "<MVE_constraint3>")]
 	 VRSHRNBQ_N))
   ]
   "TARGET_HAVE_MVE"
@@ -4786,7 +4786,7 @@
    (set (match_operand:<V_narrow_pack> 0 "s_register_operand" "=w")
 	(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 "s_register_operand" "0")
 		       (match_operand:MVE_5 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_8" "Rb")]
+		       (match_operand:SI 3 "<MVE_pred3>" "<MVE_constraint3>")]
 	 VRSHRNTQ_N))
   ]
   "TARGET_HAVE_MVE"
@@ -4980,7 +4980,7 @@
    (set (match_operand:MVE_2 0 "s_register_operand" "=w")
 	(unspec:MVE_2 [(match_operand:MVE_2 1 "s_register_operand" "0")
 		       (match_operand:MVE_2 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_7" "Ra")
+		       (match_operand:SI 3 "<MVE_pred>" "<MVE_constraint>")
 		       (match_operand:<MVE_VPRED> 4 "vpr_register_operand" "Up")]
 	 VQSHLUQ_M_N_S))
   ]
@@ -5012,7 +5012,7 @@
    (set (match_operand:MVE_2 0 "s_register_operand" "=w")
 	(unspec:MVE_2 [(match_operand:MVE_2 1 "s_register_operand" "0")
 		       (match_operand:MVE_2 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_selective_upto_8" "Rg")
+		       (match_operand:SI 3 "<MVE_pred2>" "<MVE_constraint2>")
 		       (match_operand:<MVE_VPRED> 4 "vpr_register_operand" "Up")]
 	 VSRIQ_M_N))
   ]
@@ -6131,7 +6131,7 @@
    (set (match_operand:<V_narrow_pack> 0 "s_register_operand" "=w")
 	(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 "s_register_operand" "0")
 		       (match_operand:MVE_5 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_8" "Rb")
+		       (match_operand:SI 3 "<MVE_pred3>" "<MVE_constraint3>")
 		       (match_operand:<MVE_VPRED> 4 "vpr_register_operand" "Up")]
 	 VQRSHRNBQ_M_N))
   ]
@@ -6148,7 +6148,7 @@
    (set (match_operand:<V_narrow_pack> 0 "s_register_operand" "=w")
 	(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 "s_register_operand" "0")
 		       (match_operand:MVE_5 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_8" "Rb")
+		       (match_operand:SI 3 "<MVE_pred3>" "<MVE_constraint3>")
 		       (match_operand:<MVE_VPRED> 4 "vpr_register_operand" "Up")]
 	 VQRSHRNTQ_M_N))
   ]
@@ -6216,7 +6216,7 @@
    (set (match_operand:<V_narrow_pack> 0 "s_register_operand" "=w")
 	(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 "s_register_operand" "0")
 		       (match_operand:MVE_5 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_8" "Rb")
+		       (match_operand:SI 3 "<MVE_pred3>" "<MVE_constraint3>")
 		       (match_operand:<MVE_VPRED> 4 "vpr_register_operand" "Up")]
 	 VRSHRNBQ_M_N))
   ]
@@ -6233,7 +6233,7 @@
    (set (match_operand:<V_narrow_pack> 0 "s_register_operand" "=w")
 	(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 "s_register_operand" "0")
 		       (match_operand:MVE_5 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_8" "Rb")
+		       (match_operand:SI 3 "<MVE_pred3>" "<MVE_constraint3>")
 		       (match_operand:<MVE_VPRED> 4 "vpr_register_operand" "Up")]
 	 VRSHRNTQ_M_N))
   ]
@@ -6454,7 +6454,7 @@
    (set (match_operand:<V_narrow_pack> 0 "s_register_operand" "=w")
 	(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 "s_register_operand" "0")
 		       (match_operand:MVE_5 2 "s_register_operand" "w")
-		       (match_operand:SI 3 "mve_imm_8" "Rb")
+		       (match_operand:SI 3 "<MVE_pred3>" "<MVE_constraint3>")
 		       (match_operand:<MVE_VPRED> 4 "vpr_register_operand" "Up")]
 	 VQRSHRUNBQ_M_N_S))
   ]
@@ -9952,7 +9952,7 @@
 ;; [vst2q])
 ;;
 (define_insn "mve_vst2q<mode>"
-  [(set (match_operand:OI 0 "neon_struct_operand" "=Um")
+  [(set (match_operand:OI 0 "mve_struct_operand" "=Ug")
 	(unspec:OI [(match_operand:OI 1 "s_register_operand" "w")
 		    (unspec:MVE_VLD_ST [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 	 VST2Q))
@@ -9981,7 +9981,7 @@
 ;;
 (define_insn "mve_vld2q<mode>"
   [(set (match_operand:OI 0 "s_register_operand" "=w")
-	(unspec:OI [(match_operand:OI 1 "neon_struct_operand" "Um")
+	(unspec:OI [(match_operand:OI 1 "mve_struct_operand" "Ug")
 		    (unspec:MVE_VLD_ST [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 	 VLD2Q))
   ]
@@ -10009,7 +10009,7 @@
 ;;
 (define_insn "mve_vld4q<mode>"
   [(set (match_operand:XI 0 "s_register_operand" "=w")
-	(unspec:XI [(match_operand:XI 1 "neon_struct_operand" "Um")
+	(unspec:XI [(match_operand:XI 1 "mve_struct_operand" "Ug")
 		    (unspec:MVE_VLD_ST [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 	 VLD4Q))
   ]
@@ -10462,7 +10462,7 @@
 )
 
 (define_insn "*movmisalign<mode>_mve_store"
-  [(set (match_operand:MVE_VLD_ST 0 "neon_permissive_struct_operand"	     "=Ux")
+  [(set (match_operand:MVE_VLD_ST 0 "mve_memory_operand"	     "=Ux")
 	(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 "s_register_operand" " w")]
 	 UNSPEC_MISALIGNED_ACCESS))]
   "((TARGET_HAVE_MVE && VALID_MVE_SI_MODE (<MODE>mode))
@@ -10475,7 +10475,7 @@
 
 (define_insn "*movmisalign<mode>_mve_load"
   [(set (match_operand:MVE_VLD_ST 0 "s_register_operand"				 "=w")
-	(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 "neon_permissive_struct_operand" " Ux")]
+	(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 "mve_memory_operand" " Ux")]
 	 UNSPEC_MISALIGNED_ACCESS))]
   "((TARGET_HAVE_MVE && VALID_MVE_SI_MODE (<MODE>mode))
     || (TARGET_HAVE_MVE_FLOAT && VALID_MVE_SF_MODE (<MODE>mode)))
diff --git a/gcc/config/arm/predicates.md b/gcc/config/arm/predicates.md
index aab5a91ad4d..67f2fdb4f8f 100644
--- a/gcc/config/arm/predicates.md
+++ b/gcc/config/arm/predicates.md
@@ -876,6 +876,10 @@
   (and (match_code "mem")
        (match_test "TARGET_32BIT && neon_vector_mem_operand (op, 2, true)")))
 
+(define_predicate "mve_struct_operand"
+  (and (match_code "mem")
+       (match_test "TARGET_HAVE_MVE && mve_struct_mem_operand (op)")))
+
 (define_predicate "neon_permissive_struct_operand"
   (and (match_code "mem")
        (match_test "TARGET_32BIT && neon_vector_mem_operand (op, 2, false)")))
diff --git a/gcc/config/arm/vec-common.md b/gcc/config/arm/vec-common.md
index fd878cba22d..1fd68f3ac43 100644
--- a/gcc/config/arm/vec-common.md
+++ b/gcc/config/arm/vec-common.md
@@ -280,29 +280,81 @@
   DONE;
 })
 
-(define_expand "movmisalign<mode>"
- [(set (match_operand:VDQ 0 "neon_perm_struct_or_reg_operand")
-	(unspec:VDQ [(match_operand:VDQ 1 "neon_perm_struct_or_reg_operand")]
+(define_expand "@movmisalign<mode>"
+ [(set (match_operand:VDQ 0 "nonimmediate_operand")
+	(unspec:VDQ [(match_operand:VDQ 1 "general_operand")]
 	 UNSPEC_MISALIGNED_ACCESS))]
  "ARM_HAVE_<MODE>_LDST && !BYTES_BIG_ENDIAN
   && unaligned_access && !TARGET_REALLY_IWMMXT"
 {
- rtx adjust_mem;
- /* This pattern is not permitted to fail during expansion: if both arguments
-    are non-registers (e.g. memory := constant, which can be created by the
-    auto-vectorizer), force operand 1 into a register.  */
- if (!s_register_operand (operands[0], <MODE>mode)
-     && !s_register_operand (operands[1], <MODE>mode))
-   operands[1] = force_reg (<MODE>mode, operands[1]);
-
- if (s_register_operand (operands[0], <MODE>mode))
-   adjust_mem = operands[1];
- else
-   adjust_mem = operands[0];
-
- /* Legitimize address.  */
- if (!neon_vector_mem_operand (adjust_mem, 2, true))
-   XEXP (adjust_mem, 0) = force_reg (Pmode, XEXP (adjust_mem, 0));
+  rtx *memloc;
+  bool for_store = false;
+  /* This pattern is not permitted to fail during expansion: if both arguments
+     are non-registers (e.g. memory := constant, which can be created by the
+     auto-vectorizer), force operand 1 into a register.  */
+  if (!s_register_operand (operands[0], <MODE>mode)
+      && !s_register_operand (operands[1], <MODE>mode))
+    operands[1] = force_reg (<MODE>mode, operands[1]);
+
+  if (s_register_operand (operands[0], <MODE>mode))
+    memloc = &operands[1];
+  else
+    {
+      memloc = &operands[0];
+      for_store = true;
+    }
+
+  /* For MVE, vector loads/stores must be aligned to the element size.  If the
+     alignment is less than that convert the load/store to a suitable mode.  */
+  if (TARGET_HAVE_MVE
+      && (MEM_ALIGN (*memloc)
+	  < GET_MODE_ALIGNMENT (GET_MODE_INNER (<MODE>mode))))
+    {
+      scalar_mode new_smode;
+      switch (MEM_ALIGN (*memloc))
+	{
+	case 64:
+	case 32:
+	  new_smode = SImode;
+	  break;
+	case 16:
+	  new_smode = HImode;
+	  break;
+	default:
+	  new_smode = QImode;
+	  break;
+	}
+      machine_mode new_mode
+	= mode_for_vector (new_smode,
+			   GET_MODE_SIZE (<MODE>mode)
+			   / GET_MODE_SIZE (new_smode)).require ();
+      rtx new_mem = adjust_address (*memloc, new_mode, 0);
+
+      if (!for_store)
+	{
+	  rtx reg = gen_reg_rtx (new_mode);
+	  emit_insn (gen_movmisalign (new_mode, reg, new_mem));
+	  emit_move_insn (operands[0], gen_lowpart (<MODE>mode, reg));
+	  DONE;
+	}
+      emit_insn (gen_movmisalign (new_mode, new_mem,
+				  gen_lowpart (new_mode, operands[1])));
+      DONE;
+    }
+
+  /* Legitimize address.  */
+  if ((TARGET_HAVE_MVE
+       && !mve_vector_mem_operand (<MODE>mode, XEXP (*memloc, 0), false))
+      || (!TARGET_HAVE_MVE
+	  && !neon_vector_mem_operand (*memloc, 2, false)))
+    {
+      rtx new_mem
+	= replace_equiv_address (*memloc,
+				 force_reg (Pmode, XEXP (*memloc, 0)),
+				 false);
+      gcc_assert (MEM_ALIGN (new_mem) == MEM_ALIGN (*memloc));
+      *memloc = new_mem;
+    }
 })
 
 (define_insn "mve_vshlq_<supf><mode>"
diff --git a/gcc/config/darwin-d.cc b/gcc/config/darwin-d.cc
index e983883dba6..2ceebc49851 100644
--- a/gcc/config/darwin-d.cc
+++ b/gcc/config/darwin-d.cc
@@ -18,6 +18,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
+#include "tm.h"
 #include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
diff --git a/gcc/config/default-d.cc b/gcc/config/default-d.cc
index 2d7abfcba96..30c359ed226 100644
--- a/gcc/config/default-d.cc
+++ b/gcc/config/default-d.cc
@@ -18,9 +18,11 @@ along with GCC; see the file COPYING3.  If not see
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
-#include "memmodel.h"
 #include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
+/* Do not include tm.h or tm_p.h here; definitions needed by the target
+   architecture to initialize targetdm should instead be added to tm_d.h.  */
+
 struct gcc_targetdm targetdm = TARGETDM_INITIALIZER;
diff --git a/gcc/config/dragonfly-d.cc b/gcc/config/dragonfly-d.cc
index d431638f7da..881c5e60b9a 100644
--- a/gcc/config/dragonfly-d.cc
+++ b/gcc/config/dragonfly-d.cc
@@ -18,6 +18,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
+#include "tm.h"
 #include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
diff --git a/gcc/config/freebsd-d.cc b/gcc/config/freebsd-d.cc
index 9f0f5e7b6ee..c795ca2978c 100644
--- a/gcc/config/freebsd-d.cc
+++ b/gcc/config/freebsd-d.cc
@@ -18,9 +18,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
-#include "memmodel.h"
 #include "tm.h"
-#include "tm_p.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/gcn/gcn.cc b/gcc/config/gcn/gcn.cc
index e2e9335ad75..e2cbdd1ac39 100644
--- a/gcc/config/gcn/gcn.cc
+++ b/gcc/config/gcn/gcn.cc
@@ -2458,10 +2458,14 @@ gcn_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)
   return (NUM_PARM_REGS - cum->num) * UNITS_PER_WORD;
 }
 
-/* A normal function which takes a pointer argument (to a scalar) may be
-   passed a pointer to LDS space (via a high-bits-set aperture), and that only
-   works with FLAT addressing, not GLOBAL.  Force FLAT addressing if the
-   function has an incoming pointer-to-scalar parameter.  */
+/* A normal function which takes a pointer argument may be passed a pointer to
+   LDS space (via a high-bits-set aperture), and that only works with FLAT
+   addressing, not GLOBAL.  Force FLAT addressing if the function has an
+   incoming pointer parameter.  NOTE: This is a heuristic that works in the
+   offloading case, but in general, a function might read global pointer
+   variables, etc. that may refer to LDS space or other special memory areas
+   not supported by GLOBAL instructions, and then this argument check would not
+   suffice.  */
 
 static void
 gcn_detect_incoming_pointer_arg (tree fndecl)
@@ -2471,8 +2475,7 @@ gcn_detect_incoming_pointer_arg (tree fndecl)
   for (tree arg = TYPE_ARG_TYPES (TREE_TYPE (fndecl));
        arg;
        arg = TREE_CHAIN (arg))
-    if (POINTER_TYPE_P (TREE_VALUE (arg))
-	&& !AGGREGATE_TYPE_P (TREE_TYPE (TREE_VALUE (arg))))
+    if (POINTER_TYPE_P (TREE_VALUE (arg)))
       cfun->machine->use_flat_addressing = true;
 }
 
diff --git a/gcc/config/gcn/mkoffload.cc b/gcc/config/gcn/mkoffload.cc
index 94ba7ffa5af..a8b1b6e05c2 100644
--- a/gcc/config/gcn/mkoffload.cc
+++ b/gcc/config/gcn/mkoffload.cc
@@ -1082,6 +1082,7 @@ main (int argc, char **argv)
 		    }
 		  else
 		    dbgobj = make_temp_file (".mkoffload.dbg.o");
+		  obstack_ptr_grow (&files_to_cleanup, dbgobj);
 
 		  /* If the copy fails then just ignore it.  */
 		  if (copy_early_debug_info (argv[ix], dbgobj))
diff --git a/gcc/config/glibc-d.cc b/gcc/config/glibc-d.cc
index f30af104db8..1411f1973e5 100644
--- a/gcc/config/glibc-d.cc
+++ b/gcc/config/glibc-d.cc
@@ -19,8 +19,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
-#include "memmodel.h"
-#include "tm_p.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/i386/amxtileintrin.h b/gcc/config/i386/amxtileintrin.h
index 7b5a39eba72..06f18aa9bfb 100644
--- a/gcc/config/i386/amxtileintrin.h
+++ b/gcc/config/i386/amxtileintrin.h
@@ -62,7 +62,7 @@ _tile_release (void)
 #define _tile_loadd_internal(dst,base,stride)				\
   __asm__ volatile							\
   ("{tileloadd\t(%0,%1,1), %%tmm"#dst"|tileloadd\t%%tmm"#dst", [%0+%1*1]}" \
-   :: "r" ((const void*) (base)), "r" ((long) (stride)))
+   :: "r" ((const void*) (base)), "r" ((__PTRDIFF_TYPE__) (stride)))
 
 #define _tile_stream_loadd(dst,base,stride)		\
   _tile_stream_loadd_internal (dst, base, stride)
@@ -70,7 +70,7 @@ _tile_release (void)
 #define _tile_stream_loadd_internal(dst,base,stride)			\
   __asm__ volatile							\
   ("{tileloaddt1\t(%0,%1,1), %%tmm"#dst"|tileloaddt1\t%%tmm"#dst", [%0+%1*1]}" \
-   :: "r" ((const void*) (base)), "r" ((long) (stride)))
+   :: "r" ((const void*) (base)), "r" ((__PTRDIFF_TYPE__) (stride)))
 
 #define _tile_stored(dst,base,stride)		\
   _tile_stored_internal (dst, base, stride)
@@ -78,7 +78,7 @@ _tile_release (void)
 #define _tile_stored_internal(src,base,stride)				\
   __asm__ volatile							\
   ("{tilestored\t%%tmm"#src", (%0,%1,1)|tilestored\t[%0+%1*1], %%tmm"#src"}" \
-   :: "r" ((void*) (base)), "r" ((long) (stride)) \
+   :: "r" ((void*) (base)), "r" ((__PTRDIFF_TYPE__) (stride)) \
    : "memory")
 
 #define _tile_zero(dst)				\
diff --git a/gcc/config/i386/avx512bf16intrin.h b/gcc/config/i386/avx512bf16intrin.h
index b6e9ddad157..ecfff8ebfef 100644
--- a/gcc/config/i386/avx512bf16intrin.h
+++ b/gcc/config/i386/avx512bf16intrin.h
@@ -46,9 +46,9 @@ extern __inline float
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsbh_ss (__bfloat16 __A)
 {
-  union{ float a; unsigned int b;} __tmp;
-  __tmp.b = ((unsigned int)(__A)) << 16;
-  return __tmp.a;
+  union{ float __a; unsigned int __b;} __tmp;
+  __tmp.__b = ((unsigned int)(__A)) << 16;
+  return __tmp.__a;
 }
 
 /* vcvtne2ps2bf16 */
diff --git a/gcc/config/i386/avx512fp16intrin.h b/gcc/config/i386/avx512fp16intrin.h
index 28041516bac..e43acaab12a 100644
--- a/gcc/config/i386/avx512fp16intrin.h
+++ b/gcc/config/i386/avx512fp16intrin.h
@@ -272,10 +272,10 @@ _mm512_castph512_ph128 (__m512h __A)
 {
   union
   {
-    __m128h a[4];
-    __m512h v;
-  } u = { .v = __A };
-  return u.a[0];
+    __m128h __a[4];
+    __m512h __v;
+  } __u = { .__v = __A };
+  return __u.__a[0];
 }
 
 extern __inline __m256h
@@ -284,10 +284,10 @@ _mm512_castph512_ph256 (__m512h __A)
 {
   union
   {
-    __m256h a[2];
-    __m512h v;
-  } u = { .v = __A };
-  return u.a[0];
+    __m256h __a[2];
+    __m512h __v;
+  } __u = { .__v = __A };
+  return __u.__a[0];
 }
 
 extern __inline __m512h
@@ -296,11 +296,11 @@ _mm512_castph128_ph512 (__m128h __A)
 {
   union
   {
-    __m128h a[4];
-    __m512h v;
-  } u;
-  u.a[0] = __A;
-  return u.v;
+    __m128h __a[4];
+    __m512h __v;
+  } __u;
+  __u.__a[0] = __A;
+  return __u.__v;
 }
 
 extern __inline __m512h
@@ -309,11 +309,11 @@ _mm512_castph256_ph512 (__m256h __A)
 {
   union
   {
-    __m256h a[2];
-    __m512h v;
-  } u;
-  u.a[0] = __A;
-  return u.v;
+    __m256h __a[2];
+    __m512h __v;
+  } __u;
+  __u.__a[0] = __A;
+  return __u.__v;
 }
 
 extern __inline __m512h
@@ -7155,11 +7155,11 @@ _mm512_set1_pch (_Float16 _Complex __A)
 {
   union
   {
-    _Float16 _Complex a;
-    float b;
-  } u = { .a = __A};
+    _Float16 _Complex __a;
+    float __b;
+  } __u = { .__a = __A};
 
-  return (__m512h) _mm512_set1_ps (u.b);
+  return (__m512h) _mm512_set1_ps (__u.__b);
 }
 
 // intrinsics below are alias for f*mul_*ch
diff --git a/gcc/config/i386/avx512fp16vlintrin.h b/gcc/config/i386/avx512fp16vlintrin.h
index 0794498a3d6..2783971accb 100644
--- a/gcc/config/i386/avx512fp16vlintrin.h
+++ b/gcc/config/i386/avx512fp16vlintrin.h
@@ -124,10 +124,10 @@ _mm256_castph256_ph128 (__m256h __A)
 {
   union
   {
-    __m128h a[2];
-    __m256h v;
-  } u = { .v = __A };
-  return u.a[0];
+    __m128h __a[2];
+    __m256h __v;
+  } __u = { .__v = __A };
+  return __u.__a[0];
 }
 
 extern __inline __m256h
@@ -136,11 +136,11 @@ _mm256_castph128_ph256 (__m128h __A)
 {
   union
   {
-    __m128h a[2];
-    __m256h v;
-  } u;
-  u.a[0] = __A;
-  return u.v;
+    __m128h __a[2];
+    __m256h __v;
+  } __u;
+  __u.__a[0] = __A;
+  return __u.__v;
 }
 
 extern __inline __m256h
@@ -3317,11 +3317,11 @@ _mm256_set1_pch (_Float16 _Complex __A)
 {
   union
   {
-    _Float16 _Complex a;
-    float b;
-  } u = { .a = __A };
+    _Float16 _Complex __a;
+    float __b;
+  } __u = { .__a = __A };
 
-  return (__m256h) _mm256_set1_ps (u.b);
+  return (__m256h) _mm256_set1_ps (__u.__b);
 }
 
 extern __inline __m128h
@@ -3330,11 +3330,11 @@ _mm_set1_pch (_Float16 _Complex __A)
 {
   union
   {
-    _Float16 _Complex a;
-    float b;
-  } u = { .a = __A };
+    _Float16 _Complex __a;
+    float __b;
+  } __u = { .__a = __A };
 
-  return (__m128h) _mm_set1_ps (u.b);
+  return (__m128h) _mm_set1_ps (__u.__b);
 }
 
 // intrinsics below are alias for f*mul_*ch
diff --git a/gcc/config/i386/driver-i386.cc b/gcc/config/i386/driver-i386.cc
index 9e0ae0b2baa..fcf23fd921d 100644
--- a/gcc/config/i386/driver-i386.cc
+++ b/gcc/config/i386/driver-i386.cc
@@ -574,15 +574,12 @@ const char *host_detect_local_cpu (int argc, const char **argv)
 	      /* This is unknown family 0x6 CPU.  */
 	      if (has_feature (FEATURE_AVX))
 		{
+		  /* Assume Tiger Lake */
 		  if (has_feature (FEATURE_AVX512VP2INTERSECT))
-		    {
-		      if (has_feature (FEATURE_TSXLDTRK))
-			/* Assume Sapphire Rapids.  */
-			cpu = "sapphirerapids";
-		      else
-			/* Assume Tiger Lake */
-			cpu = "tigerlake";
-		    }
+		    cpu = "tigerlake";
+		  /* Assume Sapphire Rapids.  */
+		  else if (has_feature (FEATURE_TSXLDTRK))
+		    cpu = "sapphirerapids";
 		  /* Assume Cooper Lake */
 		  else if (has_feature (FEATURE_AVX512BF16))
 		    cpu = "cooperlake";
diff --git a/gcc/config/i386/i386-builtin.def b/gcc/config/i386/i386-builtin.def
index b410102614d..bdd378ffda0 100644
--- a/gcc/config/i386/i386-builtin.def
+++ b/gcc/config/i386/i386-builtin.def
@@ -1036,8 +1036,8 @@ BDESC (OPTION_MASK_ISA_AVX, 0, CODE_FOR_avx_vpermilvarv8sf3, "__builtin_ia32_vpe
 
 BDESC (OPTION_MASK_ISA_AVX, 0, CODE_FOR_avx_blendpd256, "__builtin_ia32_blendpd256", IX86_BUILTIN_BLENDPD256, UNKNOWN, (int) V4DF_FTYPE_V4DF_V4DF_INT)
 BDESC (OPTION_MASK_ISA_AVX, 0, CODE_FOR_avx_blendps256, "__builtin_ia32_blendps256", IX86_BUILTIN_BLENDPS256, UNKNOWN, (int) V8SF_FTYPE_V8SF_V8SF_INT)
-BDESC (OPTION_MASK_ISA_AVX, 0, CODE_FOR_nothing, "__builtin_ia32_blendvpd256", IX86_BUILTIN_BLENDVPD256, UNKNOWN, (int) V4DF_FTYPE_V4DF_V4DF_V4DF)
-BDESC (OPTION_MASK_ISA_AVX, 0, CODE_FOR_nothing, "__builtin_ia32_blendvps256", IX86_BUILTIN_BLENDVPS256, UNKNOWN, (int) V8SF_FTYPE_V8SF_V8SF_V8SF)
+BDESC (OPTION_MASK_ISA_AVX, 0, CODE_FOR_avx_blendvpd256, "__builtin_ia32_blendvpd256", IX86_BUILTIN_BLENDVPD256, UNKNOWN, (int) V4DF_FTYPE_V4DF_V4DF_V4DF)
+BDESC (OPTION_MASK_ISA_AVX, 0, CODE_FOR_avx_blendvps256, "__builtin_ia32_blendvps256", IX86_BUILTIN_BLENDVPS256, UNKNOWN, (int) V8SF_FTYPE_V8SF_V8SF_V8SF)
 BDESC (OPTION_MASK_ISA_AVX, 0, CODE_FOR_avx_dpps256, "__builtin_ia32_dpps256", IX86_BUILTIN_DPPS256, UNKNOWN, (int) V8SF_FTYPE_V8SF_V8SF_INT)
 BDESC (OPTION_MASK_ISA_AVX, 0, CODE_FOR_avx_shufpd256, "__builtin_ia32_shufpd256", IX86_BUILTIN_SHUFPD256, UNKNOWN, (int) V4DF_FTYPE_V4DF_V4DF_INT)
 BDESC (OPTION_MASK_ISA_AVX, 0, CODE_FOR_avx_shufps256, "__builtin_ia32_shufps256", IX86_BUILTIN_SHUFPS256, UNKNOWN, (int) V8SF_FTYPE_V8SF_V8SF_INT)
diff --git a/gcc/config/i386/i386-builtins.cc b/gcc/config/i386/i386-builtins.cc
index 8c6d0fe9631..050c6228a18 100644
--- a/gcc/config/i386/i386-builtins.cc
+++ b/gcc/config/i386/i386-builtins.cc
@@ -2280,7 +2280,7 @@ fold_builtin_cpu (tree fndecl, tree *args)
       /* Check the value.  */
       final = build2 (EQ_EXPR, unsigned_type_node, ref,
 		      build_int_cstu (unsigned_type_node, field_val));
-      return build1 (CONVERT_EXPR, integer_type_node, final);
+      return build1 (NOP_EXPR, integer_type_node, final);
     }
   else if (fn_code == IX86_BUILTIN_CPU_SUPPORTS)
     {
@@ -2305,7 +2305,8 @@ fold_builtin_cpu (tree fndecl, tree *args)
 	  return integer_zero_node;
 	}
 
-      if (isa_names_table[i].feature >= 32)
+      unsigned feature = isa_names_table[i].feature;
+      if (feature >= INT_TYPE_SIZE)
 	{
 	  if (ix86_cpu_features2_var == nullptr)
 	    {
@@ -2323,46 +2324,41 @@ fold_builtin_cpu (tree fndecl, tree *args)
 	      varpool_node::add (ix86_cpu_features2_var);
 	    }
 
-	  for (unsigned int j = 0; j < SIZE_OF_CPU_FEATURES; j++)
-	    if (isa_names_table[i].feature < (32 + 32 + j * 32))
-	      {
-		field_val = (1U << (isa_names_table[i].feature
-				    - (32 + j * 32)));
-		tree index = size_int (j);
-		array_elt = build4 (ARRAY_REF, unsigned_type_node,
-				    ix86_cpu_features2_var,
-				    index, NULL_TREE, NULL_TREE);
-		/* Return __cpu_features2[index] & field_val  */
-		final = build2 (BIT_AND_EXPR, unsigned_type_node,
-				array_elt,
-				build_int_cstu (unsigned_type_node,
-						field_val));
-		return build1 (CONVERT_EXPR, integer_type_node, final);
-	      }
+	  /* Skip __cpu_features[0].  */
+	  feature -= INT_TYPE_SIZE;
+	  tree index = size_int (feature / INT_TYPE_SIZE);
+	  feature = feature % INT_TYPE_SIZE;
+	  array_elt = build4 (ARRAY_REF, unsigned_type_node,
+			      ix86_cpu_features2_var,
+			      index, NULL_TREE, NULL_TREE);
+	  /* Return __cpu_features2[index] & field_val  */
 	}
+      else
+	{
+	  field = TYPE_FIELDS (ix86_cpu_model_type_node);
+	  /* Get the last field, which is __cpu_features.  */
+	  while (DECL_CHAIN (field))
+	    field = DECL_CHAIN (field);
 
-      field = TYPE_FIELDS (ix86_cpu_model_type_node);
-      /* Get the last field, which is __cpu_features.  */
-      while (DECL_CHAIN (field))
-        field = DECL_CHAIN (field);
+	  /* Get the appropriate field: __cpu_model.__cpu_features  */
+	  ref = build3 (COMPONENT_REF, TREE_TYPE (field), ix86_cpu_model_var,
+			field, NULL_TREE);
 
-      /* Get the appropriate field: __cpu_model.__cpu_features  */
-      ref = build3 (COMPONENT_REF, TREE_TYPE (field), ix86_cpu_model_var,
-		    field, NULL_TREE);
+	  /* Access the 0th element of __cpu_features array.  */
+	  array_elt = build4 (ARRAY_REF, unsigned_type_node, ref,
+			      integer_zero_node, NULL_TREE, NULL_TREE);
 
-      /* Access the 0th element of __cpu_features array.  */
-      array_elt = build4 (ARRAY_REF, unsigned_type_node, ref,
-			  integer_zero_node, NULL_TREE, NULL_TREE);
+	  /* Return __cpu_model.__cpu_features[0] & field_val  */
+	}
 
-      field_val = (1U << isa_names_table[i].feature);
-      /* Return __cpu_model.__cpu_features[0] & field_val  */
+      field_val = 1U << feature;
       final = build2 (BIT_AND_EXPR, unsigned_type_node, array_elt,
 		      build_int_cstu (unsigned_type_node, field_val));
-      if (isa_names_table[i].feature == (INT_TYPE_SIZE - 1))
+      if (feature == INT_TYPE_SIZE - 1)
 	return build2 (NE_EXPR, integer_type_node, final,
 		       build_int_cst (unsigned_type_node, 0));
       else
-	return build1 (CONVERT_EXPR, integer_type_node, final);
+	return build1 (NOP_EXPR, integer_type_node, final);
     }
   gcc_unreachable ();
 }
diff --git a/gcc/config/i386/i386-d.cc b/gcc/config/i386/i386-d.cc
index a62339cae30..27e2b75fc25 100644
--- a/gcc/config/i386/i386-d.cc
+++ b/gcc/config/i386/i386-d.cc
@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/i386/i386-d.h b/gcc/config/i386/i386-d.h
new file mode 100644
index 00000000000..b9806889df9
--- /dev/null
+++ b/gcc/config/i386/i386-d.h
@@ -0,0 +1,26 @@
+/* Definitions for the D front end on the x86 architecture.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* In i386-d.cc  */
+extern void ix86_d_target_versions (void);
+extern void ix86_d_register_target_info (void);
+extern bool ix86_d_has_stdcall_convention (unsigned int *, unsigned int *);
+
+/* Target hooks for D language.  */
+#define TARGET_D_CPU_VERSIONS ix86_d_target_versions
+#define TARGET_D_REGISTER_CPU_TARGET_INFO ix86_d_register_target_info
+#define TARGET_D_HAS_STDCALL_CONVENTION ix86_d_has_stdcall_convention
diff --git a/gcc/config/i386/i386-expand.cc b/gcc/config/i386/i386-expand.cc
index 31780b6daf7..faa63a48bcd 100644
--- a/gcc/config/i386/i386-expand.cc
+++ b/gcc/config/i386/i386-expand.cc
@@ -12234,7 +12234,7 @@ ix86_expand_vec_set_builtin (tree exp)
   op1 = expand_expr (arg1, NULL_RTX, mode1, EXPAND_NORMAL);
   elt = get_element_number (TREE_TYPE (arg0), arg2);
 
-  if (GET_MODE (op1) != mode1 && GET_MODE (op1) != VOIDmode)
+  if (GET_MODE (op1) != mode1)
     op1 = convert_modes (mode1, GET_MODE (op1), op1, true);
 
   op0 = force_reg (tmode, op0);
diff --git a/gcc/config/i386/i386-protos.h b/gcc/config/i386/i386-protos.h
index 3596ce81ecf..5b09924c929 100644
--- a/gcc/config/i386/i386-protos.h
+++ b/gcc/config/i386/i386-protos.h
@@ -274,11 +274,6 @@ extern bool ix86_extract_perm_from_pool_constant (int*, rtx);
 extern void ix86_target_macros (void);
 extern void ix86_register_pragmas (void);
 
-/* In i386-d.cc  */
-extern void ix86_d_target_versions (void);
-extern void ix86_d_register_target_info (void);
-extern bool ix86_d_has_stdcall_convention (unsigned int *, unsigned int *);
-
 /* In winnt.cc  */
 extern void i386_pe_unique_section (tree, int);
 extern void i386_pe_declare_function_type (FILE *, const char *, int);
diff --git a/gcc/config/i386/i386.cc b/gcc/config/i386/i386.cc
index 9dd9fa68722..a9ef291c514 100644
--- a/gcc/config/i386/i386.cc
+++ b/gcc/config/i386/i386.cc
@@ -18351,6 +18351,15 @@ ix86_gimple_fold_builtin (gimple_stmt_iterator *gsi)
 	}
       break;
 
+    case IX86_BUILTIN_PBLENDVB256:
+    case IX86_BUILTIN_BLENDVPS256:
+    case IX86_BUILTIN_BLENDVPD256:
+      /* pcmpeqb/d/q is under avx2, w/o avx2, it's veclower
+	 to scalar operations and not combined back.  */
+      if (!TARGET_AVX2)
+	break;
+
+      /* FALLTHRU.  */
     case IX86_BUILTIN_BLENDVPD:
       /* blendvpd is under sse4.1 but pcmpgtq is under sse4.2,
 	 w/o sse4.2, it's veclowered to scalar operations and
@@ -18359,10 +18368,7 @@ ix86_gimple_fold_builtin (gimple_stmt_iterator *gsi)
 	break;
       /* FALLTHRU.  */
     case IX86_BUILTIN_PBLENDVB128:
-    case IX86_BUILTIN_PBLENDVB256:
     case IX86_BUILTIN_BLENDVPS:
-    case IX86_BUILTIN_BLENDVPS256:
-    case IX86_BUILTIN_BLENDVPD256:
       gcc_assert (n_args == 3);
       arg0 = gimple_call_arg (stmt, 0);
       arg1 = gimple_call_arg (stmt, 1);
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
index 363082ba47b..c7ef7471d60 100644
--- a/gcc/config/i386/i386.h
+++ b/gcc/config/i386/i386.h
@@ -608,11 +608,6 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);
 /* Target Pragmas.  */
 #define REGISTER_TARGET_PRAGMAS() ix86_register_pragmas ()
 
-/* Target hooks for D language.  */
-#define TARGET_D_CPU_VERSIONS ix86_d_target_versions
-#define TARGET_D_REGISTER_CPU_TARGET_INFO ix86_d_register_target_info
-#define TARGET_D_HAS_STDCALL_CONVENTION ix86_d_has_stdcall_convention
-
 #ifndef CC1_SPEC
 #define CC1_SPEC "%(cc1_cpu) "
 #endif
@@ -2328,10 +2323,9 @@ constexpr wide_int_bitmask PTA_ICELAKE_SERVER = PTA_ICELAKE_CLIENT
 constexpr wide_int_bitmask PTA_TIGERLAKE = PTA_ICELAKE_CLIENT | PTA_MOVDIRI
   | PTA_MOVDIR64B | PTA_CLWB | PTA_AVX512VP2INTERSECT | PTA_KL | PTA_WIDEKL;
 constexpr wide_int_bitmask PTA_SAPPHIRERAPIDS = PTA_ICELAKE_SERVER | PTA_MOVDIRI
-  | PTA_MOVDIR64B | PTA_AVX512VP2INTERSECT | PTA_ENQCMD | PTA_CLDEMOTE
-  | PTA_PTWRITE | PTA_WAITPKG | PTA_SERIALIZE | PTA_TSXLDTRK | PTA_AMX_TILE
-  | PTA_AMX_INT8 | PTA_AMX_BF16 | PTA_UINTR | PTA_AVXVNNI | PTA_AVX512FP16
-  | PTA_AVX512BF16;
+  | PTA_MOVDIR64B | PTA_ENQCMD | PTA_CLDEMOTE | PTA_PTWRITE | PTA_WAITPKG
+  | PTA_SERIALIZE | PTA_TSXLDTRK | PTA_AMX_TILE | PTA_AMX_INT8 | PTA_AMX_BF16
+  | PTA_UINTR | PTA_AVXVNNI | PTA_AVX512FP16 | PTA_AVX512BF16;
 constexpr wide_int_bitmask PTA_KNL = PTA_BROADWELL | PTA_AVX512PF
   | PTA_AVX512ER | PTA_AVX512F | PTA_AVX512CD | PTA_PREFETCHWT1;
 constexpr wide_int_bitmask PTA_BONNELL = PTA_CORE2 | PTA_MOVBE;
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 1c4781d26f7..624d85ca7f0 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -20745,7 +20745,8 @@
   && REGNO (operands[2]) != REGNO (operands[1])
   && peep2_reg_dead_p (2, operands[1])
   && peep2_reg_dead_p (4, operands[2])
-  && !reg_overlap_mentioned_p (operands[0], operands[3])"
+  && !reg_overlap_mentioned_p (operands[0], operands[3])
+  && !reg_mentioned_p (operands[2], operands[6])"
  [(parallel [(set (match_dup 7) (match_dup 8))
 	     (set (match_dup 1) (match_dup 9))])
   (set (match_dup 0) (match_dup 3))
diff --git a/gcc/config/i386/predicates.md b/gcc/config/i386/predicates.md
index a8cc17a054d..ac02c61acb3 100644
--- a/gcc/config/i386/predicates.md
+++ b/gcc/config/i386/predicates.md
@@ -2019,11 +2019,11 @@
   for(i = 4; i < 7; i++)
     {
       elt = XVECEXP (op, 0, i);
-      if (GET_CODE (elt) != SET
-	  || GET_CODE (SET_DEST (elt)) != REG
-	  || GET_MODE (SET_DEST (elt)) != V2DImode
-	  || REGNO (SET_DEST (elt)) != GET_SSE_REGNO (i)
-	  || SET_SRC (elt) != CONST0_RTX (V2DImode))
+      if (GET_CODE (elt) != CLOBBER
+	  || GET_MODE (elt) != VOIDmode
+	  || GET_CODE (XEXP (elt, 0)) != REG
+	  || GET_MODE (XEXP (elt, 0)) != V2DImode
+	  || REGNO (XEXP (elt, 0)) != GET_SSE_REGNO (i))
 	return false;
     }
 
@@ -2069,11 +2069,11 @@
   for(i = 4; i < 7; i++)
     {
       elt = XVECEXP (op, 0, i + 1);
-      if (GET_CODE (elt) != SET
-	  || GET_CODE (SET_DEST (elt)) != REG
-	  || GET_MODE (SET_DEST (elt)) != V2DImode
-	  || REGNO (SET_DEST (elt)) != GET_SSE_REGNO (i)
-	  || SET_SRC (elt) != CONST0_RTX (V2DImode))
+      if (GET_CODE (elt) != CLOBBER
+	  || GET_MODE (elt) != VOIDmode
+	  || GET_CODE (XEXP (elt, 0)) != REG
+	  || GET_MODE (XEXP (elt, 0)) != V2DImode
+	  || REGNO (XEXP (elt, 0)) != GET_SSE_REGNO (i))
 	return false;
     }
 
diff --git a/gcc/config/i386/smmintrin.h b/gcc/config/i386/smmintrin.h
index eb6a451c10a..47fd9b8a2c6 100644
--- a/gcc/config/i386/smmintrin.h
+++ b/gcc/config/i386/smmintrin.h
@@ -365,17 +365,18 @@ _mm_insert_ps (__m128 __D, __m128 __S, const int __N)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_extract_ps (__m128 __X, const int __N)
 {
-  union { int i; float f; } __tmp;
-  __tmp.f = __builtin_ia32_vec_ext_v4sf ((__v4sf)__X, __N);
-  return __tmp.i;
+  union { int __i; float __f; } __tmp;
+  __tmp.__f = __builtin_ia32_vec_ext_v4sf ((__v4sf)__X, __N);
+  return __tmp.__i;
 }
 #else
 #define _mm_extract_ps(X, N)						\
   (__extension__							\
    ({									\
-     union { int i; float f; } __tmp;					\
-     __tmp.f = __builtin_ia32_vec_ext_v4sf ((__v4sf)(__m128)(X), (int)(N)); \
-     __tmp.i;								\
+     union { int __i; float __f; } __tmp;				\
+     __tmp.__f = __builtin_ia32_vec_ext_v4sf ((__v4sf)(__m128)(X),	\
+					      (int)(N));		\
+     __tmp.__i;								\
    }))
 #endif
 
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index 2ce1aed4ad9..eb767e56ca4 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -1215,7 +1215,7 @@
 ;; For 256-bit modes for TARGET_AVX512VL && TARGET_AVX512DQ
 ;; i32x4, f32x4, i64x2 or f64x2 suffixes.
 (define_mode_attr i128vldq
-  [(V8SF "f32x4") (V4DF "f64x2")
+  [(V16HF "i32x4") (V8SF "f32x4") (V4DF "f64x2")
    (V32QI "i32x4") (V16HI "i32x4") (V8SI "i32x4") (V4DI "i64x2")])
 
 ;; Mix-n-match
@@ -23424,7 +23424,7 @@
 	  (match_operand:VF_128 2 "register_operand" "v")
 	  (const_int 1)))]
   "TARGET_AVX512ER"
-  "vrcp28<ssescalarmodesuffix>\t{<round_saeonly_mask_op3>%1, %2, %0<mask_operand3>|<mask_opernad3>%0, %2, %<iptr>1<round_saeonly_mask_op3>}"
+  "vrcp28<ssescalarmodesuffix>\t{<round_saeonly_mask_op3>%1, %2, %0<mask_operand3>|<mask_operand3>%0, %2, %<iptr>1<round_saeonly_mask_op3>}"
   [(set_attr "length_immediate" "1")
    (set_attr "prefix" "evex")
    (set_attr "type" "sse")
@@ -28404,7 +28404,7 @@
 
   for (i = 4; i < 7; i++)
     XVECEXP (operands[2], 0, i)
-      = gen_rtx_SET (xmm_regs[i], CONST0_RTX (V2DImode));
+      = gen_rtx_CLOBBER (VOIDmode, xmm_regs[i]);
 
   XVECEXP (operands[2], 0, 7)
     = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));
@@ -28461,7 +28461,7 @@
 
   for (i = 4; i < 7; i++)
     XVECEXP (operands[2], 0, i + 1)
-      = gen_rtx_SET (xmm_regs[i], CONST0_RTX (V2DImode));
+      = gen_rtx_CLOBBER (VOIDmode, xmm_regs[i]);
 
   XVECEXP (operands[2], 0, 8)
     = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));
diff --git a/gcc/config/i386/t-i386 b/gcc/config/i386/t-i386
index 4e2a0efc615..ffdbbdfe8ce 100644
--- a/gcc/config/i386/t-i386
+++ b/gcc/config/i386/t-i386
@@ -62,7 +62,12 @@ i386-features.o: $(srcdir)/config/i386/i386-features.cc
 	$(COMPILE) $<
 	$(POSTCOMPILE)
 
+# i386-builtin-types.inc is included into i386-builtins.h.
+# Below are direct users of i386-builtins.h:
 i386.o: i386-builtin-types.inc
+i386-builtins.o: i386-builtin-types.inc
+i386-expand.o: i386-builtin-types.inc
+i386-features.o: i386-builtin-types.inc
 
 i386-builtin-types.inc: s-i386-bt ; @true
 s-i386-bt: $(srcdir)/config/i386/i386-builtin-types.awk \
diff --git a/gcc/config/i386/winnt-d.cc b/gcc/config/i386/winnt-d.cc
index 3d990a12331..00c28c3964a 100644
--- a/gcc/config/i386/winnt-d.cc
+++ b/gcc/config/i386/winnt-d.cc
@@ -21,9 +21,9 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "target.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
-#include "tm_p.h"
 
 /* Implement TARGET_D_OS_VERSIONS for Windows targets.  */
 
diff --git a/gcc/config/i386/x86-tune.def b/gcc/config/i386/x86-tune.def
index d983e2f6213..1e1b206a71c 100644
--- a/gcc/config/i386/x86-tune.def
+++ b/gcc/config/i386/x86-tune.def
@@ -485,7 +485,8 @@ DEF_TUNE (X86_TUNE_AVOID_128FMA_CHAINS, "avoid_fma_chains", m_ZNVER)
 
 /* X86_TUNE_AVOID_256FMA_CHAINS: Avoid creating loops with tight 256bit or
    smaller FMA chain.  */
-DEF_TUNE (X86_TUNE_AVOID_256FMA_CHAINS, "avoid_fma256_chains", m_ZNVER2 | m_ZNVER3)
+DEF_TUNE (X86_TUNE_AVOID_256FMA_CHAINS, "avoid_fma256_chains", m_ZNVER2 | m_ZNVER3
+	  | m_ALDERLAKE | m_SAPPHIRERAPIDS)
 
 /* X86_TUNE_V2DF_REDUCTION_PREFER_PHADDPD: Prefer haddpd
    for v2df vector reduction.  */
diff --git a/gcc/config/loongarch/loongarch.cc b/gcc/config/loongarch/loongarch.cc
index 5c9a33c14f7..22901cb6101 100644
--- a/gcc/config/loongarch/loongarch.cc
+++ b/gcc/config/loongarch/loongarch.cc
@@ -1507,8 +1507,8 @@ loongarch_build_integer (struct loongarch_integer_op *codes,
       bool lu32i[2] = {(value & LU32I_B) == 0, (value & LU32I_B) == LU32I_B};
       bool lu52i[2] = {(value & LU52I_B) == 0, (value & LU52I_B) == LU52I_B};
 
-      int sign31 = (value & (1UL << 31)) >> 31;
-      int sign51 = (value & (1UL << 51)) >> 51;
+      int sign31 = (value & (HOST_WIDE_INT_1U << 31)) >> 31;
+      int sign51 = (value & (HOST_WIDE_INT_1U << 51)) >> 51;
       /* Determine whether the upper 32 bits are sign-extended from the lower
 	 32 bits. If it is, the instructions to load the high order can be
 	 ommitted.  */
@@ -1529,7 +1529,7 @@ loongarch_build_integer (struct loongarch_integer_op *codes,
 
       /* Determine whether the 52-61 bits are sign-extended from the low order,
 	 and if not, load the 52-61 bits.  */
-      if (!lu52i[(value & (1ULL << 51)) >> 51])
+      if (!lu52i[(value & (HOST_WIDE_INT_1U << 51)) >> 51])
 	{
 	  codes[cost].method = METHOD_LU52I;
 	  codes[cost].value = value & LU52I_B;
diff --git a/gcc/config/loongarch/loongarch.h b/gcc/config/loongarch/loongarch.h
index f9de9a6e4fb..015d70c469c 100644
--- a/gcc/config/loongarch/loongarch.h
+++ b/gcc/config/loongarch/loongarch.h
@@ -561,7 +561,8 @@ enum reg_class
   64, 65, 66, 67, 68, 69, 70, 71, 72, 73}
 
 #define IMM_BITS 12
-#define IMM_REACH (1LL << IMM_BITS)
+#define IMM_REACH (HOST_WIDE_INT_1 << IMM_BITS)
+#define HWIT_1U HOST_WIDE_INT_1U
 
 /* True if VALUE is an unsigned 6-bit number.  */
 
@@ -589,18 +590,20 @@ enum reg_class
 /* True if VALUE can be loaded into a register using LU12I.  */
 
 #define LU12I_OPERAND(VALUE) \
-  (((VALUE) | ((1UL << 31) - IMM_REACH)) == ((1UL << 31) - IMM_REACH) \
-   || ((VALUE) | ((1UL << 31) - IMM_REACH)) + IMM_REACH == 0)
+  (((VALUE) | ((HWIT_1U << 31) - IMM_REACH)) == ((HWIT_1U << 31) - IMM_REACH) \
+   || ((VALUE) | ((HWIT_1U << 31) - IMM_REACH)) + IMM_REACH == 0)
 
 /* True if VALUE can be loaded into a register using LU32I.  */
 
 #define LU32I_OPERAND(VALUE) \
-  (((VALUE) | (((1ULL << 19) - 1) << 32)) == (((1ULL << 19) - 1) << 32) \
-   || ((VALUE) | (((1ULL << 19) - 1) << 32)) + (1ULL << 32) == 0)
+  (((VALUE) | (((HWIT_1U << 19) - 1) << 32)) == (((HWIT_1U << 19) - 1) << 32) \
+   || ((VALUE) | (((HWIT_1U << 19) - 1) << 32)) + (HWIT_1U << 32) == 0)
 
 /* True if VALUE can be loaded into a register using LU52I.  */
 
-#define LU52I_OPERAND(VALUE) (((VALUE) | (0xfffULL << 52)) == (0xfffULL << 52))
+#define HWIT_UC_0xFFF HOST_WIDE_INT_UC(0xfff)
+#define LU52I_OPERAND(VALUE) \
+  (((VALUE) | (HWIT_UC_0xFFF << 52)) == (HWIT_UC_0xFFF << 52))
 
 /* Return a value X with the low 12 bits clear, and such that
    VALUE - X is a signed 12-bit value.  */
diff --git a/gcc/config/loongarch/sync.md b/gcc/config/loongarch/sync.md
index 0c4f1983e88..45be1442439 100644
--- a/gcc/config/loongarch/sync.md
+++ b/gcc/config/loongarch/sync.md
@@ -448,6 +448,29 @@
 }
   [(set (attr "length") (const_int 32))])
 
+(define_insn "atomic_cas_value_exchange_7_<mode>"
+  [(set (match_operand:GPR 0 "register_operand" "=&r")
+	(match_operand:GPR 1 "memory_operand" "+ZC"))
+   (set (match_dup 1)
+	(unspec_volatile:GPR [(match_operand:GPR 2 "reg_or_0_operand" "rJ")
+			      (match_operand:GPR 3 "reg_or_0_operand" "rJ")
+			      (match_operand:GPR 4 "reg_or_0_operand" "rJ")
+			      (match_operand:GPR 5 "reg_or_0_operand"  "rJ")
+			      (match_operand:SI 6 "const_int_operand")] ;; model
+	 UNSPEC_SYNC_EXCHANGE))
+   (clobber (match_scratch:GPR 7 "=&r"))]
+  ""
+{
+  return "%G6\\n\\t"
+	 "1:\\n\\t"
+	 "ll.<amo>\\t%0,%1\\n\\t"
+	 "and\\t%7,%0,%z3\\n\\t"
+	 "or%i5\\t%7,%7,%5\\n\\t"
+	 "sc.<amo>\\t%7,%1\\n\\t"
+	 "beqz\\t%7,1b\\n\\t";
+}
+  [(set (attr "length") (const_int 20))])
+
 (define_expand "atomic_exchange<mode>"
   [(set (match_operand:SHORT 0 "register_operand")
 	(unspec_volatile:SHORT
@@ -459,9 +482,9 @@
   ""
 {
   union loongarch_gen_fn_ptrs generator;
-  generator.fn_7 = gen_atomic_cas_value_cmp_and_7_si;
+  generator.fn_7 = gen_atomic_cas_value_exchange_7_si;
   loongarch_expand_atomic_qihi (generator, operands[0], operands[1],
-				operands[1], operands[2], operands[3]);
+				const0_rtx, operands[2], operands[3]);
   DONE;
 })
 
diff --git a/gcc/config/mips/mips-d.cc b/gcc/config/mips/mips-d.cc
index 41a278a08fd..8b6ccd10604 100644
--- a/gcc/config/mips/mips-d.cc
+++ b/gcc/config/mips/mips-d.cc
@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/mips/mips-d.h b/gcc/config/mips/mips-d.h
new file mode 100644
index 00000000000..7cb3ed9716e
--- /dev/null
+++ b/gcc/config/mips/mips-d.h
@@ -0,0 +1,24 @@
+/* Definitions for the D front end on the MIPS architecture.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Routines implemented in mips-d.cc  */
+extern void mips_d_target_versions (void);
+extern void mips_d_register_target_info (void);
+
+/* Target hooks for D language.  */
+#define TARGET_D_CPU_VERSIONS mips_d_target_versions
+#define TARGET_D_REGISTER_CPU_TARGET_INFO mips_d_register_target_info
diff --git a/gcc/config/mips/mips-protos.h b/gcc/config/mips/mips-protos.h
index 9d0f4d90fd9..86350523c1b 100644
--- a/gcc/config/mips/mips-protos.h
+++ b/gcc/config/mips/mips-protos.h
@@ -388,8 +388,4 @@ extern void mips_register_frame_header_opt (void);
 extern void mips_expand_vec_cond_expr (machine_mode, machine_mode, rtx *);
 extern void mips_expand_vec_cmp_expr (rtx *);
 
-/* Routines implemented in mips-d.cc  */
-extern void mips_d_target_versions (void);
-extern void mips_d_register_target_info (void);
-
 #endif /* ! GCC_MIPS_PROTOS_H */
diff --git a/gcc/config/mips/mips.h b/gcc/config/mips/mips.h
index 858bbba3a36..02562d3b644 100644
--- a/gcc/config/mips/mips.h
+++ b/gcc/config/mips/mips.h
@@ -680,10 +680,6 @@ struct mips_cpu_info {
     }									\
   while (0)
 
-/* Target hooks for D language.  */
-#define TARGET_D_CPU_VERSIONS mips_d_target_versions
-#define TARGET_D_REGISTER_CPU_TARGET_INFO mips_d_register_target_info
-
 /* Default target_flags if no switches are specified  */
 
 #ifndef TARGET_DEFAULT
diff --git a/gcc/config/netbsd-d.cc b/gcc/config/netbsd-d.cc
index 286f010939f..dbabae7ab71 100644
--- a/gcc/config/netbsd-d.cc
+++ b/gcc/config/netbsd-d.cc
@@ -21,8 +21,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
-#include "memmodel.h"
-#include "tm_p.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/nvptx/nvptx.h b/gcc/config/nvptx/nvptx.h
index ed72c253191..294dd715c3d 100644
--- a/gcc/config/nvptx/nvptx.h
+++ b/gcc/config/nvptx/nvptx.h
@@ -27,7 +27,7 @@
 
 /* Run-time Target.  */
 
-#define STARTFILE_SPEC "%{mmainkernel:crt0.o}"
+#define STARTFILE_SPEC "%{mmainkernel:crt0.o%s}"
 
 #define TARGET_CPU_CPP_BUILTINS() nvptx_cpu_cpp_builtins ()
 
diff --git a/gcc/config/openbsd-d.cc b/gcc/config/openbsd-d.cc
index c1a2a89807a..bb3a3f28f6d 100644
--- a/gcc/config/openbsd-d.cc
+++ b/gcc/config/openbsd-d.cc
@@ -20,9 +20,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
-#include "memmodel.h"
 #include "tm.h"
-#include "tm_p.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/pa/pa-d.cc b/gcc/config/pa/pa-d.cc
index 122ad480447..077aeb5d634 100644
--- a/gcc/config/pa/pa-d.cc
+++ b/gcc/config/pa/pa-d.cc
@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "target.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/pa/pa-d.h b/gcc/config/pa/pa-d.h
new file mode 100644
index 00000000000..9a9df108f61
--- /dev/null
+++ b/gcc/config/pa/pa-d.h
@@ -0,0 +1,24 @@
+/* Definitions for the D front end on the HPPA architecture.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Routines implemented in pa-d.cc  */
+extern void pa_d_target_versions (void);
+extern void pa_d_register_target_info (void);
+
+/* Target hooks for D language.  */
+#define TARGET_D_CPU_VERSIONS pa_d_target_versions
+#define TARGET_D_REGISTER_CPU_TARGET_INFO pa_d_register_target_info
diff --git a/gcc/config/pa/pa-protos.h b/gcc/config/pa/pa-protos.h
index d474d9efc91..fe8b7a5091e 100644
--- a/gcc/config/pa/pa-protos.h
+++ b/gcc/config/pa/pa-protos.h
@@ -111,7 +111,3 @@ extern void pa_output_function_label (FILE *);
 extern void hppa_profile_hook (int);
 
 extern const int pa_magic_milli[];
-
-/* Routines implemented in pa-d.cc  */
-extern void pa_d_target_versions (void);
-extern void pa_d_register_target_info (void);
diff --git a/gcc/config/pa/pa.h b/gcc/config/pa/pa.h
index 92d3d1841a9..1ce6635ae9b 100644
--- a/gcc/config/pa/pa.h
+++ b/gcc/config/pa/pa.h
@@ -1310,9 +1310,5 @@ do {									     \
 
 #define NEED_INDICATE_EXEC_STACK 0
 
-/* Target hooks for D language.  */
-#define TARGET_D_CPU_VERSIONS pa_d_target_versions
-#define TARGET_D_REGISTER_CPU_TARGET_INFO pa_d_register_target_info
-
 /* Output default function prologue for hpux.  */
 #define TARGET_ASM_FUNCTION_PROLOGUE pa_output_function_prologue
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index 76ae35d4cfa..41382271e54 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -5071,23 +5071,25 @@
 						    (match_dup 2))))
 		       (const_int 0))])]
   ""
-  "")
+  "
+{
+  if (TARGET_64BIT)
+    operands[2] = force_reg (DImode, operands[2]);
+}")
 
 (define_insn ""
-  [(set (match_operand:DI 0 "register_operand" "=r,r")
-	(plus:DI (match_operand:DI 1 "reg_or_0_operand" "%rM,rM")
-		 (match_operand:DI 2 "arith11_operand" "r,I")))
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(plus:DI (match_operand:DI 1 "reg_or_0_operand" "%rM")
+		 (match_operand:DI 2 "register_operand" "r")))
    (trap_if (ne (plus:TI (sign_extend:TI (match_dup 1))
 			 (sign_extend:TI (match_dup 2)))
 		(sign_extend:TI (plus:DI (match_dup 1)
 					 (match_dup 2))))
 	    (const_int 0))]
   "TARGET_64BIT"
-  "@
-  add,tsv,* %2,%1,%0
-  addi,tsv,* %2,%1,%0"
-  [(set_attr "type" "binary,binary")
-   (set_attr "length" "4,4")])
+  "add,tsv,* %2,%1,%0"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -5262,23 +5264,25 @@
 						     (match_dup 2))))
 		       (const_int 0))])]
   ""
-  "")
+  "
+{
+  if (TARGET_64BIT)
+    operands[1] = force_reg (DImode, operands[1]);
+}")
 
 (define_insn ""
-  [(set (match_operand:DI 0 "register_operand" "=r,r")
-	(minus:DI (match_operand:DI 1 "arith11_operand" "r,I")
-		  (match_operand:DI 2 "reg_or_0_operand" "rM,rM")))
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(minus:DI (match_operand:DI 1 "register_operand" "r")
+		  (match_operand:DI 2 "reg_or_0_operand" "rM")))
    (trap_if (ne (minus:TI (sign_extend:TI (match_dup 1))
 			  (sign_extend:TI (match_dup 2)))
 		(sign_extend:TI (minus:DI (match_dup 1)
 					  (match_dup 2))))
 	    (const_int 0))]
   "TARGET_64BIT"
-  "@
-  {subo|sub,tsv} %1,%2,%0
-  {subio|subi,tsv} %1,%2,%0"
-  [(set_attr "type" "binary,binary")
-   (set_attr "length" "4,4")])
+  "sub,tsv,* %1,%2,%0"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r,&r")
diff --git a/gcc/config/riscv/riscv-d.cc b/gcc/config/riscv/riscv-d.cc
index 729de96d398..a762a35778d 100644
--- a/gcc/config/riscv/riscv-d.cc
+++ b/gcc/config/riscv/riscv-d.cc
@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "target.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/riscv/riscv-d.h b/gcc/config/riscv/riscv-d.h
new file mode 100644
index 00000000000..21a989edd8c
--- /dev/null
+++ b/gcc/config/riscv/riscv-d.h
@@ -0,0 +1,24 @@
+/* Definitions for the D front end on the RISC-V architecture.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Routines implemented in riscv-d.cc  */
+extern void riscv_d_target_versions (void);
+extern void riscv_d_register_target_info (void);
+
+/* Target hooks for D language.  */
+#define TARGET_D_CPU_VERSIONS riscv_d_target_versions
+#define TARGET_D_REGISTER_CPU_TARGET_INFO riscv_d_register_target_info
diff --git a/gcc/config/riscv/riscv-protos.h b/gcc/config/riscv/riscv-protos.h
index 20c2381c21a..65bb85f5587 100644
--- a/gcc/config/riscv/riscv-protos.h
+++ b/gcc/config/riscv/riscv-protos.h
@@ -78,10 +78,6 @@ extern bool riscv_gpr_save_operation_p (rtx);
 /* Routines implemented in riscv-c.cc.  */
 void riscv_cpu_cpp_builtins (cpp_reader *);
 
-/* Routines implemented in riscv-d.cc  */
-extern void riscv_d_target_versions (void);
-extern void riscv_d_register_target_info (void);
-
 /* Routines implemented in riscv-builtins.cc.  */
 extern void riscv_atomic_assign_expand_fenv (tree *, tree *, tree *);
 extern rtx riscv_expand_builtin (tree, rtx, rtx, machine_mode, int);
diff --git a/gcc/config/riscv/riscv.h b/gcc/config/riscv/riscv.h
index b3eb6abc2aa..b30b4576c09 100644
--- a/gcc/config/riscv/riscv.h
+++ b/gcc/config/riscv/riscv.h
@@ -27,10 +27,6 @@ along with GCC; see the file COPYING3.  If not see
 /* Target CPU builtins.  */
 #define TARGET_CPU_CPP_BUILTINS() riscv_cpu_cpp_builtins (pfile)
 
-/* Target hooks for D language.  */
-#define TARGET_D_CPU_VERSIONS riscv_d_target_versions
-#define TARGET_D_REGISTER_CPU_TARGET_INFO riscv_d_register_target_info
-
 #ifdef TARGET_BIG_ENDIAN_DEFAULT
 #define DEFAULT_ENDIAN_SPEC    "b"
 #else
diff --git a/gcc/config/rs6000/mma.md b/gcc/config/rs6000/mma.md
index a183b6a168a..f2952a3c3be 100644
--- a/gcc/config/rs6000/mma.md
+++ b/gcc/config/rs6000/mma.md
@@ -268,10 +268,28 @@
 (define_expand "movoo"
   [(set (match_operand:OO 0 "nonimmediate_operand")
 	(match_operand:OO 1 "input_operand"))]
-  "TARGET_MMA"
+  ""
 {
-  rs6000_emit_move (operands[0], operands[1], OOmode);
-  DONE;
+  if (TARGET_MMA)
+    {
+      rs6000_emit_move (operands[0], operands[1], OOmode);
+      DONE;
+    }
+  else if (currently_expanding_to_rtl && seen_error ())
+    {
+      /* PR103353 shows we may want to continue to expand the __builtin_vsx_lxvp
+	 built-in function, even if we have already emitted error messages about
+	 some missing required conditions.  As shown in that PR, without one
+	 explicit mov optab on OOmode provided, it would call emit_move_insn
+	 recursively.  So we allow this pattern to be generated when we are
+	 expanding to RTL and have seen errors.  It would not cause further ICEs
+	 as the compilation would stop soon after expanding.  */
+    }
+  else if (rs6000_opaque_type_invalid_use_p (currently_expanding_gimple_stmt))
+    ;
+  else
+    /* Catch unexpected cases.  */
+    gcc_assert (false);
 })
 
 (define_insn_and_split "*movoo"
@@ -300,10 +318,25 @@
 (define_expand "movxo"
   [(set (match_operand:XO 0 "nonimmediate_operand")
 	(match_operand:XO 1 "input_operand"))]
-  "TARGET_MMA"
+  ""
 {
-  rs6000_emit_move (operands[0], operands[1], XOmode);
-  DONE;
+  if (TARGET_MMA)
+    {
+      rs6000_emit_move (operands[0], operands[1], XOmode);
+      DONE;
+    }
+  else if (currently_expanding_to_rtl && seen_error ())
+    {
+      /* PR103353 shows we may want to continue to expand the __builtin_vsx_lxvp
+	 built-in function, even if we have already emitted error messages about
+	 some missing required conditions.  So do the same handlings for XOmode
+	 as OOmode here.  */
+    }
+  else if (rs6000_opaque_type_invalid_use_p (currently_expanding_gimple_stmt))
+    ;
+  else
+    /* Catch unexpected cases.  */
+    gcc_assert (false);
 })
 
 (define_insn_and_split "*movxo"
diff --git a/gcc/config/rs6000/rs6000-builtin.cc b/gcc/config/rs6000/rs6000-builtin.cc
index e925ba9fad9..26b486a9e5d 100644
--- a/gcc/config/rs6000/rs6000-builtin.cc
+++ b/gcc/config/rs6000/rs6000-builtin.cc
@@ -1121,7 +1121,12 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi,
       unsigned nvec = (fncode == RS6000_BIF_DISASSEMBLE_ACC) ? 4 : 2;
       tree dst_ptr = gimple_call_arg (stmt, 0);
       tree src_ptr = gimple_call_arg (stmt, 1);
-      tree src_type = TREE_TYPE (src_ptr);
+      tree src_type = (fncode == RS6000_BIF_DISASSEMBLE_ACC)
+		      ? build_pointer_type (vector_quad_type_node)
+		      : build_pointer_type (vector_pair_type_node);
+      if (TREE_TYPE (src_ptr) != src_type)
+	src_ptr = build1 (NOP_EXPR, src_type, src_ptr);
+
       tree src = create_tmp_reg_or_ssa_name (TREE_TYPE (src_type));
       gimplify_assign (src, build_simple_mem_ref (src_ptr), &new_seq);
 
@@ -1294,6 +1299,11 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)
   enum tree_code bcode;
   gimple *g;
 
+  /* For an unresolved overloaded builtin, return early here since there
+     is no builtin info for it and we are unable to fold it.  */
+  if (fn_code > RS6000_OVLD_NONE)
+    return false;
+
   size_t uns_fncode = (size_t) fn_code;
   enum insn_code icode = rs6000_builtin_info[uns_fncode].icode;
   const char *fn_name1 = rs6000_builtin_info[uns_fncode].bifname;
@@ -3295,6 +3305,14 @@ rs6000_expand_builtin (tree exp, rtx target, rtx /* subtarget */,
   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);
   enum rs6000_gen_builtins fcode
     = (enum rs6000_gen_builtins) DECL_MD_FUNCTION_CODE (fndecl);
+
+  /* Emit error message if it's an unresolved overloaded builtin.  */
+  if (fcode > RS6000_OVLD_NONE)
+    {
+      error ("unresolved overload for builtin %qF", fndecl);
+      return const0_rtx;
+    }
+
   size_t uns_fcode = (size_t)fcode;
   enum insn_code icode = rs6000_builtin_info[uns_fcode].icode;
 
diff --git a/gcc/config/rs6000/rs6000-c.cc b/gcc/config/rs6000/rs6000-c.cc
index 84bb98f94fb..fa0c93e1841 100644
--- a/gcc/config/rs6000/rs6000-c.cc
+++ b/gcc/config/rs6000/rs6000-c.cc
@@ -1755,6 +1755,36 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,
   vec<tree, va_gc> *arglist = static_cast<vec<tree, va_gc> *> (passed_arglist);
   unsigned int nargs = vec_safe_length (arglist);
 
+  /* If the number of arguments did not match the prototype, return NULL
+     and the generic code will issue the appropriate error message.  Skip
+     this test for functions where we don't fully describe all the possible
+     overload signatures in rs6000-overload.def (because they aren't relevant
+     to the expansion here).  If we don't, we get confusing error messages.  */
+  /* As an example, for vec_splats we have:
+
+; There are no actual builtins for vec_splats.  There is special handling for
+; this in altivec_resolve_overloaded_builtin in rs6000-c.cc, where the call
+; is replaced by a constructor.  The single overload here causes
+; __builtin_vec_splats to be registered with the front end so that can happen.
+[VEC_SPLATS, vec_splats, __builtin_vec_splats]
+  vsi __builtin_vec_splats (vsi);
+    ABS_V4SI SPLATS_FAKERY
+
+    So even though __builtin_vec_splats accepts all vector types, the
+    infrastructure cheats and just records one prototype.  We end up getting
+    an error message that refers to this specific prototype even when we
+    are handling a different argument type.  That is completely confusing
+    to the user, so it's best to let these cases be handled individually
+    in the resolve_vec_splats, etc., helper functions.  */
+
+  if (expected_args != nargs
+      && !(fcode == RS6000_OVLD_VEC_PROMOTE
+	   || fcode == RS6000_OVLD_VEC_SPLATS
+	   || fcode == RS6000_OVLD_VEC_EXTRACT
+	   || fcode == RS6000_OVLD_VEC_INSERT
+	   || fcode == RS6000_OVLD_VEC_STEP))
+    return NULL;
+
   for (n = 0;
        !VOID_TYPE_P (TREE_VALUE (fnargs)) && n < nargs;
        fnargs = TREE_CHAIN (fnargs), n++)
@@ -1815,36 +1845,6 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,
       types[n] = type;
     }
 
-  /* If the number of arguments did not match the prototype, return NULL
-     and the generic code will issue the appropriate error message.  Skip
-     this test for functions where we don't fully describe all the possible
-     overload signatures in rs6000-overload.def (because they aren't relevant
-     to the expansion here).  If we don't, we get confusing error messages.  */
-  /* As an example, for vec_splats we have:
-
-; There are no actual builtins for vec_splats.  There is special handling for
-; this in altivec_resolve_overloaded_builtin in rs6000-c.cc, where the call
-; is replaced by a constructor.  The single overload here causes
-; __builtin_vec_splats to be registered with the front end so that can happen.
-[VEC_SPLATS, vec_splats, __builtin_vec_splats]
-  vsi __builtin_vec_splats (vsi);
-    ABS_V4SI SPLATS_FAKERY
-
-    So even though __builtin_vec_splats accepts all vector types, the
-    infrastructure cheats and just records one prototype.  We end up getting
-    an error message that refers to this specific prototype even when we
-    are handling a different argument type.  That is completely confusing
-    to the user, so it's best to let these cases be handled individually
-    in the resolve_vec_splats, etc., helper functions.  */
-
-  if (n != expected_args
-      && !(fcode == RS6000_OVLD_VEC_PROMOTE
-	   || fcode == RS6000_OVLD_VEC_SPLATS
-	   || fcode == RS6000_OVLD_VEC_EXTRACT
-	   || fcode == RS6000_OVLD_VEC_INSERT
-	   || fcode == RS6000_OVLD_VEC_STEP))
-    return NULL;
-
   /* Some overloads require special handling.  */
   tree returned_expr = NULL;
   resolution res = unresolved;
diff --git a/gcc/config/rs6000/rs6000-call.cc b/gcc/config/rs6000/rs6000-call.cc
index f06c69252b2..d27df7b25ac 100644
--- a/gcc/config/rs6000/rs6000-call.cc
+++ b/gcc/config/rs6000/rs6000-call.cc
@@ -1111,6 +1111,12 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,
 	{
 	  cum->vregno += n_elts;
 
+	  /* If we are not splitting Complex IEEE128 args then account for the
+	     fact that they are passed in 2 VSX regs. */
+	  if (!targetm.calls.split_complex_arg && type
+	      && TREE_CODE (type) == COMPLEX_TYPE && elt_mode == KCmode)
+	    cum->vregno++;
+
 	  if (!TARGET_ALTIVEC)
 	    error ("cannot pass argument in vector register because"
 		   " altivec instructions are disabled, use %qs"
diff --git a/gcc/config/rs6000/rs6000-d.cc b/gcc/config/rs6000/rs6000-d.cc
index 74e78cf9e4d..7b9ca5a855e 100644
--- a/gcc/config/rs6000/rs6000-d.cc
+++ b/gcc/config/rs6000/rs6000-d.cc
@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/rs6000/rs6000-d.h b/gcc/config/rs6000/rs6000-d.h
new file mode 100644
index 00000000000..c805b304245
--- /dev/null
+++ b/gcc/config/rs6000/rs6000-d.h
@@ -0,0 +1,24 @@
+/* Definitions for the D front end on the PowerPC architecture.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Declare functions in rs6000-d.cc  */
+extern void rs6000_d_target_versions (void);
+extern void rs6000_d_register_target_info (void);
+
+/* Target hooks for D language.  */
+#define TARGET_D_CPU_VERSIONS rs6000_d_target_versions
+#define TARGET_D_REGISTER_CPU_TARGET_INFO rs6000_d_register_target_info
diff --git a/gcc/config/rs6000/rs6000-logue.cc b/gcc/config/rs6000/rs6000-logue.cc
index 59fe1c8cb8b..a868ede24fb 100644
--- a/gcc/config/rs6000/rs6000-logue.cc
+++ b/gcc/config/rs6000/rs6000-logue.cc
@@ -4924,7 +4924,7 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)
 	 a REG_CFA_DEF_CFA note, but that's OK;  A duplicate is
 	 discarded by dwarf2cfi.cc/dwarf2out.cc, and in any case would
 	 be harmless if emitted.  */
-      if (frame_pointer_needed)
+      if (frame_pointer_needed_indeed)
 	{
 	  insn = get_last_insn ();
 	  add_reg_note (insn, REG_CFA_DEF_CFA,
diff --git a/gcc/config/rs6000/rs6000-protos.h b/gcc/config/rs6000/rs6000-protos.h
index 3ea01023609..36f7f7faac3 100644
--- a/gcc/config/rs6000/rs6000-protos.h
+++ b/gcc/config/rs6000/rs6000-protos.h
@@ -324,10 +324,6 @@ extern void rs6000_target_modify_macros (bool, HOST_WIDE_INT, HOST_WIDE_INT);
 extern void (*rs6000_target_modify_macros_ptr) (bool, HOST_WIDE_INT,
 						HOST_WIDE_INT);
 
-/* Declare functions in rs6000-d.cc  */
-extern void rs6000_d_target_versions (void);
-extern void rs6000_d_register_target_info (void);
-
 #ifdef NO_DOLLAR_IN_LABEL
 const char * rs6000_xcoff_strip_dollar (const char *);
 #endif
@@ -349,4 +345,6 @@ extern rtx rs6000_gen_lvx (enum machine_mode, rtx, rtx);
 extern rtx rs6000_gen_stvx (enum machine_mode, rtx, rtx);
 
 extern void rs6000_emit_xxspltidp_v2df (rtx, long value);
+extern gimple *currently_expanding_gimple_stmt;
+extern bool rs6000_opaque_type_invalid_use_p (gimple *);
 #endif  /* rs6000-protos.h */
diff --git a/gcc/config/rs6000/rs6000.cc b/gcc/config/rs6000/rs6000.cc
index 1aadd2b96b8..19ef1e983fc 100644
--- a/gcc/config/rs6000/rs6000.cc
+++ b/gcc/config/rs6000/rs6000.cc
@@ -28287,28 +28287,6 @@ rs6000_invalid_conversion (const_tree fromtype, const_tree totype)
       if (tomode == OOmode)
 	return N_("invalid conversion to type %<__vector_pair%>");
     }
-  else if (POINTER_TYPE_P (fromtype) && POINTER_TYPE_P (totype))
-    {
-      /* We really care about the modes of the base types.  */
-      frommode = TYPE_MODE (TREE_TYPE (fromtype));
-      tomode = TYPE_MODE (TREE_TYPE (totype));
-
-      /* Do not allow conversions to/from XOmode and OOmode pointer
-	 types, except to/from void pointers.  */
-      if (frommode != tomode
-	  && frommode != VOIDmode
-	  && tomode != VOIDmode)
-	{
-	  if (frommode == XOmode)
-	    return N_("invalid conversion from type %<* __vector_quad%>");
-	  if (tomode == XOmode)
-	    return N_("invalid conversion to type %<* __vector_quad%>");
-	  if (frommode == OOmode)
-	    return N_("invalid conversion from type %<* __vector_pair%>");
-	  if (tomode == OOmode)
-	    return N_("invalid conversion to type %<* __vector_pair%>");
-	}
-    }
 
   /* Conversion allowed.  */
   return NULL;
@@ -28792,7 +28770,44 @@ constant_generates_xxspltidp (vec_const_128bit_type *vsx_const)
   return sf_value;
 }
 
-
+/* Now we have only two opaque types, they are __vector_quad and
+   __vector_pair built-in types.  They are target specific and
+   only available when MMA is supported.  With MMA supported, it
+   simply returns true, otherwise it checks if the given gimple
+   STMT is an assignment stmt and uses either of these two opaque
+   types unexpectedly, if yes, it would raise an error message
+   and returns true, otherwise it returns false.  */
+
+bool
+rs6000_opaque_type_invalid_use_p (gimple *stmt)
+{
+  if (TARGET_MMA)
+    return false;
+
+  if (stmt)
+    {
+      /* The usage of MMA opaque types is very limited for now,
+	 to check with gassign is enough so far.  */
+      if (gassign *ga = dyn_cast<gassign *> (stmt))
+	{
+	  tree lhs = gimple_assign_lhs (ga);
+	  tree type = TREE_TYPE (lhs);
+	  if (type == vector_quad_type_node)
+	    {
+	      error ("type %<__vector_quad%> requires the %qs option", "-mmma");
+	      return true;
+	    }
+	  else if (type == vector_pair_type_node)
+	    {
+	      error ("type %<__vector_pair%> requires the %qs option", "-mmma");
+	      return true;
+	    }
+	}
+    }
+
+  return false;
+}
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-rs6000.h"
diff --git a/gcc/config/rs6000/rs6000.h b/gcc/config/rs6000/rs6000.h
index bc48f450210..5c886d909aa 100644
--- a/gcc/config/rs6000/rs6000.h
+++ b/gcc/config/rs6000/rs6000.h
@@ -649,10 +649,6 @@ extern unsigned char rs6000_recip_bits[];
 #define TARGET_CPU_CPP_BUILTINS() \
   rs6000_cpu_cpp_builtins (pfile)
 
-/* Target hooks for D language.  */
-#define TARGET_D_CPU_VERSIONS rs6000_d_target_versions
-#define TARGET_D_REGISTER_CPU_TARGET_INFO rs6000_d_register_target_info
-
 /* This is used by rs6000_cpu_cpp_builtins to indicate the byte order
    we're compiling for.  Some configurations may need to override it.  */
 #define RS6000_CPU_CPP_ENDIAN_BUILTINS()	\
diff --git a/gcc/config/rs6000/rtems.h b/gcc/config/rs6000/rtems.h
index d529e22f7de..84370150dc4 100644
--- a/gcc/config/rs6000/rtems.h
+++ b/gcc/config/rs6000/rtems.h
@@ -255,7 +255,8 @@
 %{mcpu=821:  %{!Dppc*: %{!Dmpc*: -Dmpc821}  } } \
 %{mcpu=860:  %{!Dppc*: %{!Dmpc*: -Dmpc860}  } } \
 %{mcpu=8540: %{!Dppc*: %{!Dmpc*: -Dppc8540}  } } \
-%{mcpu=e6500: -D__PPC_CPU_E6500__}"
+%{mcpu=e6500: -D__PPC_CPU_E6500__} \
+%{mvrsave: -D__PPC_VRSAVE__}"
 
 #undef	ASM_SPEC
 #define	ASM_SPEC "%{!m64:%(asm_spec32)}%{m64:%(asm_spec64)} %(asm_spec_common)"
diff --git a/gcc/config/rs6000/t-rtems b/gcc/config/rs6000/t-rtems
index 4f8c147be3e..9da2da6154b 100644
--- a/gcc/config/rs6000/t-rtems
+++ b/gcc/config/rs6000/t-rtems
@@ -36,6 +36,9 @@ MULTILIB_DIRNAMES += nof
 MULTILIB_OPTIONS += mno-altivec
 MULTILIB_DIRNAMES += noaltivec
 
+MULTILIB_OPTIONS += mvrsave
+MULTILIB_DIRNAMES += vrsave
+
 MULTILIB_MATCHES  	+= ${MULTILIB_MATCHES_ENDIAN}
 MULTILIB_MATCHES	+= ${MULTILIB_MATCHES_SYSV}
 # Map 405 to 403
@@ -70,5 +73,7 @@ MULTILIB_REQUIRED += mcpu=7400/msoft-float
 MULTILIB_REQUIRED += mcpu=8540/msoft-float
 MULTILIB_REQUIRED += mcpu=860
 MULTILIB_REQUIRED += mcpu=e6500/m32
+MULTILIB_REQUIRED += mcpu=e6500/m32/mvrsave
 MULTILIB_REQUIRED += mcpu=e6500/m32/msoft-float/mno-altivec
 MULTILIB_REQUIRED += mcpu=e6500/m64
+MULTILIB_REQUIRED += mcpu=e6500/m64/mvrsave
diff --git a/gcc/config/rs6000/vector.md b/gcc/config/rs6000/vector.md
index 4d0797c48f8..9436f002f08 100644
--- a/gcc/config/rs6000/vector.md
+++ b/gcc/config/rs6000/vector.md
@@ -1535,7 +1535,7 @@
   [(match_operand:VEC_L 0 "vlogical_operand")
    (match_operand:VEC_L 1 "vlogical_operand")
    (match_operand:QI 2 "reg_or_short_operand")]
-  "TARGET_ALTIVEC"
+  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)"
 {
   rtx bitshift = operands[2];
   rtx shift;
diff --git a/gcc/config/s390/s390-d.cc b/gcc/config/s390/s390-d.cc
index 8e631859e67..0dd4b5c999b 100644
--- a/gcc/config/s390/s390-d.cc
+++ b/gcc/config/s390/s390-d.cc
@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/s390/s390-d.h b/gcc/config/s390/s390-d.h
new file mode 100644
index 00000000000..703031b3c81
--- /dev/null
+++ b/gcc/config/s390/s390-d.h
@@ -0,0 +1,24 @@
+/* Definitions for the D front end on the IBM S/390 and zSeries architectures.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* s390-d.cc routines */
+extern void s390_d_target_versions (void);
+extern void s390_d_register_target_info (void);
+
+/* Target hooks for D language.  */
+#define TARGET_D_CPU_VERSIONS s390_d_target_versions
+#define TARGET_D_REGISTER_CPU_TARGET_INFO s390_d_register_target_info
diff --git a/gcc/config/s390/s390-protos.h b/gcc/config/s390/s390-protos.h
index fd4acaae44a..7ce4c52abe9 100644
--- a/gcc/config/s390/s390-protos.h
+++ b/gcc/config/s390/s390-protos.h
@@ -174,10 +174,6 @@ extern void s390_register_target_pragmas (void);
 /* Routines for s390-c.cc */
 extern bool s390_const_operand_ok (tree, int, int, tree);
 
-/* s390-d.cc routines */
-extern void s390_d_target_versions (void);
-extern void s390_d_register_target_info (void);
-
 /* Pass management.  */
 namespace gcc { class context; }
 class rtl_opt_pass;
diff --git a/gcc/config/s390/s390.cc b/gcc/config/s390/s390.cc
index 7c3bd6cbe7f..c520dec1aff 100644
--- a/gcc/config/s390/s390.cc
+++ b/gcc/config/s390/s390.cc
@@ -13711,36 +13711,37 @@ s390_call_saved_register_used (tree call_expr)
       function_arg_info arg (TREE_TYPE (parameter), /*named=*/true);
       apply_pass_by_reference_rules (&cum_v, arg);
 
-       parm_rtx = s390_function_arg (cum, arg);
+      parm_rtx = s390_function_arg (cum, arg);
 
-       s390_function_arg_advance (cum, arg);
+      s390_function_arg_advance (cum, arg);
 
-       if (!parm_rtx)
-	 continue;
-
-       if (REG_P (parm_rtx))
-	 {
-	   for (reg = 0; reg < REG_NREGS (parm_rtx); reg++)
-	     if (!call_used_or_fixed_reg_p (reg + REGNO (parm_rtx)))
-	       return true;
-	 }
+      if (!parm_rtx)
+	continue;
 
-       if (GET_CODE (parm_rtx) == PARALLEL)
-	 {
-	   int i;
+      if (REG_P (parm_rtx))
+	{
+	  int size = s390_function_arg_size (arg.mode, arg.type);
+	  int nregs = (size + UNITS_PER_LONG - 1) / UNITS_PER_LONG;
 
-	   for (i = 0; i < XVECLEN (parm_rtx, 0); i++)
-	     {
-	       rtx r = XEXP (XVECEXP (parm_rtx, 0, i), 0);
+	  for (reg = 0; reg < nregs; reg++)
+	    if (!call_used_or_fixed_reg_p (reg + REGNO (parm_rtx)))
+	      return true;
+	}
+      else if (GET_CODE (parm_rtx) == PARALLEL)
+	{
+	  int i;
 
-	       gcc_assert (REG_P (r));
+	  for (i = 0; i < XVECLEN (parm_rtx, 0); i++)
+	    {
+	      rtx r = XEXP (XVECEXP (parm_rtx, 0, i), 0);
 
-	       for (reg = 0; reg < REG_NREGS (r); reg++)
-		 if (!call_used_or_fixed_reg_p (reg + REGNO (r)))
-		   return true;
-	     }
-	 }
+	      gcc_assert (REG_P (r));
+	      gcc_assert (REG_NREGS (r) == 1);
 
+	      if (!call_used_or_fixed_reg_p (REGNO (r)))
+		return true;
+	    }
+	}
     }
   return false;
 }
diff --git a/gcc/config/s390/s390.h b/gcc/config/s390/s390.h
index 2e1bc71e73a..1114222cd4a 100644
--- a/gcc/config/s390/s390.h
+++ b/gcc/config/s390/s390.h
@@ -247,10 +247,6 @@ enum processor_flags
 /* Target CPU builtins.  */
 #define TARGET_CPU_CPP_BUILTINS() s390_cpu_cpp_builtins (pfile)
 
-/* Target hooks for D language.  */
-#define TARGET_D_CPU_VERSIONS s390_d_target_versions
-#define TARGET_D_REGISTER_CPU_TARGET_INFO s390_d_register_target_info
-
 #ifdef DEFAULT_TARGET_64BIT
 #define TARGET_DEFAULT     (MASK_64BIT | MASK_ZARCH | MASK_HARD_DFP	\
 			    | MASK_OPT_HTM | MASK_OPT_VX)
diff --git a/gcc/config/sol2-d.cc b/gcc/config/sol2-d.cc
index 9caa82e8490..cecb49cc826 100644
--- a/gcc/config/sol2-d.cc
+++ b/gcc/config/sol2-d.cc
@@ -19,8 +19,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
-#include "memmodel.h"
-#include "tm_p.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/sparc/sparc-d.cc b/gcc/config/sparc/sparc-d.cc
index 1f3a9666b97..f8a3cf30f25 100644
--- a/gcc/config/sparc/sparc-d.cc
+++ b/gcc/config/sparc/sparc-d.cc
@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
+#include "tm_d.h"
 #include "d/d-target.h"
 #include "d/d-target-def.h"
 
diff --git a/gcc/config/sparc/sparc-d.h b/gcc/config/sparc/sparc-d.h
new file mode 100644
index 00000000000..b9d8ccf15ab
--- /dev/null
+++ b/gcc/config/sparc/sparc-d.h
@@ -0,0 +1,24 @@
+/* Definitions for the D front end on the SPARC architecture.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Routines implemented in sparc-d.cc  */
+extern void sparc_d_target_versions (void);
+extern void sparc_d_register_target_info (void);
+
+/* Target hooks for D language.  */
+#define TARGET_D_CPU_VERSIONS sparc_d_target_versions
+#define TARGET_D_REGISTER_CPU_TARGET_INFO sparc_d_register_target_info
diff --git a/gcc/config/sparc/sparc-protos.h b/gcc/config/sparc/sparc-protos.h
index f9e1c74554d..4ddd00c81e1 100644
--- a/gcc/config/sparc/sparc-protos.h
+++ b/gcc/config/sparc/sparc-protos.h
@@ -112,8 +112,4 @@ unsigned int sparc_regmode_natural_size (machine_mode);
 
 extern rtl_opt_pass *make_pass_work_around_errata (gcc::context *);
 
-/* Routines implemented in sparc-d.cc  */
-extern void sparc_d_target_versions (void);
-extern void sparc_d_register_target_info (void);
-
 #endif /* __SPARC_PROTOS_H__ */
diff --git a/gcc/config/sparc/sparc.cc b/gcc/config/sparc/sparc.cc
index aca925befe1..a47537365a8 100644
--- a/gcc/config/sparc/sparc.cc
+++ b/gcc/config/sparc/sparc.cc
@@ -6050,6 +6050,9 @@ sparc_expand_prologue (void)
 	}
 
       RTX_FRAME_RELATED_P (insn) = 1;
+
+      /* Ensure no memory access is done before the frame is established.  */
+      emit_insn (gen_frame_blockage ());
     }
   else
     {
@@ -6064,13 +6067,7 @@ sparc_expand_prologue (void)
 	  /* %sp is not the CFA register anymore.  */
 	  emit_insn (gen_stack_pointer_inc (GEN_INT (4096 - size)));
 
-	  /* Make sure no %fp-based store is issued until after the frame is
-	     established.  The offset between the frame pointer and the stack
-	     pointer is calculated relative to the value of the stack pointer
-	     at the end of the function prologue, and moving instructions that
-	     access the stack via the frame pointer between the instructions
-	     that decrement the stack pointer could result in accessing the
-	     register window save area, which is volatile.  */
+	  /* Likewise.  */
 	  emit_insn (gen_frame_blockage ());
 	}
       else
@@ -6166,8 +6163,8 @@ sparc_flat_expand_prologue (void)
 	}
       RTX_FRAME_RELATED_P (insn) = 1;
 
-      /* Ensure nothing is scheduled until after the frame is established.  */
-      emit_insn (gen_blockage ());
+      /* Ensure no memory access is done before the frame is established.  */
+      emit_insn (gen_frame_blockage ());
 
       if (frame_pointer_needed)
 	{
@@ -6254,6 +6251,9 @@ sparc_expand_epilogue (bool for_eh)
     ; /* do nothing.  */
   else if (sparc_leaf_function_p)
     {
+      /* Ensure no memory access is done after the frame is destroyed.  */
+      emit_insn (gen_frame_blockage ());
+
       if (size <= 4096)
 	emit_insn (gen_stack_pointer_inc (GEN_INT (size)));
       else if (size <= 8192)
@@ -6304,15 +6304,15 @@ sparc_flat_expand_epilogue (bool for_eh)
     ; /* do nothing.  */
   else if (frame_pointer_needed)
     {
-      /* Make sure the frame is destroyed after everything else is done.  */
-      emit_insn (gen_blockage ());
+      /* Ensure no memory access is done after the frame is destroyed.  */
+      emit_insn (gen_frame_blockage ());
 
       emit_move_insn (stack_pointer_rtx, gen_rtx_REG (Pmode, 1));
     }
   else
     {
       /* Likewise.  */
-      emit_insn (gen_blockage ());
+      emit_insn (gen_frame_blockage ());
 
       if (size <= 4096)
 	emit_insn (gen_stack_pointer_inc (GEN_INT (size)));
diff --git a/gcc/config/sparc/sparc.h b/gcc/config/sparc/sparc.h
index 2e17fca197a..91917c3eaad 100644
--- a/gcc/config/sparc/sparc.h
+++ b/gcc/config/sparc/sparc.h
@@ -27,10 +27,6 @@ along with GCC; see the file COPYING3.  If not see
 
 #define TARGET_CPU_CPP_BUILTINS() sparc_target_macros ()
 
-/* Target hooks for D language.  */
-#define TARGET_D_CPU_VERSIONS sparc_d_target_versions
-#define TARGET_D_REGISTER_CPU_TARGET_INFO sparc_d_register_target_info
-
 /* Specify this in a cover file to provide bi-architecture (32/64) support.  */
 /* #define SPARC_BI_ARCH */
 
diff --git a/gcc/configure b/gcc/configure
index 5ce0557719a..c749ace011d 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -13008,7 +13008,6 @@ fi
 
 tm_file="${tm_file} defaults.h"
 tm_p_file="${tm_p_file} tm-preds.h"
-tm_d_file="${tm_d_file} defaults.h"
 host_xm_file="auto-host.h ansidecl.h ${host_xm_file}"
 build_xm_file="${build_auto} ansidecl.h ${build_xm_file}"
 # We don't want ansidecl.h in target files, write code there in ISO/GNU C.
@@ -13403,13 +13402,9 @@ for f in $tm_p_file; do
 done
 
 tm_d_file_list=
-tm_d_include_list="options.h insn-constants.h"
+tm_d_include_list=
 for f in $tm_d_file; do
   case $f in
-    defaults.h )
-       tm_d_file_list="${tm_d_file_list} \$(srcdir)/$f"
-       tm_d_include_list="${tm_d_include_list} $f"
-       ;;
     * )
        tm_d_file_list="${tm_d_file_list} \$(srcdir)/config/$f"
        tm_d_include_list="${tm_d_include_list} config/$f"
@@ -19673,7 +19668,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 19676 "configure"
+#line 19671 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -19779,7 +19774,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 19782 "configure"
+#line 19777 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 23bee7010a3..992a50e7b20 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -2113,7 +2113,6 @@ AC_SUBST(HAVE_AUTO_BUILD)
 
 tm_file="${tm_file} defaults.h"
 tm_p_file="${tm_p_file} tm-preds.h"
-tm_d_file="${tm_d_file} defaults.h"
 host_xm_file="auto-host.h ansidecl.h ${host_xm_file}"
 build_xm_file="${build_auto} ansidecl.h ${build_xm_file}"
 # We don't want ansidecl.h in target files, write code there in ISO/GNU C.
@@ -2357,13 +2356,9 @@ for f in $tm_p_file; do
 done
 
 tm_d_file_list=
-tm_d_include_list="options.h insn-constants.h"
+tm_d_include_list=
 for f in $tm_d_file; do
   case $f in
-    defaults.h )
-       tm_d_file_list="${tm_d_file_list} \$(srcdir)/$f"
-       tm_d_include_list="${tm_d_include_list} $f"
-       ;;
     * )
        tm_d_file_list="${tm_d_file_list} \$(srcdir)/config/$f"
        tm_d_include_list="${tm_d_include_list} config/$f"
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index dc03a2518f3..4d1ac08b8c4 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,149 @@
+2023-01-04  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2023-01-04  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/108282
+	* decl2.cc (mark_single_function): Ignore mark_used failure
+	only in a non-SFINAE context rather than in a SFINAE one.
+
+2022-12-19  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-12-15  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/100295
+	PR c++/107579
+	* pt.cc (el_data::skip_unevaluated_operands): New data member.
+	(extract_locals_r): If skip_unevaluated_operands is true,
+	don't walk into unevaluated contexts.
+	(extract_local_specs): Walk the pattern twice, first with
+	skip_unevaluated_operands true followed by it set to false.
+
+2022-12-19  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-12-15  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/108104
+	* pt.cc (unify) <default>: Relax assert to accept any
+	CONSTRUCTOR parm, not just COMPOUND_LITERAL_P one.
+
+2022-12-19  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-12-04  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/107417
+	* pt.cc (for_each_template_parm_r) <case REQUIRES_EXPR>: Move
+	walking of the TREE_TYPE of each parameter to ...
+	* tree.cc (cp_walk_subtrees) <case REQUIRES_EXPR>: ... here.
+
+2022-12-19  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-12-03  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/103081
+	* pt.cc (tsubst_copy) <case CONST_DECL>: Generalize
+	early exit test for namespace-scope decls to check dependence of
+	the enclosing scope instead.  Remove dead early exit test.
+
+2022-12-19  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-11-30  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/107542
+	* typeck.cc (cp_build_binary_op): In the SPACESHIP_EXPR case,
+	handle an error_mark_node result type.
+
+2022-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-15  Jakub Jelinek  <jakub@redhat.com>
+
+	* cp-tree.h (next_common_initial_seqence): Rename to ...
+	(next_common_initial_sequence): ... this.
+	* typeck.cc (next_common_initial_seqence): Rename to ...
+	(next_common_initial_sequence): ... this.
+	(layout_compatible_type_p): Call next_common_initial_sequence
+	rather than next_common_initial_seqence.
+	* semantics.cc (is_corresponding_member_aggr): Likewise.
+
+2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/104066
+	* decl.cc (grokdeclarator): Check funcdecl_p before complaining
+	about constinit.
+
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-10-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/105774
+	* constexpr.cc (cxx_eval_increment_expression): For signed types
+	that promote to int, evaluate PLUS_EXPR or MINUS_EXPR in int type.
+
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/106829
+	* semantics.cc (finish_omp_target_clauses): If current_function_decl
+	isn't a nonstatic member function, don't set data.current_object to
+	non-NULL.
+
+2022-10-13  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-10-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/106925
+	* except.cc (maybe_splice_retval_cleanup): Check current_function_decl.
+	Make the bool const.
+
+2022-09-29  Jason Merrill  <jason@redhat.com>
+
+	* class.cc (check_methods): Call constraints_satisfied_p.
+
+2022-09-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/93259
+	* pt.cc (type_dependent_expression_p): Treat a compound
+	literal of array-of-unknown-bound type like a variable.
+
+2022-09-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106893
+	PR c++/90451
+	* decl.cc (cp_finish_decl): Call mark_single_function.
+
+2022-08-30  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-08-30  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/106759
+	* cp-objcp-common.cc (names_builtin_p): Handle RID_IS_NOTHROW_ASSIGNABLE
+	and RID_IS_NOTHROW_CONSTRUCTIBLE.
+
+2022-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-08-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* typeck.cc (cp_build_modify_expr): Implement
+	P2327R1 - De-deprecating volatile compound operations.  Don't warn
+	for |=, &= or ^= with volatile lhs.
+	* expr.cc (mark_use) <case MODIFY_EXPR>: Adjust warning wording,
+	leave out simple.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/gcc/cp/class.cc b/gcc/cp/class.cc
index bfda0065bf4..b9e0a77f52b 100644
--- a/gcc/cp/class.cc
+++ b/gcc/cp/class.cc
@@ -4780,8 +4780,9 @@ check_methods (tree t)
 
   /* Check whether the eligible special member functions (P0848) are
      user-provided.  add_method arranged that the CLASSTYPE_MEMBER_VEC only
-     has the eligible ones; TYPE_FIELDS also contains ineligible overloads,
-     which is why this needs to be separate from the loop above.  */
+     has the eligible ones, unless none are eligible; TYPE_FIELDS also contains
+     ineligible overloads, which is why this needs to be separate from the loop
+     above.  */
 
   if (tree dtor = CLASSTYPE_DESTRUCTOR (t))
     {
@@ -4804,6 +4805,10 @@ check_methods (tree t)
     {
       if (!user_provided_p (fn))
 	/* Might be trivial.  */;
+      else if (TREE_CODE (fn) == TEMPLATE_DECL)
+	/* Templates are never special members.  */;
+      else if (!constraints_satisfied_p (fn))
+	/* Not eligible.  */;
       else if (copy_fn_p (fn))
 	TYPE_HAS_COMPLEX_COPY_CTOR (t) = true;
       else if (move_fn_p (fn))
@@ -4814,6 +4819,10 @@ check_methods (tree t)
     {
       if (!user_provided_p (fn))
 	/* Might be trivial.  */;
+      else if (TREE_CODE (fn) == TEMPLATE_DECL)
+	/* Templates are never special members.  */;
+      else if (!constraints_satisfied_p (fn))
+	/* Not eligible.  */;
       else if (copy_fn_p (fn))
 	TYPE_HAS_COMPLEX_COPY_ASSIGN (t) = true;
       else if (move_fn_p (fn))
diff --git a/gcc/cp/constexpr.cc b/gcc/cp/constexpr.cc
index 28f8785dea3..3566f6ef724 100644
--- a/gcc/cp/constexpr.cc
+++ b/gcc/cp/constexpr.cc
@@ -6040,6 +6040,18 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,
 	offset = fold_build1 (NEGATE_EXPR, TREE_TYPE (offset), offset);
       mod = fold_build2 (POINTER_PLUS_EXPR, type, val, offset);
     }
+  else if (c_promoting_integer_type_p (type)
+	   && !TYPE_UNSIGNED (type)
+	   && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))
+    {
+      offset = fold_convert (integer_type_node, offset);
+      mod = fold_convert (integer_type_node, val);
+      tree t = fold_build2 (inc ? PLUS_EXPR : MINUS_EXPR, integer_type_node,
+			    mod, offset);
+      mod = fold_convert (type, t);
+      if (TREE_OVERFLOW_P (mod) && !TREE_OVERFLOW_P (t))
+	TREE_OVERFLOW (mod) = false;
+    }
   else
     mod = fold_build2 (inc ? PLUS_EXPR : MINUS_EXPR, type, val, offset);
   if (!ptr)
diff --git a/gcc/cp/cp-objcp-common.cc b/gcc/cp/cp-objcp-common.cc
index 0b70d5567e4..f40fd588176 100644
--- a/gcc/cp/cp-objcp-common.cc
+++ b/gcc/cp/cp-objcp-common.cc
@@ -460,6 +460,8 @@ names_builtin_p (const char *name)
     case RID_IS_UNION:
     case RID_IS_ASSIGNABLE:
     case RID_IS_CONSTRUCTIBLE:
+    case RID_IS_NOTHROW_ASSIGNABLE:
+    case RID_IS_NOTHROW_CONSTRUCTIBLE:
     case RID_UNDERLYING_TYPE:
       return true;
     default:
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index 72f4398a8f9..cb434af789d 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -7957,7 +7957,7 @@ extern bool comp_except_specs			(const_tree, const_tree, int);
 extern bool comptypes				(tree, tree, int);
 extern bool same_type_ignoring_top_level_qualifiers_p (tree, tree);
 extern bool similar_type_p			(tree, tree);
-extern bool next_common_initial_seqence		(tree &, tree &);
+extern bool next_common_initial_sequence	(tree &, tree &);
 extern bool layout_compatible_type_p		(tree, tree);
 extern bool compparms				(const_tree, const_tree);
 extern int comp_cv_qualification		(const_tree, const_tree);
diff --git a/gcc/cp/decl.cc b/gcc/cp/decl.cc
index 9f78c500a15..ed47d262078 100644
--- a/gcc/cp/decl.cc
+++ b/gcc/cp/decl.cc
@@ -8137,6 +8137,9 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
 	    d_init = build_x_compound_expr_from_list (d_init, ELK_INIT,
 						      tf_warning_or_error);
 	  d_init = resolve_nondeduced_context (d_init, tf_warning_or_error);
+	  /* Force auto deduction now.  Use tf_none to avoid redundant warnings
+	     on deprecated-14.C.  */
+	  mark_single_function (d_init, tf_none);
 	}
       enum auto_deduction_context adc = adc_variable_type;
       if (VAR_P (decl) && DECL_DECOMPOSITION_P (decl))
@@ -12960,7 +12963,7 @@ grokdeclarator (const cp_declarator *declarator,
 			  "an array", name);
 		return error_mark_node;
 	      }
-	    if (constinit_p)
+	    if (constinit_p && funcdecl_p)
 	      {
 		error_at (declspecs->locations[ds_constinit],
 			  "%<constinit%> on function return type is not "
diff --git a/gcc/cp/decl2.cc b/gcc/cp/decl2.cc
index d7e9980ff1e..37985a37df6 100644
--- a/gcc/cp/decl2.cc
+++ b/gcc/cp/decl2.cc
@@ -5779,7 +5779,7 @@ mark_single_function (tree expr, tsubst_flags_t complain)
 
   if (is_overloaded_fn (expr) == 1
       && !mark_used (expr, complain)
-      && (complain & tf_error))
+      && !(complain & tf_error))
     return false;
   return true;
 }
diff --git a/gcc/cp/except.cc b/gcc/cp/except.cc
index da0a65c613d..58d8772fc95 100644
--- a/gcc/cp/except.cc
+++ b/gcc/cp/except.cc
@@ -1322,9 +1322,12 @@ maybe_splice_retval_cleanup (tree compound_stmt)
 {
   /* If we need a cleanup for the return value, add it in at the same level as
      pushdecl_outermost_localscope.  And also in try blocks.  */
-  bool function_body
+  const bool function_body
     = (current_binding_level->level_chain
-       && current_binding_level->level_chain->kind == sk_function_parms);
+       && current_binding_level->level_chain->kind == sk_function_parms
+      /* When we're processing a default argument, c_f_d may not have been
+	 set.  */
+       && current_function_decl);
 
   if ((function_body || current_binding_level->kind == sk_try)
       && !DECL_CONSTRUCTOR_P (current_function_decl)
diff --git a/gcc/cp/expr.cc b/gcc/cp/expr.cc
index 56fc11f425b..f3e155b7ba3 100644
--- a/gcc/cp/expr.cc
+++ b/gcc/cp/expr.cc
@@ -220,7 +220,7 @@ mark_use (tree expr, bool rvalue_p, bool read_p,
     case MODIFY_EXPR:
 	{
 	  tree lhs = TREE_OPERAND (expr, 0);
-	  /* [expr.ass] "A simple assignment whose left operand is of
+	  /* [expr.ass] "An assignment whose left operand is of
 	     a volatile-qualified type is deprecated unless the assignment
 	     is either a discarded-value expression or appears in an
 	     unevaluated context."  */
@@ -230,7 +230,7 @@ mark_use (tree expr, bool rvalue_p, bool read_p,
 	      && !TREE_THIS_VOLATILE (expr))
 	    {
 	      if (warning_at (location_of (expr), OPT_Wvolatile,
-			      "using value of simple assignment with "
+			      "using value of assignment with "
 			      "%<volatile%>-qualified left operand is "
 			      "deprecated"))
 		/* Make sure not to warn about this assignment again.  */
diff --git a/gcc/cp/pt.cc b/gcc/cp/pt.cc
index bef31416fb7..735c106c7d6 100644
--- a/gcc/cp/pt.cc
+++ b/gcc/cp/pt.cc
@@ -10648,21 +10648,6 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)
 	return error_mark_node;
       break;
 
-    case REQUIRES_EXPR:
-      {
-	if (!fn)
-	  return error_mark_node;
-
-	/* Recursively walk the type of each constraint variable.  */
-	tree p = TREE_OPERAND (t, 0);
-	while (p)
-	  {
-	    WALK_SUBTREE (TREE_TYPE (p));
-	    p = TREE_CHAIN (p);
-	  }
-      }
-      break;
-
     default:
       break;
     }
@@ -13006,17 +12991,26 @@ public:
   /* List of local_specializations used within the pattern.  */
   tree extra;
   tsubst_flags_t complain;
+  /* True iff we don't want to walk into unevaluated contexts.  */
+  bool skip_unevaluated_operands = false;
 
   el_data (tsubst_flags_t c)
     : extra (NULL_TREE), complain (c) {}
 };
 static tree
-extract_locals_r (tree *tp, int */*walk_subtrees*/, void *data_)
+extract_locals_r (tree *tp, int *walk_subtrees, void *data_)
 {
   el_data &data = *reinterpret_cast<el_data*>(data_);
   tree *extra = &data.extra;
   tsubst_flags_t complain = data.complain;
 
+  if (data.skip_unevaluated_operands
+      && unevaluated_p (TREE_CODE (*tp)))
+    {
+      *walk_subtrees = 0;
+      return NULL_TREE;
+    }
+
   if (TYPE_P (*tp) && typedef_variant_p (*tp))
     /* Remember local typedefs (85214).  */
     tp = &TYPE_NAME (*tp);
@@ -13108,6 +13102,14 @@ static tree
 extract_local_specs (tree pattern, tsubst_flags_t complain)
 {
   el_data data (complain);
+  /* Walk the pattern twice, ignoring unevaluated operands the first time
+     around, so that if a local specialization appears in both an evaluated
+     and unevaluated context we prefer to process it in the evaluated context
+     (since e.g. process_outer_var_ref is a no-op inside an unevaluated
+     context).  */
+  data.skip_unevaluated_operands = true;
+  cp_walk_tree (&pattern, extract_locals_r, &data, &data.visited);
+  data.skip_unevaluated_operands = false;
   cp_walk_tree (&pattern, extract_locals_r, &data, &data.visited);
   return data.extra;
 }
@@ -16967,13 +16969,8 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 
 	if (DECL_TEMPLATE_PARM_P (t))
 	  return tsubst_copy (DECL_INITIAL (t), args, complain, in_decl);
-	/* There is no need to substitute into namespace-scope
-	   enumerators.  */
-	if (DECL_NAMESPACE_SCOPE_P (t))
+	if (!uses_template_parms (DECL_CONTEXT (t)))
 	  return t;
-	/* If ARGS is NULL, then T is known to be non-dependent.  */
-	if (args == NULL_TREE)
-	  return scalar_constant_value (t);
 
 	if (tree ref = maybe_dependent_member_ref (t, args, complain, in_decl))
 	  return ref;
@@ -24830,7 +24827,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,
       if (is_overloaded_fn (parm) || type_unknown_p (parm))
 	return unify_success (explain_p);
       gcc_assert (EXPR_P (parm)
-		  || COMPOUND_LITERAL_P (parm)
+		  || TREE_CODE (parm) == CONSTRUCTOR
 		  || TREE_CODE (parm) == TRAIT_EXPR);
     expr:
       /* We must be looking at an expression.  This can happen with
@@ -27952,11 +27949,11 @@ type_dependent_expression_p (tree expression)
      If the array has no length and has an initializer, it must be that
      we couldn't determine its length in cp_complete_array_type because
      it is dependent.  */
-  if (VAR_P (expression)
+  if (((VAR_P (expression) && DECL_INITIAL (expression))
+       || COMPOUND_LITERAL_P (expression))
       && TREE_TYPE (expression) != NULL_TREE
       && TREE_CODE (TREE_TYPE (expression)) == ARRAY_TYPE
-      && !TYPE_DOMAIN (TREE_TYPE (expression))
-      && DECL_INITIAL (expression))
+      && !TYPE_DOMAIN (TREE_TYPE (expression)))
    return true;
 
   /* Pull a FUNCTION_DECL out of a BASELINK if we can.  */
diff --git a/gcc/cp/semantics.cc b/gcc/cp/semantics.cc
index 972a1966f69..de755904d50 100644
--- a/gcc/cp/semantics.cc
+++ b/gcc/cp/semantics.cc
@@ -9482,16 +9482,15 @@ finish_omp_target_clauses (location_t loc, tree body, tree *clauses_ptr)
 {
   omp_target_walk_data data;
   data.this_expr_accessed = false;
+  data.current_object = NULL_TREE;
 
-  tree ct = current_nonlambda_class_type ();
-  if (ct)
-    {
-      tree object = maybe_dummy_object (ct, NULL);
-      object = maybe_resolve_dummy (object, true);
-      data.current_object = object;
-    }
-  else
-    data.current_object = NULL_TREE;
+  if (DECL_NONSTATIC_MEMBER_P (current_function_decl) && current_class_ptr)
+    if (tree ct = current_nonlambda_class_type ())
+      {
+	tree object = maybe_dummy_object (ct, NULL);
+	object = maybe_resolve_dummy (object, true);
+	data.current_object = object;
+      }
 
   if (DECL_LAMBDA_FUNCTION_P (current_function_decl))
     {
@@ -11601,7 +11600,7 @@ is_corresponding_member_aggr (location_t loc, tree basetype1, tree membertype1,
   tree ret = boolean_false_node;
   while (1)
     {
-      bool r = next_common_initial_seqence (field1, field2);
+      bool r = next_common_initial_sequence (field1, field2);
       if (field1 == NULL_TREE || field2 == NULL_TREE)
 	break;
       if (r
diff --git a/gcc/cp/tree.cc b/gcc/cp/tree.cc
index 3b37567cbd7..bc521f8ae9c 100644
--- a/gcc/cp/tree.cc
+++ b/gcc/cp/tree.cc
@@ -5488,15 +5488,18 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,
       break;
  
     case REQUIRES_EXPR:
-      // Only recurse through the nested expression. Do not
-      // walk the parameter list. Doing so causes false
-      // positives in the pack expansion checker since the
-      // requires parameters are introduced as pack expansions.
-      ++cp_unevaluated_operand;
-      result = cp_walk_tree (&REQUIRES_EXPR_REQS (*tp), func, data, pset);
-      --cp_unevaluated_operand;
-      *walk_subtrees_p = 0;
-      break;
+      {
+	cp_unevaluated u;
+	for (tree parm = REQUIRES_EXPR_PARMS (*tp); parm; parm = DECL_CHAIN (parm))
+	  /* Walk the types of each parameter, but not the parameter itself,
+	     since doing so would cause false positives in the unexpanded pack
+	     checker if the requires-expr introduces a function parameter pack,
+	     e.g. requires (Ts... ts) { }.   */
+	  WALK_SUBTREE (TREE_TYPE (parm));
+	WALK_SUBTREE (REQUIRES_EXPR_REQS (*tp));
+	*walk_subtrees_p = 0;
+	break;
+      }
 
     case DECL_EXPR:
       /* User variables should be mentioned in BIND_EXPR_VARS
diff --git a/gcc/cp/typeck.cc b/gcc/cp/typeck.cc
index ceb80d9744f..c36508b8cc5 100644
--- a/gcc/cp/typeck.cc
+++ b/gcc/cp/typeck.cc
@@ -1627,7 +1627,7 @@ similar_type_p (tree type1, tree type2)
    the common initial sequence.  */
 
 bool
-next_common_initial_seqence (tree &memb1, tree &memb2)
+next_common_initial_sequence (tree &memb1, tree &memb2)
 {
   while (memb1)
     {
@@ -1719,7 +1719,7 @@ layout_compatible_type_p (tree type1, tree type2)
 	{
 	  while (1)
 	    {
-	      if (!next_common_initial_seqence (field1, field2))
+	      if (!next_common_initial_sequence (field1, field2))
 		return false;
 	      if (field1 == NULL_TREE)
 		return true;
@@ -5921,8 +5921,9 @@ cp_build_binary_op (const op_location_t &location,
       tree_code orig_code0 = TREE_CODE (orig_type0);
       tree orig_type1 = TREE_TYPE (orig_op1);
       tree_code orig_code1 = TREE_CODE (orig_type1);
-      if (!result_type)
-	/* Nope.  */;
+      if (!result_type || result_type == error_mark_node)
+	/* Nope.  */
+	result_type = NULL_TREE;
       else if ((orig_code0 == BOOLEAN_TYPE) != (orig_code1 == BOOLEAN_TYPE))
 	/* "If one of the operands is of type bool and the other is not, the
 	   program is ill-formed."  */
@@ -9126,10 +9127,14 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,
 
 	  /* An expression of the form E1 op= E2.  [expr.ass] says:
 	     "Such expressions are deprecated if E1 has volatile-qualified
-	     type."  We warn here rather than in cp_genericize_r because
+	     type and op is not one of the bitwise operators |, &, ^."
+	     We warn here rather than in cp_genericize_r because
 	     for compound assignments we are supposed to warn even if the
 	     assignment is a discarded-value expression.  */
-	  if (TREE_THIS_VOLATILE (lhs) || CP_TYPE_VOLATILE_P (lhstype))
+	  if (modifycode != BIT_AND_EXPR
+	      && modifycode != BIT_IOR_EXPR
+	      && modifycode != BIT_XOR_EXPR
+	      && (TREE_THIS_VOLATILE (lhs) || CP_TYPE_VOLATILE_P (lhstype)))
 	    warning_at (loc, OPT_Wvolatile,
 			"compound assignment with %<volatile%>-qualified left "
 			"operand is deprecated");
diff --git a/gcc/cselib.cc b/gcc/cselib.cc
index 6769beeeaf8..6a5609786fa 100644
--- a/gcc/cselib.cc
+++ b/gcc/cselib.cc
@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dumpfile.h"
 #include "cselib.h"
 #include "function-abi.h"
+#include "alias.h"
 
 /* A list of cselib_val structures.  */
 struct elt_list
@@ -1157,6 +1158,75 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)
   return 1;
 }
 
+/* Wrapper for rtx_equal_for_cselib_p to determine whether a SET is
+   truly redundant, taking into account aliasing information.  */
+bool
+cselib_redundant_set_p (rtx set)
+{
+  gcc_assert (GET_CODE (set) == SET);
+  rtx dest = SET_DEST (set);
+  if (cselib_reg_set_mode (dest) != GET_MODE (dest))
+    return false;
+
+  if (!rtx_equal_for_cselib_p (dest, SET_SRC (set)))
+    return false;
+
+  while (GET_CODE (dest) == SUBREG
+	 || GET_CODE (dest) == ZERO_EXTRACT
+	 || GET_CODE (dest) == STRICT_LOW_PART)
+    dest = XEXP (dest, 0);
+
+  if (!flag_strict_aliasing || !MEM_P (dest))
+    return true;
+
+  /* For a store we need to check that suppressing it will not change
+     the effective alias set.  */
+  rtx dest_addr = XEXP (dest, 0);
+
+  /* Lookup the equivalents to the original dest (rather than just the
+     MEM).  */
+  cselib_val *src_val = cselib_lookup (SET_DEST (set),
+				       GET_MODE (SET_DEST (set)),
+				       0, VOIDmode);
+
+  if (src_val)
+    {
+      /* Walk the list of source equivalents to find the MEM accessing
+	 the same location.  */
+      for (elt_loc_list *l = src_val->locs; l; l = l->next)
+	{
+	  rtx src_equiv = l->loc;
+	  while (GET_CODE (src_equiv) == SUBREG
+		 || GET_CODE (src_equiv) == ZERO_EXTRACT
+		 || GET_CODE (src_equiv) == STRICT_LOW_PART)
+	    src_equiv = XEXP (src_equiv, 0);
+
+	  if (MEM_P (src_equiv))
+	    {
+	      /* Match the MEMs by comparing the addresses.  We can
+		 only remove the later store if the earlier aliases at
+		 least all the accesses of the later one.  */
+	      if (rtx_equal_for_cselib_1 (dest_addr, XEXP (src_equiv, 0),
+					  GET_MODE (dest), 0))
+		return mems_same_for_tbaa_p (src_equiv, dest);
+	    }
+	}
+    }
+
+  /* We failed to find a recorded value in the cselib history, so try
+     the source of this set; this catches cases such as *p = *q when p
+     and q have the same value.  */
+  rtx src = SET_SRC (set);
+  while (GET_CODE (src) == SUBREG)
+    src = XEXP (src, 0);
+
+  if (MEM_P (src)
+      && rtx_equal_for_cselib_1 (dest_addr, XEXP (src, 0), GET_MODE (dest), 0))
+    return mems_same_for_tbaa_p (src, dest);
+
+  return false;
+}
+
 /* Helper function for cselib_hash_rtx.  Arguments like for cselib_hash_rtx,
    except that it hashes (plus:P x c).  */
 
diff --git a/gcc/cselib.h b/gcc/cselib.h
index 9ae65e6459e..b0905053ea5 100644
--- a/gcc/cselib.h
+++ b/gcc/cselib.h
@@ -83,6 +83,7 @@ extern void cselib_process_insn (rtx_insn *);
 extern bool fp_setter_insn (rtx_insn *);
 extern machine_mode cselib_reg_set_mode (const_rtx);
 extern int rtx_equal_for_cselib_1 (rtx, rtx, machine_mode, int);
+extern bool cselib_redundant_set_p (rtx);
 extern int references_value_p (const_rtx, int);
 extern rtx cselib_expand_value_rtx (rtx, bitmap, int);
 typedef rtx (*cselib_expand_callback)(rtx, bitmap, int, void *);
diff --git a/gcc/d/ChangeLog b/gcc/d/ChangeLog
index b2d2d964cc4..d7e7254de3e 100644
--- a/gcc/d/ChangeLog
+++ b/gcc/d/ChangeLog
@@ -1,3 +1,40 @@
+2022-12-12  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-12-12  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108055
+	* decl.cc (function_defined_in_root_p): Check all enclosing template
+	instances for definition in a root module.
+	(function_needs_inline_definition_p): Replace call to
+	function_defined_in_root_p with test for outer module `isRoot'.
+
+2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* imports.cc (ImportVisitor::visit (OverloadSet *)): Remove "final"
+	and "override" from visitor method.
+
+2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108050
+	* decl.cc (DeclVisitor::visit (Import *)): Handle build_import_decl
+	returning a TREE_LIST.
+	* imports.cc (ImportVisitor::visit (OverloadSet *)): New override.
+
+2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/107592
+	* toir.cc (IRVisitor::push_unrolled_continue_label): New method.
+	(IRVisitor::pop_unrolled_continue_label): New method.
+	(IRVisitor::visit (UnrolledLoopStatement *)): Use them instead of
+	push_continue_label and pop_continue_label.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/gcc/d/decl.cc b/gcc/d/decl.cc
index 0f1dad95ba3..11fd7f6c81f 100644
--- a/gcc/d/decl.cc
+++ b/gcc/d/decl.cc
@@ -197,8 +197,16 @@ public:
 	    tree name = (alias != NULL)
 	      ? get_identifier (alias->toChars ()) : NULL_TREE;
 
-	    debug_hooks->imported_module_or_decl (decl, name, context,
-						  false, false);
+	    if (TREE_CODE (decl) != TREE_LIST)
+	      debug_hooks->imported_module_or_decl (decl, name, context,
+						    false, false);
+	    else
+	      {
+		/* Overload sets return a list of imported decls.  */
+		for (; decl != NULL_TREE; decl = TREE_CHAIN (decl))
+		  debug_hooks->imported_module_or_decl (TREE_VALUE (decl), name,
+							context, false, false);
+	      }
 	  }
       }
     else
@@ -1015,7 +1023,8 @@ build_decl_tree (Dsymbol *d)
   input_location = saved_location;
 }
 
-/* Returns true if function FD is defined or instantiated in a root module.  */
+/* Returns true if function FD, or any lexically enclosing scope function of FD
+   is defined or instantiated in a root module.  */
 
 static bool
 function_defined_in_root_p (FuncDeclaration *fd)
@@ -1024,9 +1033,11 @@ function_defined_in_root_p (FuncDeclaration *fd)
   if (md && md->isRoot ())
     return true;
 
-  TemplateInstance *ti = fd->isInstantiated ();
-  if (ti && ti->minst && ti->minst->isRoot ())
-    return true;
+  for (TemplateInstance *ti = fd->isInstantiated (); ti != NULL; ti = ti->tinst)
+    {
+      if (ti->minst && ti->minst->isRoot ())
+	return true;
+    }
 
   return false;
 }
@@ -1054,7 +1065,8 @@ function_needs_inline_definition_p (FuncDeclaration *fd)
 
   /* Check whether function will be regularly defined later in the current
      translation unit.  */
-  if (function_defined_in_root_p (fd))
+  Module *md = fd->getModule ();
+  if (md && md->isRoot ())
     return false;
 
   /* Non-inlineable functions are always external.  */
diff --git a/gcc/d/imports.cc b/gcc/d/imports.cc
index 6747ee5df27..dfda2401ee8 100644
--- a/gcc/d/imports.cc
+++ b/gcc/d/imports.cc
@@ -160,6 +160,20 @@ public:
       d->aliassym->accept (this);
   }
 
+  /* Build IMPORTED_DECLs for all overloads in a set.  */
+  void visit (OverloadSet *d)
+  {
+    vec<tree, va_gc> *tset = NULL;
+
+    vec_alloc (tset, d->a.length);
+
+    for (size_t i = 0; i < d->a.length; i++)
+      vec_safe_push (tset, build_import_decl (d->a[i]));
+
+    this->result_ = build_tree_list_vec (tset);
+    tset->truncate (0);
+  }
+
   /* Function aliases are the same as alias symbols.  */
   void visit (FuncAliasDeclaration *d)
   {
diff --git a/gcc/d/toir.cc b/gcc/d/toir.cc
index bf81dc9ad96..d25cef12f91 100644
--- a/gcc/d/toir.cc
+++ b/gcc/d/toir.cc
@@ -529,6 +529,28 @@ public:
     this->do_label (label);
   }
 
+  /* Generate and set a new continue label for the current unrolled loop.  */
+
+  void push_unrolled_continue_label (UnrolledLoopStatement *s)
+  {
+    this->push_continue_label (s);
+  }
+
+  /* Finish with the continue label for the unrolled loop.  */
+
+  void pop_unrolled_continue_label (UnrolledLoopStatement *s)
+  {
+    Statement *stmt = s->getRelatedLabeled ();
+    d_label_entry *ent = d_function_chain->labels->get (stmt);
+    gcc_assert (ent != NULL && ent->bc_label == true);
+
+    this->pop_continue_label (TREE_VEC_ELT (ent->label, bc_continue));
+
+    /* Remove the continue label from the label htab, as a new one must be
+       inserted at the end of every unrolled loop.  */
+    ent->label = TREE_VEC_ELT (ent->label, bc_break);
+  }
+
   /* Visitor interfaces.  */
 
 
@@ -1089,9 +1111,9 @@ public:
 
 	if (statement != NULL)
 	  {
-	    tree lcontinue = this->push_continue_label (statement);
+	    this->push_unrolled_continue_label (s);
 	    this->build_stmt (statement);
-	    this->pop_continue_label (lcontinue);
+	    this->pop_unrolled_continue_label (s);
 	  }
       }
 
diff --git a/gcc/doc/cppopts.texi b/gcc/doc/cppopts.texi
index 75c56a368ca..c0a92b37018 100644
--- a/gcc/doc/cppopts.texi
+++ b/gcc/doc/cppopts.texi
@@ -318,9 +318,10 @@ supported by the system's @code{iconv} library routine.
 @opindex fwide-exec-charset
 @cindex character set, wide execution
 Set the wide execution character set, used for wide string and
-character constants.  The default is UTF-32 or UTF-16, whichever
-corresponds to the width of @code{wchar_t}.  As with
-@option{-fexec-charset}, @var{charset} can be any encoding supported
+character constants.  The default is one of UTF-32BE, UTF-32LE, UTF-16BE,
+or UTF-16LE, whichever corresponds to the width of @code{wchar_t} and the
+big-endian or little-endian byte order being used for code generation.  As
+with @option{-fexec-charset}, @var{charset} can be any encoding supported
 by the system's @code{iconv} library routine; however, you will have
 problems with encodings that do not fit exactly in @code{wchar_t}.
 
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 84e6f6694ab..e705e94603f 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -21887,18 +21887,6 @@ AMD Family 19h CPU.
 
 @item znver3
 AMD Family 19h Zen version 3.
-
-@item x86-64
-Baseline x86-64 microarchitecture level (as defined in x86-64 psABI).
-
-@item x86-64-v2
-x86-64-v2 microarchitecture level.
-
-@item x86-64-v3
-x86-64-v3 microarchitecture level.
-
-@item x86-64-v4
-x86-64-v4 microarchitecture level.
 @end table
 
 Here is an example:
@@ -21992,6 +21980,16 @@ VPCLMULQDQ instructions.
 AVX512VNNI instructions.
 @item avx512bitalg
 AVX512BITALG instructions.
+@item x86-64
+Baseline x86-64 microarchitecture level (as defined in x86-64 psABI).
+@item x86-64-v2
+x86-64-v2 microarchitecture level.
+@item x86-64-v3
+x86-64-v3 microarchitecture level.
+@item x86-64-v4
+x86-64-v4 microarchitecture level.
+
+
 @end table
 
 Here is an example:
diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
index 48408d842db..19d073256a9 100644
--- a/gcc/doc/install.texi
+++ b/gcc/doc/install.texi
@@ -227,7 +227,9 @@ described below.
 @heading Tools/packages necessary for building GCC
 @table @asis
 @item ISO C++11 compiler
-Necessary to bootstrap GCC.
+Necessary to bootstrap GCC.  GCC 4.8.3 or newer has sufficient
+support for used C++11 features, with earlier GCC versions you
+might run into implementation bugs.
 
 Versions of GCC prior to 11 also allow bootstrapping with an ISO C++98
 compiler, versions of GCC prior to 4.8 also allow bootstrapping with a
@@ -236,7 +238,7 @@ bootstrapping with a traditional (K&R) C compiler.
 
 To build all languages in a cross-compiler or other configuration where
 3-stage bootstrap is not performed, you need to start with an existing
-GCC binary (version 4.8 or later) because source code for language
+GCC binary (version 4.8.3 or later) because source code for language
 frontends other than C might use GCC extensions.
 
 @item C standard library and headers
@@ -287,7 +289,7 @@ section.
 @item @anchor{GDC-prerequisite}GDC
 
 In order to build GDC, the D compiler, you need a working GDC
-compiler (GCC version 9.1 or later) and D runtime library,
+compiler (GCC version 9.4 or later) and D runtime library,
 @samp{libphobos}, as the D front end is written in D.
 
 Versions of GDC prior to 12 can be built with an ISO C++11 compiler, which can
@@ -3579,16 +3581,28 @@ information have to.
 @item
 @uref{#alpha-x-x,,alpha*-*-*}
 @item
+@uref{#amdgcn-x-amdhsa,,amdgcn-*-amdhsa}
+@item
 @uref{#amd64-x-solaris2,,amd64-*-solaris2*}
 @item
+@uref{#arc-x-elf32,,arc-*-elf32}
+@item
+@uref{#arc-linux-uclibc,,arc-linux-uclibc}
+@item
 @uref{#arm-x-eabi,,arm-*-eabi}
 @item
 @uref{#avr,,avr}
 @item
 @uref{#bfin,,Blackfin}
 @item
+@uref{#cris,,cris}
+@item
 @uref{#dos,,DOS}
 @item
+@uref{#epiphany-x-elf,,epiphany-*-elf}
+@item
+@uref{#ft32-x-elf,,ft32-*-elf}
+@item
 @uref{#x-x-freebsd,,*-*-freebsd*}
 @item
 @uref{#h8300-hms,,h8300-hms}
@@ -3613,6 +3627,8 @@ information have to.
 @item
 @uref{#iq2000-x-elf,,iq2000-*-elf}
 @item
+@uref{#loongarch,,loongarch}
+@item
 @uref{#lm32-x-elf,,lm32-*-elf}
 @item
 @uref{#lm32-x-uclinux,,lm32-*-uclinux}
@@ -3623,12 +3639,16 @@ information have to.
 @item
 @uref{#m68k-x-x,,m68k-*-*}
 @item
-@uref{#m68k-uclinux,,m68k-uclinux}
+@uref{#m68k-x-uclinux,,m68k-*-uclinux}
 @item
 @uref{#microblaze-x-elf,,microblaze-*-elf}
 @item
 @uref{#mips-x-x,,mips-*-*}
 @item
+@uref{#moxie-x-elf,,moxie-*-elf}
+@item
+@uref{#msp430-x-elf,,msp430-*-elf}
+@item
 @uref{#nds32le-x-elf,,nds32le-*-elf}
 @item
 @uref{#nds32be-x-elf,,nds32be-*-elf}
@@ -3667,6 +3687,10 @@ information have to.
 @item
 @uref{#riscv64-x-linux,,riscv64-*-linux}
 @item
+@uref{#rl78-x-elf,,rl78-*-elf}
+@item
+@uref{#rx-x-elf,,rx-*-elf}
+@item
 @uref{#s390-x-linux,,s390-*-linux*}
 @item
 @uref{#s390x-x-linux,,s390x-*-linux*}
@@ -3787,14 +3811,14 @@ This is a synonym for @samp{x86_64-*-solaris2*}.
 @heading amdgcn-*-amdhsa
 AMD GCN GPU target.
 
-Instead of GNU Binutils, you will need to install LLVM 6, or later, and copy
+Instead of GNU Binutils, you will need to install LLVM 13.0.1, or later, and copy
 @file{bin/llvm-mc} to @file{amdgcn-amdhsa/bin/as},
 @file{bin/lld} to @file{amdgcn-amdhsa/bin/ld},
 @file{bin/llvm-nm} to @file{amdgcn-amdhsa/bin/nm}, and
 @file{bin/llvm-ar} to both @file{bin/amdgcn-amdhsa-ar} and
 @file{bin/amdgcn-amdhsa-ranlib}.
 
-Use Newlib (2019-01-16, or newer).
+Use Newlib (3.2.0, or newer).
 
 To run the binaries, install the HSA Runtime from the
 @uref{https://rocm.github.io,,ROCm Platform}, and use
@@ -4635,8 +4659,7 @@ Instead of GNU binutils, you will need to install
 Tell GCC where to find it:
 @option{--with-build-time-tools=[install-nvptx-tools]/nvptx-none/bin}.
 
-You will need newlib 3.0 git revision
-cd31fbb2aea25f94d7ecedc9db16dfc87ab0c316 or later.  It can be
+You will need newlib 3.1.0 or later.  It can be
 automatically built together with GCC@.  For this, add a symbolic link
 to nvptx-newlib's @file{newlib} directory to the directory containing
 the GCC sources.
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index ff6c338bedb..0c177c9c529 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -19194,7 +19194,7 @@ performance of the code.  Permissible values for this option are:
 @samp{cortex-a78}, @samp{cortex-a78ae}, @samp{cortex-a78c},
 @samp{ares}, @samp{exynos-m1}, @samp{emag}, @samp{falkor},
 @samp{neoverse-512tvb}, @samp{neoverse-e1}, @samp{neoverse-n1},
-@samp{neoverse-n2}, @samp{neoverse-v1}, @samp{qdf24xx},
+@samp{neoverse-n2}, @samp{neoverse-v1}, @samp{neoverse-v2}, @samp{qdf24xx},
 @samp{saphira}, @samp{phecda}, @samp{xgene1}, @samp{vulcan},
 @samp{octeontx}, @samp{octeontx81},  @samp{octeontx83},
 @samp{octeontx2}, @samp{octeontx2t98}, @samp{octeontx2t96}
@@ -19208,7 +19208,8 @@ performance of the code.  Permissible values for this option are:
 @samp{cortex-a73.cortex-a35}, @samp{cortex-a73.cortex-a53},
 @samp{cortex-a75.cortex-a55}, @samp{cortex-a76.cortex-a55},
 @samp{cortex-r82}, @samp{cortex-x1}, @samp{cortex-x2},
-@samp{cortex-a510}, @samp{cortex-a710}, @samp{ampere1}, @samp{native}.
+@samp{cortex-a510}, @samp{cortex-a710}, @samp{ampere1},
+@samp{ampere1a}, @samp{native}.
 
 The values @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
 @samp{cortex-a73.cortex-a35}, @samp{cortex-a73.cortex-a53},
@@ -31541,11 +31542,11 @@ Intel sapphirerapids CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3,
 SSSE3, SSE4.1, SSE4.2, POPCNT, CX16, SAHF, FXSR, AVX, XSAVE, PCLMUL, FSGSBASE,
 RDRND, F16C, AVX2, BMI, BMI2, LZCNT, FMA, MOVBE, HLE, RDSEED, ADCX, PREFETCHW,
 AES, CLFLUSHOPT, XSAVEC, XSAVES, SGX, AVX512F, AVX512VL, AVX512BW, AVX512DQ,
-AVX512CD, PKU, AVX512VBMI, AVX512IFMA, SHA, AVX512VNNI, GFNI, VAES, AVX512VBMI2
+AVX512CD, PKU, AVX512VBMI, AVX512IFMA, SHA, AVX512VNNI, GFNI, VAES, AVX512VBMI2,
 VPCLMULQDQ, AVX512BITALG, RDPID, AVX512VPOPCNTDQ, PCONFIG, WBNOINVD, CLWB,
-MOVDIRI, MOVDIR64B, AVX512VP2INTERSECT, ENQCMD, CLDEMOTE, PTWRITE, WAITPKG,
-SERIALIZE, TSXLDTRK, UINTR, AMX-BF16, AMX-TILE, AMX-INT8, AVX-VNNI, AVX512FP16
-and AVX512BF16 instruction set support.
+MOVDIRI, MOVDIR64B, ENQCMD, CLDEMOTE, PTWRITE, WAITPKG, SERIALIZE, TSXLDTRK,
+UINTR, AMX-BF16, AMX-TILE, AMX-INT8, AVX-VNNI, AVX512FP16 and AVX512BF16
+instruction set support.
 
 @item alderlake
 Intel Alderlake CPU with 64-bit extensions, MOVBE, MMX, SSE, SSE2, SSE3, SSSE3,
diff --git a/gcc/dse.cc b/gcc/dse.cc
index bb658a85959..5880b6caa9a 100644
--- a/gcc/dse.cc
+++ b/gcc/dse.cc
@@ -1562,12 +1562,7 @@ record_store (rtx body, bb_info_t bb_info)
 					 width)
 	      /* We can only remove the later store if the earlier aliases
 		 at least all accesses the later one.  */
-	      && ((MEM_ALIAS_SET (mem) == MEM_ALIAS_SET (s_info->mem)
-		   || alias_set_subset_of (MEM_ALIAS_SET (mem),
-					   MEM_ALIAS_SET (s_info->mem)))
-		  && (!MEM_EXPR (s_info->mem)
-		      || refs_same_for_tbaa_p (MEM_EXPR (s_info->mem),
-					       MEM_EXPR (mem)))))
+	      && mems_same_for_tbaa_p (s_info->mem, mem))
 	    {
 	      if (GET_MODE (mem) == BLKmode)
 		{
diff --git a/gcc/expr.cc b/gcc/expr.cc
index 2103931c740..880ed89cb34 100644
--- a/gcc/expr.cc
+++ b/gcc/expr.cc
@@ -7640,8 +7640,7 @@ get_inner_reference (tree exp, poly_int64_pod *pbitsize,
 	  /* For vector fields re-check the target flags, as DECL_MODE
 	     could have been set with different target flags than
 	     the current function has.  */
-	  if (mode == BLKmode
-	      && VECTOR_TYPE_P (TREE_TYPE (field))
+	  if (VECTOR_TYPE_P (TREE_TYPE (field))
 	      && VECTOR_MODE_P (TYPE_MODE_RAW (TREE_TYPE (field))))
 	    mode = TYPE_MODE (TREE_TYPE (field));
 	}
diff --git a/gcc/fold-const.cc b/gcc/fold-const.cc
index 948e13a22d8..eec4c1820ed 100644
--- a/gcc/fold-const.cc
+++ b/gcc/fold-const.cc
@@ -3351,9 +3351,6 @@ operand_compare::operand_equal_p (const_tree arg0, const_tree arg1,
 		if (compare_address
 		    && (flags & OEP_ADDRESS_OF_SAME_FIELD) == 0)
 		  {
-		    if (TREE_OPERAND (arg0, 2)
-			|| TREE_OPERAND (arg1, 2))
-		      return OP_SAME_WITH_NULL (2);
 		    tree field0 = TREE_OPERAND (arg0, 1);
 		    tree field1 = TREE_OPERAND (arg1, 1);
 
@@ -3864,17 +3861,10 @@ operand_compare::hash_operand (const_tree t, inchash::hash &hstate,
 	      if (sflags & OEP_ADDRESS_OF)
 		{
 		  hash_operand (TREE_OPERAND (t, 0), hstate, flags);
-		  if (TREE_OPERAND (t, 2))
-		    hash_operand (TREE_OPERAND (t, 2), hstate,
-				  flags & ~OEP_ADDRESS_OF);
-		  else
-		    {
-		      tree field = TREE_OPERAND (t, 1);
-		      hash_operand (DECL_FIELD_OFFSET (field),
-				    hstate, flags & ~OEP_ADDRESS_OF);
-		      hash_operand (DECL_FIELD_BIT_OFFSET (field),
-				    hstate, flags & ~OEP_ADDRESS_OF);
-		    }
+		  hash_operand (DECL_FIELD_OFFSET (TREE_OPERAND (t, 1)),
+				hstate, flags & ~OEP_ADDRESS_OF);
+		  hash_operand (DECL_FIELD_BIT_OFFSET (TREE_OPERAND (t, 1)),
+				hstate, flags & ~OEP_ADDRESS_OF);
 		  return;
 		}
 	      break;
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index 97166527031..2f89c6d8c25 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,243 @@
+2022-12-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-12-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108131
+	* array.cc (match_array_element_spec): Avoid too early simplification
+	of matched array element specs that can lead to a misinterpretation
+	when used as array bounds in array declarations.
+
+2022-12-18  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2022-12-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/107872
+	* resolve.cc (derived_inaccessible): Skip over allocatable components
+	to prevent an infinite loop.
+
+2022-11-25  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-11-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107576
+	* interface.cc (gfc_procedure_use): Reject NULL as actual argument
+	when there is no explicit procedure interface.
+
+2022-10-29  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-21  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100097
+	PR fortran/100098
+	* trans-array.cc (gfc_trans_class_array): New function to
+	initialize class descriptor's TKR information.
+	* trans-array.h (gfc_trans_class_array): Add function prototype.
+	* trans-decl.cc (gfc_trans_deferred_vars): Add calls to the new
+	function for both pointers and allocatables.
+
+2022-10-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103413
+	* symbol.cc (gfc_type_compatible): A boz-literal-constant has no type
+	and thus is not considered compatible to any type.
+
+2022-10-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-20  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105633
+	* expr.cc (find_array_section): Move check for NULL pointers so
+	that both subscript triplets and vector subscripts are covered.
+
+2022-10-12  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/106817
+	* trans-expr.cc (gfc_conv_procedure_call): Collect all clobbers
+	to their own separate block.  Append the block of clobbers to
+	the procedure preliminary block after the argument evaluation
+	codes for all the arguments.
+
+2022-10-12  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/105012
+	* trans-expr.cc (gfc_conv_procedure_call): Retrieve variable
+	from the just calculated variable reference.
+
+2022-10-12  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	* trans.h (gfc_conv_expr_reference): Remove add_clobber
+	argument.
+	* trans-expr.cc (gfc_conv_expr_reference): Ditto. Inline code
+	depending on add_clobber and conditions controlling it ...
+	(gfc_conv_procedure_call): ... to here.
+
+2022-10-08  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100040
+	PR fortran/100029
+	* trans-expr.cc (gfc_conv_class_to_class): Add code to have
+	assumed-rank arrays recognized as full arrays and fix the type
+	of the array assignment.
+	(gfc_conv_procedure_call): Change order of code blocks such that
+	the free of ALLOCATABLE dummy arguments with INTENT(OUT) occurs
+	first.
+
+2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-22  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100103
+	* trans-array.cc (gfc_is_reallocatable_lhs): Add select rank
+	temporary associate names as possible targets of automatic
+	reallocation.
+
+2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-20  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100132
+	* trans-types.cc (create_fn_spec): Fix function attributes when
+	passing polymorphic pointers.
+
+2022-09-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107054
+	* simplify.cc (gfc_simplify_unpack): Replace assert by condition
+	that terminates simplification when there are not enough elements
+	in the constructor of argument VECTOR.
+
+2022-09-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82868
+	* trans-decl.cc (generate_coarray_sym_init): Skip symbol
+	if attr.associate_var.
+
+2022-09-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106985
+	* expr.cc (gfc_simplify_expr): Avoid NULL pointer dereference.
+
+2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106986
+	* simplify.cc (gfc_simplify_findloc): Do not try to simplify
+	intrinsic FINDLOC when the ARRAY argument has a NULL shape.
+
+2022-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106857
+	* simplify.cc (gfc_simplify_pack): Check for NULL pointer dereferences
+	while walking through constructors (error recovery).
+
+2022-09-16  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-03  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100245
+	* trans-expr.cc (trans_class_assignment): Add if clause to handle
+	derived type in the LHS.
+
+2022-09-05  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-04  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100136
+	* trans-expr.cc (gfc_conv_procedure_call): Add handling of pointer
+	expressions.
+
+2022-08-30  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-08-25  Tobias Burnus  <tobias@codesourcery.com>
+
+	* parse.cc (parse_omp_structured_block): When parsing strictly
+	structured blocks, issue an error if the end-directive comes
+	before the 'end block'.
+
+2022-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-08-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/106579
+	* trans-intrinsic.cc: Include realmpfr.h.
+	(conv_intrinsic_ieee_value): New function.
+	(gfc_conv_ieee_arithmetic_function): Handle ieee_value.
+
+2022-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-08-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/106579
+	* f95-lang.cc (gfc_init_builtin_functions): Initialize
+	BUILT_IN_FPCLASSIFY.
+	* libgfortran.h (IEEE_OTHER_VALUE, IEEE_SIGNALING_NAN,
+	IEEE_QUIET_NAN, IEEE_NEGATIVE_INF, IEEE_NEGATIVE_NORMAL,
+	IEEE_NEGATIVE_DENORMAL, IEEE_NEGATIVE_SUBNORMAL,
+	IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_ZERO, IEEE_POSITIVE_DENORMAL,
+	IEEE_POSITIVE_SUBNORMAL, IEEE_POSITIVE_NORMAL, IEEE_POSITIVE_INF):
+	New enum.
+	* trans-intrinsic.cc (conv_intrinsic_ieee_class): New function.
+	(gfc_conv_ieee_arithmetic_function): Handle ieee_class.
+
+2022-08-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-08-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103694
+	* simplify.cc (simplify_size): The size expression of an array cannot
+	be simplified if an error occurs while resolving the array spec.
+
+2022-08-23  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-08-17  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/106566
+	* openmp.cc (gfc_match_omp_declare_simd): Accept module procedures.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/gcc/fortran/array.cc b/gcc/fortran/array.cc
index bbdb5b392fc..f4003c2a2fe 100644
--- a/gcc/fortran/array.cc
+++ b/gcc/fortran/array.cc
@@ -499,8 +499,6 @@ match_array_element_spec (gfc_array_spec *as)
   if (!gfc_expr_check_typed (*upper, gfc_current_ns, false))
     return AS_UNKNOWN;
 
-  gfc_try_simplify_expr (*upper, 0);
-
   if (((*upper)->expr_type == EXPR_CONSTANT
 	&& (*upper)->ts.type != BT_INTEGER) ||
       ((*upper)->expr_type == EXPR_FUNCTION
@@ -533,8 +531,6 @@ match_array_element_spec (gfc_array_spec *as)
   if (!gfc_expr_check_typed (*upper, gfc_current_ns, false))
     return AS_UNKNOWN;
 
-  gfc_try_simplify_expr (*upper, 0);
-
   if (((*upper)->expr_type == EXPR_CONSTANT
 	&& (*upper)->ts.type != BT_INTEGER) ||
       ((*upper)->expr_type == EXPR_FUNCTION
diff --git a/gcc/fortran/expr.cc b/gcc/fortran/expr.cc
index be94c18c836..69d0b57c688 100644
--- a/gcc/fortran/expr.cc
+++ b/gcc/fortran/expr.cc
@@ -1552,6 +1552,12 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)
       lower = ref->u.ar.as->lower[d];
       upper = ref->u.ar.as->upper[d];
 
+      if (!lower || !upper)
+	{
+	  t = false;
+	  goto cleanup;
+	}
+
       if (ref->u.ar.dimen_type[d] == DIMEN_VECTOR)  /* Vector subscript.  */
 	{
 	  gfc_constructor *ci;
@@ -1594,9 +1600,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)
 	{
 	  if ((begin && begin->expr_type != EXPR_CONSTANT)
 	      || (finish && finish->expr_type != EXPR_CONSTANT)
-	      || (step && step->expr_type != EXPR_CONSTANT)
-	      || !lower
-	      || !upper)
+	      || (step && step->expr_type != EXPR_CONSTANT))
 	    {
 	      t = false;
 	      goto cleanup;
@@ -2287,7 +2291,8 @@ gfc_simplify_expr (gfc_expr *p, int type)
 	 initialization expression, or we want a subsection.  */
       if (p->symtree->n.sym->attr.flavor == FL_PARAMETER
 	  && (gfc_init_expr_flag || p->ref
-	      || p->symtree->n.sym->value->expr_type != EXPR_ARRAY))
+	      || (p->symtree->n.sym->value
+		  && p->symtree->n.sym->value->expr_type != EXPR_ARRAY)))
 	{
 	  if (!simplify_parameter_variable (p, type))
 	    return false;
diff --git a/gcc/fortran/f95-lang.cc b/gcc/fortran/f95-lang.cc
index 1a895a25132..20c4a87c90b 100644
--- a/gcc/fortran/f95-lang.cc
+++ b/gcc/fortran/f95-lang.cc
@@ -1002,8 +1002,9 @@ gfc_init_builtin_functions (void)
 		      "__builtin_isnormal", ATTR_CONST_NOTHROW_LEAF_LIST);
   gfc_define_builtin ("__builtin_signbit", ftype, BUILT_IN_SIGNBIT,
 		      "__builtin_signbit", ATTR_CONST_NOTHROW_LEAF_LIST);
+  gfc_define_builtin ("__builtin_fpclassify", ftype, BUILT_IN_FPCLASSIFY,
+		      "__builtin_fpclassify", ATTR_CONST_NOTHROW_LEAF_LIST);
 
-  ftype = build_function_type (integer_type_node, NULL_TREE);
   gfc_define_builtin ("__builtin_isless", ftype, BUILT_IN_ISLESS,
 		      "__builtin_isless", ATTR_CONST_NOTHROW_LEAF_LIST);
   gfc_define_builtin ("__builtin_islessequal", ftype, BUILT_IN_ISLESSEQUAL,
diff --git a/gcc/fortran/interface.cc b/gcc/fortran/interface.cc
index 71eec78259b..0acd78d5f2e 100644
--- a/gcc/fortran/interface.cc
+++ b/gcc/fortran/interface.cc
@@ -4137,6 +4137,14 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)
 	      return false;
 	    }
 
+	  if (a->expr && a->expr->expr_type == EXPR_NULL)
+	    {
+	      gfc_error ("Passing intrinsic NULL as actual argument at %L "
+			 "requires an explicit interface", &a->expr->where);
+	      a->expr->error = 1;
+	      return false;
+	    }
+
 	  /* TS 29113, C407b.  */
 	  if (a->expr && a->expr->expr_type == EXPR_VARIABLE
 	      && symbol_rank (a->expr->symtree->n.sym) == -1)
diff --git a/gcc/fortran/libgfortran.h b/gcc/fortran/libgfortran.h
index 064795eb469..81d1e340763 100644
--- a/gcc/fortran/libgfortran.h
+++ b/gcc/fortran/libgfortran.h
@@ -186,3 +186,23 @@ typedef enum
   BT_ASSUMED, BT_UNION, BT_BOZ
 }
 bt;
+
+/* Enumeration of the possible floating-point types. These values
+   correspond to the hidden arguments of the IEEE_CLASS_TYPE
+   derived-type of IEEE_ARITHMETIC.  */
+
+enum {
+  IEEE_OTHER_VALUE = 0,
+  IEEE_SIGNALING_NAN,
+  IEEE_QUIET_NAN,
+  IEEE_NEGATIVE_INF,
+  IEEE_NEGATIVE_NORMAL,
+  IEEE_NEGATIVE_DENORMAL,
+  IEEE_NEGATIVE_SUBNORMAL = IEEE_NEGATIVE_DENORMAL,
+  IEEE_NEGATIVE_ZERO,
+  IEEE_POSITIVE_ZERO,
+  IEEE_POSITIVE_DENORMAL,
+  IEEE_POSITIVE_SUBNORMAL = IEEE_POSITIVE_DENORMAL,
+  IEEE_POSITIVE_NORMAL,
+  IEEE_POSITIVE_INF
+};
diff --git a/gcc/fortran/openmp.cc b/gcc/fortran/openmp.cc
index 5018a37ec46..14f2521f1df 100644
--- a/gcc/fortran/openmp.cc
+++ b/gcc/fortran/openmp.cc
@@ -4027,9 +4027,13 @@ gfc_match_omp_declare_simd (void)
   gfc_omp_declare_simd *ods;
   bool needs_space = false;
 
-  switch (gfc_match (" ( %s ) ", &proc_name))
+  switch (gfc_match (" ( "))
     {
-    case MATCH_YES: break;
+    case MATCH_YES:
+      if (gfc_match_symbol (&proc_name, /* host assoc = */ true) != MATCH_YES
+	  || gfc_match (" ) ") != MATCH_YES)
+	return MATCH_ERROR;
+      break;
     case MATCH_NO: proc_name = NULL; needs_space = true; break;
     case MATCH_ERROR: return MATCH_ERROR;
     }
diff --git a/gcc/fortran/parse.cc b/gcc/fortran/parse.cc
index e6e915d2a5e..d1c72ef92e7 100644
--- a/gcc/fortran/parse.cc
+++ b/gcc/fortran/parse.cc
@@ -5708,7 +5708,7 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)
 	    }
 	  return st;
 	}
-      else if (st != omp_end_st)
+      else if (st != omp_end_st || block_construct)
 	{
 	  unexpected_statement (st);
 	  st = next_statement ();
diff --git a/gcc/fortran/resolve.cc b/gcc/fortran/resolve.cc
index 29df531cdb6..f4b5441622e 100644
--- a/gcc/fortran/resolve.cc
+++ b/gcc/fortran/resolve.cc
@@ -7528,7 +7528,8 @@ derived_inaccessible (gfc_symbol *sym)
   for (c = sym->components; c; c = c->next)
     {
 	/* Prevent an infinite loop through this function.  */
-	if (c->ts.type == BT_DERIVED && c->attr.pointer
+	if (c->ts.type == BT_DERIVED
+	    && (c->attr.pointer || c->attr.allocatable)
 	    && sym == c->ts.u.derived)
 	  continue;
 
diff --git a/gcc/fortran/simplify.cc b/gcc/fortran/simplify.cc
index 2f4f13b6a83..d48ae1af584 100644
--- a/gcc/fortran/simplify.cc
+++ b/gcc/fortran/simplify.cc
@@ -5857,6 +5857,7 @@ gfc_simplify_findloc (gfc_expr *array, gfc_expr *value, gfc_expr *dim,
   bool back_val = false;
 
   if (!is_constant_array_expr (array)
+      || array->shape == NULL
       || !gfc_is_constant_expr (dim))
     return NULL;
 
@@ -6393,7 +6394,7 @@ gfc_simplify_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)
       /* Copy only those elements of ARRAY to RESULT whose
 	 MASK equals .TRUE..  */
       mask_ctor = gfc_constructor_first (mask->value.constructor);
-      while (mask_ctor)
+      while (mask_ctor && array_ctor)
 	{
 	  if (mask_ctor->expr->value.logical)
 	    {
@@ -7498,8 +7499,9 @@ simplify_size (gfc_expr *array, gfc_expr *dim, int k)
     }
 
   for (ref = array->ref; ref; ref = ref->next)
-    if (ref->type == REF_ARRAY && ref->u.ar.as)
-      gfc_resolve_array_spec (ref->u.ar.as, 0);
+    if (ref->type == REF_ARRAY && ref->u.ar.as
+	&& !gfc_resolve_array_spec (ref->u.ar.as, 0))
+      return NULL;
 
   if (dim == NULL)
     {
@@ -8418,9 +8420,16 @@ gfc_simplify_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)
     {
       if (mask_ctor->expr->value.logical)
 	{
-	  gcc_assert (vector_ctor);
-	  e = gfc_copy_expr (vector_ctor->expr);
-	  vector_ctor = gfc_constructor_next (vector_ctor);
+	  if (vector_ctor)
+	    {
+	      e = gfc_copy_expr (vector_ctor->expr);
+	      vector_ctor = gfc_constructor_next (vector_ctor);
+	    }
+	  else
+	    {
+	      gfc_free_expr (result);
+	      return NULL;
+	    }
 	}
       else if (field->expr_type == EXPR_ARRAY)
 	e = gfc_copy_expr (field_ctor->expr);
diff --git a/gcc/fortran/symbol.cc b/gcc/fortran/symbol.cc
index 7a80dfd063b..b092813a5c0 100644
--- a/gcc/fortran/symbol.cc
+++ b/gcc/fortran/symbol.cc
@@ -5133,6 +5133,10 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)
   bool is_union1 = (ts1->type == BT_UNION);
   bool is_union2 = (ts2->type == BT_UNION);
 
+  /* A boz-literal-constant has no type.  */
+  if (ts1->type == BT_BOZ || ts2->type == BT_BOZ)
+    return false;
+
   if (is_class1
       && ts1->u.derived->components
       && ((ts1->u.derived->attr.is_class
diff --git a/gcc/fortran/trans-array.cc b/gcc/fortran/trans-array.cc
index 05134952db4..514cb057afb 100644
--- a/gcc/fortran/trans-array.cc
+++ b/gcc/fortran/trans-array.cc
@@ -10378,7 +10378,7 @@ gfc_is_reallocatable_lhs (gfc_expr *expr)
 
   /* An allocatable class variable with no reference.  */
   if (sym->ts.type == BT_CLASS
-      && !sym->attr.associate_var
+      && (!sym->attr.associate_var || sym->attr.select_rank_temporary)
       && CLASS_DATA (sym)->attr.allocatable
       && expr->ref
       && ((expr->ref->type == REF_ARRAY && expr->ref->u.ar.type == AR_FULL
@@ -10393,7 +10393,7 @@ gfc_is_reallocatable_lhs (gfc_expr *expr)
 
   /* An allocatable variable.  */
   if (sym->attr.allocatable
-      && !sym->attr.associate_var
+      && (!sym->attr.associate_var || sym->attr.select_rank_temporary)
       && expr->ref
       && expr->ref->type == REF_ARRAY
       && expr->ref->u.ar.type == AR_FULL)
@@ -11125,6 +11125,52 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
 }
 
 
+/* Initialize class descriptor's TKR infomation.  */
+
+void
+gfc_trans_class_array (gfc_symbol * sym, gfc_wrapped_block * block)
+{
+  tree type, etype;
+  tree tmp;
+  tree descriptor;
+  stmtblock_t init;
+  locus loc;
+  int rank;
+
+  /* Make sure the frontend gets these right.  */
+  gcc_assert (sym->ts.type == BT_CLASS && CLASS_DATA (sym)
+	      && (CLASS_DATA (sym)->attr.class_pointer
+		  || CLASS_DATA (sym)->attr.allocatable));
+
+  gcc_assert (VAR_P (sym->backend_decl)
+	      || TREE_CODE (sym->backend_decl) == PARM_DECL);
+
+  if (sym->attr.dummy)
+    return;
+
+  descriptor = gfc_class_data_get (sym->backend_decl);
+  type = TREE_TYPE (descriptor);
+
+  if (type == NULL || !GFC_DESCRIPTOR_TYPE_P (type))
+    return;
+
+  gfc_save_backend_locus (&loc);
+  gfc_set_backend_locus (&sym->declared_at);
+  gfc_init_block (&init);
+
+  rank = CLASS_DATA (sym)->as ? (CLASS_DATA (sym)->as->rank) : (0);
+  gcc_assert (rank>=0);
+  tmp = gfc_conv_descriptor_dtype (descriptor);
+  etype = gfc_get_element_type (type);
+  tmp = fold_build2_loc (input_location, MODIFY_EXPR, TREE_TYPE (tmp), tmp,
+			 gfc_get_dtype_rank_type (rank, etype));
+  gfc_add_expr_to_block (&init, tmp);
+
+  gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);
+  gfc_restore_backend_locus (&loc);
+}
+
+
 /* NULLIFY an allocatable/pointer array on function entry, free it on exit.
    Do likewise, recursively if necessary, with the allocatable components of
    derived types.  This function is also called for assumed-rank arrays, which
diff --git a/gcc/fortran/trans-array.h b/gcc/fortran/trans-array.h
index 04fee617590..cd2b3d9f2f0 100644
--- a/gcc/fortran/trans-array.h
+++ b/gcc/fortran/trans-array.h
@@ -69,6 +69,8 @@ tree gfc_check_pdt_dummy (gfc_symbol *, tree, int, gfc_actual_arglist *);
 
 tree gfc_alloc_allocatable_for_assignment (gfc_loopinfo*, gfc_expr*, gfc_expr*);
 
+/* Add initialization for class descriptors  */
+void gfc_trans_class_array (gfc_symbol *, gfc_wrapped_block *);
 /* Add initialization for deferred arrays.  */
 void gfc_trans_deferred_array (gfc_symbol *, gfc_wrapped_block *);
 /* Generate an initializer for a static pointer or allocatable array.  */
diff --git a/gcc/fortran/trans-decl.cc b/gcc/fortran/trans-decl.cc
index 908a4c6d42e..4ac06018e1f 100644
--- a/gcc/fortran/trans-decl.cc
+++ b/gcc/fortran/trans-decl.cc
@@ -4835,7 +4835,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
       else if ((!sym->attr.dummy || sym->ts.deferred)
 		&& (sym->ts.type == BT_CLASS
 		&& CLASS_DATA (sym)->attr.class_pointer))
-	continue;
+	gfc_trans_class_array (sym, block);
       else if ((!sym->attr.dummy || sym->ts.deferred)
 		&& (sym->attr.allocatable
 		    || (sym->attr.pointer && sym->attr.result)
@@ -4919,6 +4919,10 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
 		  tmp = NULL_TREE;
 		}
 
+	      /* Initialize descriptor's TKR information.  */
+	      if (sym->ts.type == BT_CLASS)
+		gfc_trans_class_array (sym, block);
+
 	      /* Deallocate when leaving the scope. Nullifying is not
 		 needed.  */
 	      if (!sym->attr.result && !sym->attr.dummy && !sym->attr.pointer
@@ -5529,6 +5533,7 @@ generate_coarray_sym_init (gfc_symbol *sym)
 
   if (sym->attr.dummy || sym->attr.allocatable || !sym->attr.codimension
       || sym->attr.use_assoc || !sym->attr.referenced
+      || sym->attr.associate_var
       || sym->attr.select_type_temporary)
     return;
 
diff --git a/gcc/fortran/trans-expr.cc b/gcc/fortran/trans-expr.cc
index 850007fd2e1..704cbc297f7 100644
--- a/gcc/fortran/trans-expr.cc
+++ b/gcc/fortran/trans-expr.cc
@@ -1178,8 +1178,10 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
     return;
 
   /* Test for FULL_ARRAY.  */
-  if (e->rank == 0 && gfc_expr_attr (e).codimension
-      && gfc_expr_attr (e).dimension)
+  if (e->rank == 0
+      && ((gfc_expr_attr (e).codimension && gfc_expr_attr (e).dimension)
+	  || (class_ts.u.derived->components->as
+	      && class_ts.u.derived->components->as->type == AS_ASSUMED_RANK)))
     full_array = true;
   else
     gfc_is_class_array_ref (e, &full_array);
@@ -1227,8 +1229,12 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
 	  && e->rank != class_ts.u.derived->components->as->rank)
 	{
 	  if (e->rank == 0)
-	    gfc_add_modify (&parmse->post, gfc_class_data_get (parmse->expr),
-			    gfc_conv_descriptor_data_get (ctree));
+	    {
+	      tmp = gfc_class_data_get (parmse->expr);
+	      gfc_add_modify (&parmse->post, tmp,
+			      fold_convert (TREE_TYPE (tmp),
+					 gfc_conv_descriptor_data_get (ctree)));
+	    }
 	  else
 	    class_array_data_assign (&parmse->post, parmse->expr, ctree, true);
 	}
@@ -6018,7 +6024,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
   gfc_charlen cl;
   gfc_expr *e;
   gfc_symbol *fsym;
-  stmtblock_t post;
   enum {MISSING = 0, ELEMENTAL, SCALAR, SCALAR_POINTER, ARRAY};
   gfc_component *comp = NULL;
   int arglen;
@@ -6062,7 +6067,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
   else
     info = NULL;
 
+  stmtblock_t post, clobbers;
   gfc_init_block (&post);
+  gfc_init_block (&clobbers);
   gfc_init_interface_mapping (&mapping);
   if (!comp)
     {
@@ -6395,7 +6402,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				&& e->symtree->n.sym->attr.pointer))
 			&& fsym && fsym->attr.target)
 		/* Make sure the function only gets called once.  */
-		gfc_conv_expr_reference (&parmse, e, false);
+		gfc_conv_expr_reference (&parmse, e);
 	      else if (e->expr_type == EXPR_FUNCTION
 		       && e->symtree->n.sym->result
 		       && e->symtree->n.sym->result != e->symtree->n.sym
@@ -6502,22 +6509,37 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		    }
 		  else
 		    {
-		      bool add_clobber;
-		      add_clobber = fsym && fsym->attr.intent == INTENT_OUT
-			&& !fsym->attr.allocatable && !fsym->attr.pointer
-			&& e->symtree && e->symtree->n.sym
-			&& !e->symtree->n.sym->attr.dimension
-			&& !e->symtree->n.sym->attr.pointer
-			&& !e->symtree->n.sym->attr.allocatable
-			/* See PR 41453.  */
-			&& !e->symtree->n.sym->attr.dummy
-			/* FIXME - PR 87395 and PR 41453  */
-			&& e->symtree->n.sym->attr.save == SAVE_NONE
-			&& !e->symtree->n.sym->attr.associate_var
-			&& e->ts.type != BT_CHARACTER && e->ts.type != BT_DERIVED
-			&& e->ts.type != BT_CLASS && !sym->attr.elemental;
-
-		      gfc_conv_expr_reference (&parmse, e, add_clobber);
+		      gfc_conv_expr_reference (&parmse, e);
+
+		      if (fsym
+			  && fsym->attr.intent == INTENT_OUT
+			  && !fsym->attr.allocatable
+			  && !fsym->attr.pointer
+			  && e->expr_type == EXPR_VARIABLE
+			  && e->ref == NULL
+			  && e->symtree
+			  && e->symtree->n.sym
+			  && !e->symtree->n.sym->attr.dimension
+			  && !e->symtree->n.sym->attr.pointer
+			  && !e->symtree->n.sym->attr.allocatable
+			  /* See PR 41453.  */
+			  && !e->symtree->n.sym->attr.dummy
+			  /* FIXME - PR 87395 and PR 41453  */
+			  && e->symtree->n.sym->attr.save == SAVE_NONE
+			  && !e->symtree->n.sym->attr.associate_var
+			  && e->ts.type != BT_CHARACTER
+			  && e->ts.type != BT_DERIVED
+			  && e->ts.type != BT_CLASS
+			  && !sym->attr.elemental)
+			{
+			  tree var;
+			  /* FIXME: This fails if var is passed by reference, see PR
+			     41453.  */
+			  var = build_fold_indirect_ref_loc (input_location,
+							     parmse.expr);
+			  tree clobber = build_clobber (TREE_TYPE (var));
+			  gfc_add_modify (&clobbers, var, clobber);
+			}
 		    }
 		  /* Catch base objects that are not variables.  */
 		  if (e->ts.type == BT_CLASS
@@ -6526,23 +6548,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		    base_object = build_fold_indirect_ref_loc (input_location,
 							       parmse.expr);
 
-		  /* A class array element needs converting back to be a
-		     class object, if the formal argument is a class object.  */
-		  if (fsym && fsym->ts.type == BT_CLASS
-			&& e->ts.type == BT_CLASS
-			&& ((CLASS_DATA (fsym)->as
-			     && CLASS_DATA (fsym)->as->type == AS_ASSUMED_RANK)
-			    || CLASS_DATA (e)->attr.dimension))
-		    gfc_conv_class_to_class (&parmse, e, fsym->ts, false,
-				     fsym->attr.intent != INTENT_IN
-				     && (CLASS_DATA (fsym)->attr.class_pointer
-					 || CLASS_DATA (fsym)->attr.allocatable),
-				     fsym->attr.optional
-				     && e->expr_type == EXPR_VARIABLE
-				     && e->symtree->n.sym->attr.optional,
-				     CLASS_DATA (fsym)->attr.class_pointer
-				     || CLASS_DATA (fsym)->attr.allocatable);
-
 		  /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is
 		     allocated on entry, it must be deallocated.  */
 		  if (fsym && fsym->attr.intent == INTENT_OUT
@@ -6603,6 +6608,23 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		      gfc_add_expr_to_block (&se->pre, tmp);
 		    }
 
+		  /* A class array element needs converting back to be a
+		     class object, if the formal argument is a class object.  */
+		  if (fsym && fsym->ts.type == BT_CLASS
+			&& e->ts.type == BT_CLASS
+			&& ((CLASS_DATA (fsym)->as
+			     && CLASS_DATA (fsym)->as->type == AS_ASSUMED_RANK)
+			    || CLASS_DATA (e)->attr.dimension))
+		    gfc_conv_class_to_class (&parmse, e, fsym->ts, false,
+				     fsym->attr.intent != INTENT_IN
+				     && (CLASS_DATA (fsym)->attr.class_pointer
+					 || CLASS_DATA (fsym)->attr.allocatable),
+				     fsym->attr.optional
+				     && e->expr_type == EXPR_VARIABLE
+				     && e->symtree->n.sym->attr.optional,
+				     CLASS_DATA (fsym)->attr.class_pointer
+				     || CLASS_DATA (fsym)->attr.allocatable);
+
 		  if (fsym && (fsym->ts.type == BT_DERIVED
 			       || fsym->ts.type == BT_ASSUMED)
 		      && e->ts.type == BT_CLASS
@@ -7220,16 +7242,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	      else
 		goto end_pointer_check;
 
+	      tmp = parmse.expr;
 	      if (fsym && fsym->ts.type == BT_CLASS)
 		{
-		  tmp = build_fold_indirect_ref_loc (input_location,
-						      parmse.expr);
+		  if (POINTER_TYPE_P (TREE_TYPE (tmp)))
+		    tmp = build_fold_indirect_ref_loc (input_location, tmp);
 		  tmp = gfc_class_data_get (tmp);
 		  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))
 		    tmp = gfc_conv_descriptor_data_get (tmp);
 		}
-	      else
-		tmp = parmse.expr;
 
 	      /* If the argument is passed by value, we need to strip the
 		 INDIRECT_REF.  */
@@ -7385,6 +7406,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 
       vec_safe_push (arglist, parmse.expr);
     }
+  gfc_add_block_to_block (&se->pre, &clobbers);
   gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);
 
   if (comp)
@@ -9485,7 +9507,7 @@ gfc_conv_expr_type (gfc_se * se, gfc_expr * expr, tree type)
    values only.  */
 
 void
-gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)
+gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)
 {
   gfc_ss *ss;
   tree var;
@@ -9525,16 +9547,6 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)
 	  gfc_add_block_to_block (&se->pre, &se->post);
 	  se->expr = var;
 	}
-      else if (add_clobber && expr->ref == NULL)
-	{
-	  tree clobber;
-	  tree var;
-	  /* FIXME: This fails if var is passed by reference, see PR
-	     41453.  */
-	  var = expr->symtree->n.sym->backend_decl;
-	  clobber = build_clobber (TREE_TYPE (var));
-	  gfc_add_modify (&se->pre, var, clobber);
-	}
       return;
     }
 
@@ -11436,6 +11448,9 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,
       class_han = GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))
 	  ? gfc_class_data_get (lse->expr) : lse->expr;
 
+      if (!POINTER_TYPE_P (TREE_TYPE (class_han)))
+	class_han = gfc_build_addr_expr (NULL_TREE, class_han);
+
       /* Allocate block.  */
       gfc_init_block (&alloc);
       gfc_allocate_using_malloc (&alloc, class_han, size, NULL_TREE);
diff --git a/gcc/fortran/trans-intrinsic.cc b/gcc/fortran/trans-intrinsic.cc
index 2249723540d..86e0bf9655f 100644
--- a/gcc/fortran/trans-intrinsic.cc
+++ b/gcc/fortran/trans-intrinsic.cc
@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "trans-array.h"
 #include "dependency.h"	/* For CAF array alias analysis.  */
 #include "attribs.h"
+#include "realmpfr.h"
 
 /* Only for gfc_trans_assign and gfc_trans_pointer_assign.  */
 
@@ -10008,6 +10009,220 @@ conv_intrinsic_ieee_copy_sign (gfc_se * se, gfc_expr * expr)
 }
 
 
+/* Generate code for IEEE_CLASS.  */
+
+static bool
+conv_intrinsic_ieee_class (gfc_se *se, gfc_expr *expr)
+{
+  tree arg, c, t1, t2, t3, t4;
+
+  /* In GCC 12, handle inline only the powerpc64le-linux IEEE quad
+     real(kind=16) and nothing else.  */
+  if (gfc_type_abi_kind (&expr->value.function.actual->expr->ts) != 17)
+    return false;
+
+  /* Convert arg, evaluate it only once.  */
+  conv_ieee_function_args (se, expr, &arg, 1);
+  arg = gfc_evaluate_now (arg, &se->pre);
+
+  c = build_call_expr_loc (input_location,
+			   builtin_decl_explicit (BUILT_IN_FPCLASSIFY), 6,
+			   build_int_cst (integer_type_node, IEEE_QUIET_NAN),
+			   build_int_cst (integer_type_node,
+					  IEEE_POSITIVE_INF),
+			   build_int_cst (integer_type_node,
+					  IEEE_POSITIVE_NORMAL),
+			   build_int_cst (integer_type_node,
+					  IEEE_POSITIVE_DENORMAL),
+			   build_int_cst (integer_type_node,
+					  IEEE_POSITIVE_ZERO),
+			   arg);
+  c = gfc_evaluate_now (c, &se->pre);
+  t1 = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,
+			c, build_int_cst (integer_type_node,
+					  IEEE_QUIET_NAN));
+  /* In GCC 12, we don't have __builtin_issignaling but above we made
+     sure arg is powerpc64le-linux IEEE quad real(kind=16).
+     When we check it is some kind of NaN by fpclassify, all we need
+     is check the ((__int128) 1) << 111 bit, if it is zero, it is a sNaN,
+     if it is set, it is a qNaN.  */
+  t2 = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,
+			build_nonstandard_integer_type (128, 1), arg);
+  t2 = fold_build2_loc (input_location, RSHIFT_EXPR, TREE_TYPE (t2), t2,
+			build_int_cst (integer_type_node, 111));
+  t2 = fold_convert (integer_type_node, t2);
+  t2 = fold_build2_loc (input_location, BIT_AND_EXPR, integer_type_node,
+			t2, integer_one_node);
+  t2 = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,
+			t2, build_zero_cst (TREE_TYPE (t2)));
+  t1 = fold_build2_loc (input_location, TRUTH_AND_EXPR,
+			logical_type_node, t1, t2);
+  t3 = fold_build2_loc (input_location, GE_EXPR, logical_type_node,
+			c, build_int_cst (integer_type_node,
+					  IEEE_POSITIVE_ZERO));
+  t4 = build_call_expr_loc (input_location,
+			    builtin_decl_explicit (BUILT_IN_SIGNBIT), 1,
+			    arg);
+  t4 = fold_build2_loc (input_location, NE_EXPR, logical_type_node,
+			t4, build_zero_cst (TREE_TYPE (t4)));
+  t3 = fold_build2_loc (input_location, TRUTH_AND_EXPR,
+			logical_type_node, t3, t4);
+  int s = IEEE_NEGATIVE_ZERO + IEEE_POSITIVE_ZERO;
+  gcc_assert (IEEE_NEGATIVE_INF == s - IEEE_POSITIVE_INF);
+  gcc_assert (IEEE_NEGATIVE_NORMAL == s - IEEE_POSITIVE_NORMAL);
+  gcc_assert (IEEE_NEGATIVE_DENORMAL == s - IEEE_POSITIVE_DENORMAL);
+  gcc_assert (IEEE_NEGATIVE_SUBNORMAL == s - IEEE_POSITIVE_SUBNORMAL);
+  gcc_assert (IEEE_NEGATIVE_ZERO == s - IEEE_POSITIVE_ZERO);
+  t4 = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (c),
+			build_int_cst (TREE_TYPE (c), s), c);
+  t3 = fold_build3_loc (input_location, COND_EXPR, TREE_TYPE (c),
+			t3, t4, c);
+  t1 = fold_build3_loc (input_location, COND_EXPR, TREE_TYPE (c), t1,
+			build_int_cst (TREE_TYPE (c), IEEE_SIGNALING_NAN),
+			t3);
+  tree type = gfc_typenode_for_spec (&expr->ts);
+  /* Perform a quick sanity check that the return type is
+     IEEE_CLASS_TYPE derived type defined in
+     libgfortran/ieee/ieee_arithmetic.F90
+     Primarily check that it is a derived type with a single
+     member in it.  */
+  gcc_assert (TREE_CODE (type) == RECORD_TYPE);
+  tree field = NULL_TREE;
+  for (tree f = TYPE_FIELDS (type); f != NULL_TREE; f = DECL_CHAIN (f))
+    if (TREE_CODE (f) == FIELD_DECL)
+      {
+	gcc_assert (field == NULL_TREE);
+	field = f;
+      }
+  gcc_assert (field);
+  t1 = fold_convert (TREE_TYPE (field), t1);
+  se->expr = build_constructor_single (type, field, t1);
+  return true;
+}
+
+
+/* Generate code for IEEE_VALUE.  */
+
+static bool
+conv_intrinsic_ieee_value (gfc_se *se, gfc_expr *expr)
+{
+  tree args[2], arg, ret, tmp;
+  stmtblock_t body;
+
+  /* In GCC 12, handle inline only the powerpc64le-linux IEEE quad
+     real(kind=16) and nothing else.  */
+  if (gfc_type_abi_kind (&expr->ts) != 17)
+    return false;
+
+  /* Convert args, evaluate the second one only once.  */
+  conv_ieee_function_args (se, expr, args, 2);
+  arg = gfc_evaluate_now (args[1], &se->pre);
+
+  tree type = TREE_TYPE (arg);
+  /* Perform a quick sanity check that the second argument's type is
+     IEEE_CLASS_TYPE derived type defined in
+     libgfortran/ieee/ieee_arithmetic.F90
+     Primarily check that it is a derived type with a single
+     member in it.  */
+  gcc_assert (TREE_CODE (type) == RECORD_TYPE);
+  tree field = NULL_TREE;
+  for (tree f = TYPE_FIELDS (type); f != NULL_TREE; f = DECL_CHAIN (f))
+    if (TREE_CODE (f) == FIELD_DECL)
+      {
+	gcc_assert (field == NULL_TREE);
+	field = f;
+      }
+  gcc_assert (field);
+  arg = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),
+			 arg, field, NULL_TREE);
+  arg = gfc_evaluate_now (arg, &se->pre);
+
+  type = gfc_typenode_for_spec (&expr->ts);
+  gcc_assert (TREE_CODE (type) == REAL_TYPE);
+  ret = gfc_create_var (type, NULL);
+
+  gfc_init_block (&body);
+
+  tree end_label = gfc_build_label_decl (NULL_TREE);
+  for (int c = IEEE_SIGNALING_NAN; c <= IEEE_POSITIVE_INF; ++c)
+    {
+      tree label = gfc_build_label_decl (NULL_TREE);
+      tree low = build_int_cst (TREE_TYPE (arg), c);
+      tmp = build_case_label (low, low, label);
+      gfc_add_expr_to_block (&body, tmp);
+
+      REAL_VALUE_TYPE real;
+      int k;
+      switch (c)
+	{
+	case IEEE_SIGNALING_NAN:
+	  real_nan (&real, "", 0, TYPE_MODE (type));
+	  break;
+	case IEEE_QUIET_NAN:
+	  real_nan (&real, "", 1, TYPE_MODE (type));
+	  break;
+	case IEEE_NEGATIVE_INF:
+	  real_inf (&real);
+	  real = real_value_negate (&real);
+	  break;
+	case IEEE_NEGATIVE_NORMAL:
+	  real_from_integer (&real, TYPE_MODE (type), -42, SIGNED);
+	  break;
+	case IEEE_NEGATIVE_DENORMAL:
+	  k = gfc_validate_kind (BT_REAL, expr->ts.kind, false);
+	  real_from_mpfr (&real, gfc_real_kinds[k].tiny,
+			  type, GFC_RND_MODE);
+	  real_arithmetic (&real, RDIV_EXPR, &real, &dconst2);
+	  real = real_value_negate (&real);
+	  break;
+	case IEEE_NEGATIVE_ZERO:
+	  real_from_integer (&real, TYPE_MODE (type), 0, SIGNED);
+	  real = real_value_negate (&real);
+	  break;
+	case IEEE_POSITIVE_ZERO:
+	  /* Make this also the default: label.  The other possibility
+	     would be to add a separate default: label followed by
+	     __builtin_unreachable ().  */
+	  label = gfc_build_label_decl (NULL_TREE);
+	  tmp = build_case_label (NULL_TREE, NULL_TREE, label);
+	  gfc_add_expr_to_block (&body, tmp);
+	  real_from_integer (&real, TYPE_MODE (type), 0, SIGNED);
+	  break;
+	case IEEE_POSITIVE_DENORMAL:
+	  k = gfc_validate_kind (BT_REAL, expr->ts.kind, false);
+	  real_from_mpfr (&real, gfc_real_kinds[k].tiny,
+			  type, GFC_RND_MODE);
+	  real_arithmetic (&real, RDIV_EXPR, &real, &dconst2);
+	  break;
+	case IEEE_POSITIVE_NORMAL:
+	  real_from_integer (&real, TYPE_MODE (type), 42, SIGNED);
+	  break;
+	case IEEE_POSITIVE_INF:
+	  real_inf (&real);
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+
+      tree val = build_real (type, real);
+      gfc_add_modify (&body, ret, val);
+
+      tmp = build1_v (GOTO_EXPR, end_label);
+      gfc_add_expr_to_block (&body, tmp);
+    }
+
+  tmp = gfc_finish_block (&body);
+  tmp = fold_build2_loc (input_location, SWITCH_EXPR, NULL_TREE, arg, tmp);
+  gfc_add_expr_to_block (&se->pre, tmp);
+
+  tmp = build1_v (LABEL_EXPR, end_label);
+  gfc_add_expr_to_block (&se->pre, tmp);
+
+  se->expr = ret;
+  return true;
+}
+
+
 /* Generate code for an intrinsic function from the IEEE_ARITHMETIC
    module.  */
 
@@ -10038,6 +10253,10 @@ gfc_conv_ieee_arithmetic_function (gfc_se * se, gfc_expr * expr)
     conv_intrinsic_ieee_logb_rint (se, expr, BUILT_IN_LOGB);
   else if (startswith (name, "_gfortran_ieee_rint"))
     conv_intrinsic_ieee_logb_rint (se, expr, BUILT_IN_RINT);
+  else if (startswith (name, "ieee_class_") && ISDIGIT (name[11]))
+    return conv_intrinsic_ieee_class (se, expr);
+  else if (startswith (name, "ieee_value_") && ISDIGIT (name[11]))
+    return conv_intrinsic_ieee_value (se, expr);
   else
     /* It is not among the functions we translate directly.  We return
        false, so a library function call is emitted.  */
diff --git a/gcc/fortran/trans-types.cc b/gcc/fortran/trans-types.cc
index 3cdc529eb28..a01e218b30f 100644
--- a/gcc/fortran/trans-types.cc
+++ b/gcc/fortran/trans-types.cc
@@ -3042,12 +3042,23 @@ create_fn_spec (gfc_symbol *sym, tree fntype)
   for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)
     if (spec_len < sizeof (spec))
       {
-	if (!f->sym || f->sym->attr.pointer || f->sym->attr.target
+	bool is_class = false;
+	bool is_pointer = false;
+
+	if (f->sym)
+	  {
+	    is_class = f->sym->ts.type == BT_CLASS && CLASS_DATA (f->sym)
+	      && f->sym->attr.class_ok;
+	    is_pointer = is_class ? CLASS_DATA (f->sym)->attr.class_pointer
+				  : f->sym->attr.pointer;
+	  }
+
+	if (f->sym == NULL || is_pointer || f->sym->attr.target
 	    || f->sym->attr.external || f->sym->attr.cray_pointer
 	    || (f->sym->ts.type == BT_DERIVED
 		&& (f->sym->ts.u.derived->attr.proc_pointer_comp
 		    || f->sym->ts.u.derived->attr.pointer_comp))
-	    || (f->sym->ts.type == BT_CLASS
+	    || (is_class
 		&& (CLASS_DATA (f->sym)->ts.u.derived->attr.proc_pointer_comp
 		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp))
 	    || (f->sym->ts.type == BT_INTEGER && f->sym->ts.is_c_interop))
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
index 623aceed520..6451a633e60 100644
--- a/gcc/fortran/trans.h
+++ b/gcc/fortran/trans.h
@@ -499,8 +499,7 @@ tree gfc_build_compare_string (tree, tree, tree, tree, int, enum tree_code);
 void gfc_conv_expr (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_val (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_lhs (gfc_se * se, gfc_expr * expr);
-void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr,
-			      bool add_clobber = false);
+void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_type (gfc_se * se, gfc_expr *, tree);
 
 
diff --git a/gcc/gcc.cc b/gcc/gcc.cc
index bb07cc244e3..b4c8d659014 100644
--- a/gcc/gcc.cc
+++ b/gcc/gcc.cc
@@ -27,6 +27,7 @@ CC recognizes how to compile each input file by suffixes in the file names.
 Once it knows which kind of compilation to perform, the procedure for
 compilation is specified by a string called a "spec".  */
 
+#define INCLUDE_STRING
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -43,6 +44,7 @@ compilation is specified by a string called a "spec".  */
 #include "opts.h"
 #include "filenames.h"
 #include "spellcheck.h"
+#include "opts-jobserver.h"
 
 
 
@@ -9178,38 +9180,9 @@ driver::final_actions () const
 void
 driver::detect_jobserver () const
 {
-  /* Detect jobserver and drop it if it's not working.  */
-  const char *makeflags = env.get ("MAKEFLAGS");
-  if (makeflags != NULL)
-    {
-      const char *needle = "--jobserver-auth=";
-      const char *n = strstr (makeflags, needle);
-      if (n != NULL)
-	{
-	  int rfd = -1;
-	  int wfd = -1;
-
-	  bool jobserver
-	    = (sscanf (n + strlen (needle), "%d,%d", &rfd, &wfd) == 2
-	       && rfd > 0
-	       && wfd > 0
-	       && is_valid_fd (rfd)
-	       && is_valid_fd (wfd));
-
-	  /* Drop the jobserver if it's not working now.  */
-	  if (!jobserver)
-	    {
-	      unsigned offset = n - makeflags;
-	      char *dup = xstrdup (makeflags);
-	      dup[offset] = '\0';
-
-	      const char *space = strchr (makeflags + offset, ' ');
-	      if (space != NULL)
-		strcpy (dup + offset, space);
-	      xputenv (concat ("MAKEFLAGS=", dup, NULL));
-	    }
-	}
-    }
+  jobserver_info jinfo;
+  if (!jinfo.is_active && !jinfo.skipped_makeflags.empty ())
+    xputenv (jinfo.skipped_makeflags.c_str ());
 }
 
 /* Determine what the exit code of the driver should be.  */
diff --git a/gcc/gimple-ssa-warn-access.cc b/gcc/gimple-ssa-warn-access.cc
index 39aa8186de6..efe55dab917 100644
--- a/gcc/gimple-ssa-warn-access.cc
+++ b/gcc/gimple-ssa-warn-access.cc
@@ -2121,7 +2121,6 @@ private:
 
   /* Return the argument that a call returns.  */
   tree gimple_call_return_arg (gcall *);
-  tree gimple_call_return_arg_ref (gcall *);
 
   /* Check a call for uses of a dangling pointer arguments.  */
   void check_call_dangling (gcall *);
@@ -4442,24 +4441,6 @@ pass_waccess::gimple_call_return_arg (gcall *call)
   return gimple_call_arg (call, argno);
 }
 
-/* Return the decl referenced by the argument that the call STMT to
-   a built-in function returns (including with an offset) or null if
-   it doesn't.  */
-
-tree
-pass_waccess::gimple_call_return_arg_ref (gcall *call)
-{
-  if (tree arg = gimple_call_return_arg (call))
-    {
-      access_ref aref;
-      if (m_ptr_qry.get_ref (arg, call, &aref, 0)
-	  && DECL_P (aref.ref))
-	return aref.ref;
-    }
-
-  return NULL_TREE;
-}
-
 /* Check for and diagnose all uses of the dangling pointer VAR to the auto
    object DECL whose lifetime has ended.  OBJREF is true when VAR denotes
    an access to a DECL that may have been clobbered.  */
@@ -4627,11 +4608,10 @@ pass_waccess::check_dangling_uses ()
   unsigned i;
   FOR_EACH_SSA_NAME (i, var, m_func)
     {
-      /* For each SSA_NAME pointer VAR find the DECL it points to.
-	 If the DECL is a clobbered local variable, check to see
+      /* For each SSA_NAME pointer VAR find the object it points to.
+	 If the object is a clobbered local variable, check to see
 	 if any of VAR's uses (or those of other pointers derived
 	 from VAR) happens after the clobber.  If so, warn.  */
-      tree decl = NULL_TREE;
 
       gimple *def_stmt = SSA_NAME_DEF_STMT (var);
       if (is_gimple_assign (def_stmt))
@@ -4641,23 +4621,30 @@ pass_waccess::check_dangling_uses ()
 	    {
 	      if (!POINTER_TYPE_P (TREE_TYPE (var)))
 		continue;
-	      decl = TREE_OPERAND (rhs, 0);
+	      check_dangling_uses (var, TREE_OPERAND (rhs, 0));
 	    }
 	  else
 	    {
 	      /* For other expressions, check the base DECL to see
 		 if it's been clobbered, most likely as a result of
 		 inlining a reference to it.  */
-	      decl = get_base_address (rhs);
+	      tree decl = get_base_address (rhs);
 	      if (DECL_P (decl))
 		check_dangling_uses (var, decl, false, true);
-	      continue;
 	    }
 	}
       else if (POINTER_TYPE_P (TREE_TYPE (var)))
 	{
 	  if (gcall *call = dyn_cast<gcall *>(def_stmt))
-	    decl = gimple_call_return_arg_ref (call);
+	    {
+	      if (tree arg = gimple_call_return_arg (call))
+		{
+		  access_ref aref;
+		  if (m_ptr_qry.get_ref (arg, call, &aref, 0)
+		      && aref.deref < 0)
+		    check_dangling_uses (var, aref.ref);
+		}
+	    }
 	  else if (gphi *phi = dyn_cast <gphi *>(def_stmt))
 	    {
 	      unsigned nargs = gimple_phi_num_args (phi);
@@ -4665,19 +4652,12 @@ pass_waccess::check_dangling_uses ()
 		{
 		  access_ref aref;
 		  tree arg = gimple_phi_arg_def (phi, i);
-		  if (!m_ptr_qry.get_ref (arg, phi, &aref, 0)
-		      || (aref.deref == 0
-			  && POINTER_TYPE_P (TREE_TYPE (aref.ref))))
-		    continue;
-		  check_dangling_uses (var, aref.ref, true);
+		  if (m_ptr_qry.get_ref (arg, phi, &aref, 0)
+		      && aref.deref < 0)
+		    check_dangling_uses (var, aref.ref, true);
 		}
-	      continue;
 	    }
-	  else
-	    continue;
 	}
-
-      check_dangling_uses (var, decl);
     }
 }
 
diff --git a/gcc/gimple-ssa-warn-alloca.cc b/gcc/gimple-ssa-warn-alloca.cc
index 273b88ec141..23f63f066f5 100644
--- a/gcc/gimple-ssa-warn-alloca.cc
+++ b/gcc/gimple-ssa-warn-alloca.cc
@@ -217,6 +217,7 @@ alloca_call_type (gimple *stmt, bool is_vla)
   int_range_max r;
   if (warn_limit_specified_p (is_vla)
       && TREE_CODE (len) == SSA_NAME
+      && types_compatible_p (TREE_TYPE (len), size_type_node)
       && get_range_query (cfun)->range_of_expr (r, len, stmt)
       && !r.varying_p ())
     {
diff --git a/gcc/ifcvt.cc b/gcc/ifcvt.cc
index e007b17b793..2c1eba312de 100644
--- a/gcc/ifcvt.cc
+++ b/gcc/ifcvt.cc
@@ -3368,6 +3368,20 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)
   return TRUE;
 }
 
+/* Helper function for noce_convert_multiple_sets_1.  If store to
+   DEST can affect P[0] or P[1], clear P[0].  Called via note_stores.  */
+
+static void
+check_for_cc_cmp_clobbers (rtx dest, const_rtx, void *p0)
+{
+  rtx *p = (rtx *) p0;
+  if (p[0] == NULL_RTX)
+    return;
+  if (reg_overlap_mentioned_p (dest, p[0])
+      || (p[1] && reg_overlap_mentioned_p (dest, p[1])))
+    p[0] = NULL_RTX;
+}
+
 /* This goes through all relevant insns of IF_INFO->then_bb and tries to
    create conditional moves.  In case a simple move sufficis the insn
    should be listed in NEED_NO_CMOV.  The rewired-src cases should be
@@ -3518,7 +3532,7 @@ noce_convert_multiple_sets_1 (struct noce_if_info *if_info,
 
 	 as min/max and emit an insn, accordingly.  */
       unsigned cost1 = 0, cost2 = 0;
-      rtx_insn *seq, *seq1, *seq2;
+      rtx_insn *seq, *seq1, *seq2 = NULL;
       rtx temp_dest = NULL_RTX, temp_dest1 = NULL_RTX, temp_dest2 = NULL_RTX;
       bool read_comparison = false;
 
@@ -3530,9 +3544,10 @@ noce_convert_multiple_sets_1 (struct noce_if_info *if_info,
 	 as well.  This allows the backend to emit a cmov directly without
 	 creating an additional compare for each.  If successful, costing
 	 is easier and this sequence is usually preferred.  */
-      seq2 = try_emit_cmove_seq (if_info, temp, cond,
-				 new_val, old_val, need_cmov,
-				 &cost2, &temp_dest2, cc_cmp, rev_cc_cmp);
+      if (cc_cmp)
+	seq2 = try_emit_cmove_seq (if_info, temp, cond,
+				   new_val, old_val, need_cmov,
+				   &cost2, &temp_dest2, cc_cmp, rev_cc_cmp);
 
       /* The backend might have created a sequence that uses the
 	 condition.  Check this.  */
@@ -3587,6 +3602,24 @@ noce_convert_multiple_sets_1 (struct noce_if_info *if_info,
 	  return FALSE;
 	}
 
+      if (cc_cmp)
+	{
+	  /* Check if SEQ can clobber registers mentioned in
+	     cc_cmp and/or rev_cc_cmp.  If yes, we need to use
+	     only seq1 from that point on.  */
+	  rtx cc_cmp_pair[2] = { cc_cmp, rev_cc_cmp };
+	  for (walk = seq; walk; walk = NEXT_INSN (walk))
+	    {
+	      note_stores (walk, check_for_cc_cmp_clobbers, cc_cmp_pair);
+	      if (cc_cmp_pair[0] == NULL_RTX)
+		{
+		  cc_cmp = NULL_RTX;
+		  rev_cc_cmp = NULL_RTX;
+		  break;
+		}
+	    }
+	}
+
       /* End the sub sequence and emit to the main sequence.  */
       emit_insn (seq);
 
diff --git a/gcc/ira-color.cc b/gcc/ira-color.cc
index 4a1a325e8e3..ffe73b61c45 100644
--- a/gcc/ira-color.cc
+++ b/gcc/ira-color.cc
@@ -2209,8 +2209,8 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)
     restore_costs_from_copies (a);
   ALLOCNO_HARD_REGNO (a) = best_hard_regno;
   ALLOCNO_ASSIGNED_P (a) = true;
-  if (best_hard_regno >= 0)
-    update_costs_from_copies (a, true, ! retry_p);
+  if (best_hard_regno >= 0 && !retry_p)
+    update_costs_from_copies (a, true, true);
   ira_assert (ALLOCNO_CLASS (a) == aclass);
   /* We don't need updated costs anymore.  */
   ira_free_allocno_updated_costs (a);
diff --git a/gcc/ira.cc b/gcc/ira.cc
index e3b3c549120..a287026a275 100644
--- a/gcc/ira.cc
+++ b/gcc/ira.cc
@@ -5718,6 +5718,7 @@ ira (FILE *f)
     regstat_free_ri ();
     regstat_init_n_sets_and_refs ();
     regstat_compute_ri ();
+    resize_reg_info ();
   };
 
   int max_regno_before_rm = max_reg_num ();
diff --git a/gcc/lto-wrapper.cc b/gcc/lto-wrapper.cc
index d070829bacb..9fede90c277 100644
--- a/gcc/lto-wrapper.cc
+++ b/gcc/lto-wrapper.cc
@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see
    ./ccCJuXGv.lto.ltrans.o
 */
 
+#define INCLUDE_STRING
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -49,6 +50,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "lto-section-names.h"
 #include "collect-utils.h"
 #include "opts-diagnostic.h"
+#include "opt-suggestions.h"
+#include "opts-jobserver.h"
 
 /* Environment variable, used for passing the names of offload targets from GCC
    driver to lto-wrapper.  */
@@ -1336,35 +1339,6 @@ init_num_threads (void)
 #endif
 }
 
-/* Test and return reason why a jobserver cannot be detected.  */
-
-static const char *
-jobserver_active_p (void)
-{
-  #define JS_PREFIX "jobserver is not available: "
-  #define JS_NEEDLE "--jobserver-auth="
-
-  const char *makeflags = getenv ("MAKEFLAGS");
-  if (makeflags == NULL)
-    return JS_PREFIX "%<MAKEFLAGS%> environment variable is unset";
-
-  const char *n = strstr (makeflags, JS_NEEDLE);
-  if (n == NULL)
-    return JS_PREFIX "%<" JS_NEEDLE "%> is not present in %<MAKEFLAGS%>";
-
-  int rfd = -1;
-  int wfd = -1;
-
-  if (sscanf (n + strlen (JS_NEEDLE), "%d,%d", &rfd, &wfd) == 2
-      && rfd > 0
-      && wfd > 0
-      && is_valid_fd (rfd)
-      && is_valid_fd (wfd))
-    return NULL;
-  else
-    return JS_PREFIX "cannot access %<" JS_NEEDLE "%> file descriptors";
-}
-
 /* Print link to -flto documentation with a hint message.  */
 
 void
@@ -1422,7 +1396,6 @@ run_gcc (unsigned argc, char *argv[])
   bool jobserver_requested = false;
   int auto_parallel = 0;
   bool no_partition = false;
-  const char *jobserver_error = NULL;
   bool fdecoded_options_first = true;
   vec<cl_decoded_option> fdecoded_options;
   fdecoded_options.create (16);
@@ -1654,14 +1627,14 @@ run_gcc (unsigned argc, char *argv[])
     }
   else
     {
-      jobserver_error = jobserver_active_p ();
-      if (jobserver && jobserver_error != NULL)
+      jobserver_info jinfo;
+      if (jobserver && !jinfo.is_active)
 	{
 	  /* Fall back to auto parallelism.  */
 	  jobserver = 0;
 	  auto_parallel = 1;
 	}
-      else if (!jobserver && jobserver_error == NULL)
+      else if (!jobserver && jinfo.is_active)
 	{
 	  parallel = 1;
 	  jobserver = 1;
@@ -1976,9 +1949,10 @@ cont:
 
       if (nr > 1)
 	{
-	  if (jobserver_requested && jobserver_error != NULL)
+	  jobserver_info jinfo;
+	  if (jobserver_requested && !jinfo.is_active)
 	    {
-	      warning (0, jobserver_error);
+	      warning (0, jinfo.error_msg.c_str ());
 	      print_lto_docs_link ();
 	    }
 	  else if (parallel == 0)
diff --git a/gcc/lto/ChangeLog b/gcc/lto/ChangeLog
index 4805a59b044..639d861d399 100644
--- a/gcc/lto/ChangeLog
+++ b/gcc/lto/ChangeLog
@@ -1,3 +1,11 @@
+2022-10-27  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-10-27  Martin Liska  <mliska@suse.cz>
+
+	PR lto/107418
+	* lto-dump.cc (lto_main): Do not load LTO stream for aliases.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/gcc/lto/lto-dump.cc b/gcc/lto/lto-dump.cc
index 1fb3fb86fb5..7dd3ac7b96d 100644
--- a/gcc/lto/lto-dump.cc
+++ b/gcc/lto/lto-dump.cc
@@ -344,7 +344,8 @@ lto_main (void)
       /* Dump gimple statement statistics.  */
       cgraph_node *node;
       FOR_EACH_DEFINED_FUNCTION (node)
-	node->get_untransformed_body ();
+	if (!node->alias)
+	  node->get_untransformed_body ();
       if (!GATHER_STATISTICS)
 	warning_at (input_location, 0,
 		    "Not configured with "
diff --git a/gcc/omp-expand.cc b/gcc/omp-expand.cc
index 19d04a0d959..bb019ea3a18 100644
--- a/gcc/omp-expand.cc
+++ b/gcc/omp-expand.cc
@@ -10465,7 +10465,10 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,
 		case GF_OMP_TARGET_KIND_OACC_ENTER_DATA:
 		case GF_OMP_TARGET_KIND_OACC_EXIT_DATA:
 		case GF_OMP_TARGET_KIND_OACC_DECLARE:
-		  /* ..., other than for those stand-alone directives...  */
+		  /* ..., other than for those stand-alone directives...
+		     To be precise, target data isn't stand-alone, but
+		     gimplifier put the end API call into try finally block
+		     for it, so omp expansion can treat it as such.  */
 		  region = NULL;
 		  break;
 		default:
@@ -10483,6 +10486,11 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,
 		   && gimple_omp_task_taskwait_p (stmt))
 	    /* #pragma omp taskwait depend(...) is a stand-alone directive.  */
 	    region = NULL;
+	  else if (code == GIMPLE_OMP_TASKGROUP)
+	    /* #pragma omp taskgroup isn't a stand-alone directive, but
+	       gimplifier put the end API call into try finall block
+	       for it, so omp expansion can treat it as such.  */
+	    region = NULL;
 	  /* ..., this directive becomes the parent for a new region.  */
 	  if (region)
 	    parent = region;
@@ -10679,13 +10687,18 @@ omp_make_gimple_edges (basic_block bb, struct omp_region **region,
     case GIMPLE_OMP_MASTER:
     case GIMPLE_OMP_MASKED:
     case GIMPLE_OMP_SCOPE:
-    case GIMPLE_OMP_TASKGROUP:
     case GIMPLE_OMP_CRITICAL:
     case GIMPLE_OMP_SECTION:
       cur_region = new_omp_region (bb, code, cur_region);
       fallthru = true;
       break;
 
+    case GIMPLE_OMP_TASKGROUP:
+      cur_region = new_omp_region (bb, code, cur_region);
+      fallthru = true;
+      cur_region = cur_region->outer;
+      break;
+
     case GIMPLE_OMP_TASK:
       cur_region = new_omp_region (bb, code, cur_region);
       fallthru = true;
diff --git a/gcc/omp-low.cc b/gcc/omp-low.cc
index eefd9107b89..06d13a2a7c2 100644
--- a/gcc/omp-low.cc
+++ b/gcc/omp-low.cc
@@ -6152,6 +6152,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,
 		      && gimple_omp_for_combined_into_p (ctx->stmt))
 		    {
 		      tree t = OMP_CLAUSE_LINEAR_STEP (c);
+		      if (DECL_P (t))
+			t = build_outer_var_ref (t, ctx);
 		      tree stept = TREE_TYPE (t);
 		      tree ct = omp_find_clause (clauses,
 						 OMP_CLAUSE__LOOPTEMP_);
@@ -7579,6 +7581,7 @@ lower_oacc_reductions (location_t loc, tree clauses, tree level, bool inner,
 	      incoming = build_simple_mem_ref (incoming);
 	  }
 	else
+	  /* Note that 'var' might be a mem ref.  */
 	  v1 = v2 = v3 = var;
 
 	/* Determine position in reduction buffer, which may be used
@@ -7607,26 +7610,28 @@ lower_oacc_reductions (location_t loc, tree clauses, tree level, bool inner,
 	  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,
 					  TREE_TYPE (var), 6, setup_code,
 					  unshare_expr (ref_to_res),
-					  incoming, level, op, off);
+					  unshare_expr (incoming),
+					  level, op, off);
 	tree init_call
 	  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,
 					  TREE_TYPE (var), 6, init_code,
 					  unshare_expr (ref_to_res),
-					  v1, level, op, off);
+					  unshare_expr (v1), level, op, off);
 	tree fini_call
 	  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,
 					  TREE_TYPE (var), 6, fini_code,
 					  unshare_expr (ref_to_res),
-					  v2, level, op, off);
+					  unshare_expr (v2), level, op, off);
 	tree teardown_call
 	  = build_call_expr_internal_loc (loc, IFN_GOACC_REDUCTION,
 					  TREE_TYPE (var), 6, teardown_code,
-					  ref_to_res, v3, level, op, off);
+					  ref_to_res, unshare_expr (v3),
+					  level, op, off);
 
-	gimplify_assign (v1, setup_call, &before_fork);
-	gimplify_assign (v2, init_call, &after_fork);
-	gimplify_assign (v3, fini_call, &before_join);
-	gimplify_assign (outgoing, teardown_call, &after_join);
+	gimplify_assign (unshare_expr (v1), setup_call, &before_fork);
+	gimplify_assign (unshare_expr (v2), init_call, &after_fork);
+	gimplify_assign (unshare_expr (v3), fini_call, &before_join);
+	gimplify_assign (unshare_expr (outgoing), teardown_call, &after_join);
       }
 
   /* Now stitch things together.  */
@@ -9672,7 +9677,6 @@ lower_omp_taskgroup (gimple_stmt_iterator *gsi_p, omp_context *ctx)
   gimple_bind_add_seq (bind, gimple_omp_body (stmt));
   gimple_omp_set_body (stmt, NULL);
 
-  gimple_bind_add_stmt (bind, gimple_build_omp_return (true));
   gimple_bind_add_seq (bind, dseq);
 
   pop_gimplify_context (bind);
@@ -10656,6 +10660,28 @@ oacc_privatization_candidate_p (const location_t loc, const tree c,
 	}
     }
 
+  /* If an artificial variable has been added to a bind, e.g.
+     a compiler-generated temporary structure used by the Fortran front-end, do
+     not consider it as a privatization candidate.  Note that variables on
+     the stack are private per-thread by default: making them "gang-private"
+     for OpenACC actually means to share a single instance of a variable
+     amongst all workers and threads spawned within each gang.
+     At present, no compiler-generated artificial variables require such
+     sharing semantics, so this is safe.  */
+
+  if (res && block && DECL_ARTIFICIAL (decl))
+    {
+      res = false;
+
+      if (dump_enabled_p ())
+	{
+	  oacc_privatization_begin_diagnose_var (l_dump_flags, loc, c, decl);
+	  dump_printf (l_dump_flags,
+		       "isn%'t candidate for adjusting OpenACC privatization "
+		       "level: %s\n", "artificial");
+	}
+    }
+
   if (res)
     {
       if (dump_enabled_p ())
diff --git a/gcc/omp-oacc-kernels-decompose.cc b/gcc/omp-oacc-kernels-decompose.cc
index 4386787ba3c..ec9b0faab0a 100644
--- a/gcc/omp-oacc-kernels-decompose.cc
+++ b/gcc/omp-oacc-kernels-decompose.cc
@@ -239,7 +239,13 @@ visit_loops_in_gang_single_region (gimple_stmt_iterator *gsi_p,
     case GIMPLE_OMP_FOR:
       /*TODO Given the current 'adjust_region_code' algorithm, this is
 	actually...  */
+#if 0
       gcc_unreachable ();
+#else
+      /* ..., but due to bugs (PR100400), we may actually come here.
+	 Reliably catch this, regardless of checking level.  */
+      internal_error ("PR100400");
+#endif
 
       {
 	tree clauses = gimple_omp_for_clauses (stmt);
diff --git a/gcc/opts-common.cc b/gcc/opts-common.cc
index 1663be1f602..7c07d504696 100644
--- a/gcc/opts-common.cc
+++ b/gcc/opts-common.cc
@@ -17,6 +17,7 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#define INCLUDE_STRING
 #include "config.h"
 #include "system.h"
 #include "intl.h"
@@ -25,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "options.h"
 #include "diagnostic.h"
 #include "spellcheck.h"
+#include "opts-jobserver.h"
 
 static void prune_options (struct cl_decoded_option **, unsigned int *);
 
@@ -2003,3 +2005,55 @@ void prepend_xassembler_to_collect_as_options (const char *collect_as_options,
       obstack_1grow (o, '\'');
     }
 }
+
+jobserver_info::jobserver_info ()
+{
+  /* Traditionally, GNU make uses opened pipes for jobserver-auth,
+    e.g. --jobserver-auth=3,4.
+    Starting with GNU make 4.4, one can use --jobserver-style=fifo
+    and then named pipe is used: --jobserver-auth=fifo:/tmp/hcsparta.  */
+
+  /* Detect jobserver and drop it if it's not working.  */
+  string js_needle = "--jobserver-auth=";
+  string fifo_prefix = "fifo:";
+
+  const char *envval = getenv ("MAKEFLAGS");
+  if (envval != NULL)
+    {
+      string makeflags = envval;
+      size_t n = makeflags.rfind (js_needle);
+      if (n != string::npos)
+	{
+	  string ending = makeflags.substr (n + js_needle.size ());
+	  if (ending.find (fifo_prefix) == 0)
+	    {
+	      ending = ending.substr (fifo_prefix.size ());
+	      pipe_path = ending.substr (0, ending.find (' '));
+	      is_active = true;
+	    }
+	  else if (sscanf (makeflags.c_str () + n + js_needle.size (),
+			   "%d,%d", &rfd, &wfd) == 2
+	      && rfd > 0
+	      && wfd > 0
+	      && is_valid_fd (rfd)
+	      && is_valid_fd (wfd))
+	    is_active = true;
+	  else
+	    {
+	      string dup = makeflags.substr (0, n);
+	      size_t pos = makeflags.find (' ', n);
+	      if (pos != string::npos)
+		dup += makeflags.substr (pos);
+	      skipped_makeflags = "MAKEFLAGS=" + dup;
+	      error_msg
+		= "cannot access %<" + js_needle + "%> file descriptors";
+	    }
+	}
+      error_msg = "%<" + js_needle + "%> is not present in %<MAKEFLAGS%>";
+    }
+  else
+    error_msg = "%<MAKEFLAGS%> environment variable is unset";
+
+  if (!error_msg.empty ())
+    error_msg = "jobserver is not available: " + error_msg;
+}
diff --git a/gcc/opts-jobserver.h b/gcc/opts-jobserver.h
new file mode 100644
index 00000000000..98ea2579962
--- /dev/null
+++ b/gcc/opts-jobserver.h
@@ -0,0 +1,46 @@
+/* GNU make's jobserver related functionality.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.
+
+See dbgcnt.def for usage information.  */
+
+#ifndef GCC_JOBSERVER_H
+#define GCC_JOBSERVER_H
+
+using namespace std;
+
+struct jobserver_info
+{
+  /* Default constructor.  */
+  jobserver_info ();
+
+  /* Error message if there is a problem.  */
+  string error_msg = "";
+  /* Skipped MAKEFLAGS where --jobserver-auth is skipped.  */
+  string skipped_makeflags = "";
+  /* File descriptor for reading used for jobserver communication.  */
+  int rfd = -1;
+  /* File descriptor for writing used for jobserver communication.  */
+  int wfd = -1;
+  /* Named pipe path.  */
+  string pipe_path = "";
+  /* Return true if jobserver is active.  */
+  bool is_active = false;
+};
+
+#endif /* GCC_JOBSERVER_H */
diff --git a/gcc/postreload.cc b/gcc/postreload.cc
index 4a67d0d437a..f17d2f0d0e1 100644
--- a/gcc/postreload.cc
+++ b/gcc/postreload.cc
@@ -43,7 +43,6 @@ along with GCC; see the file COPYING3.  If not see
 #include "function-abi.h"
 #include "rtl-iter.h"
 
-static int reload_cse_noop_set_p (rtx);
 static bool reload_cse_simplify (rtx_insn *, rtx);
 static void reload_cse_regs_1 (void);
 static int reload_cse_simplify_set (rtx, rtx_insn *);
@@ -74,16 +73,6 @@ reload_cse_regs (rtx_insn *first ATTRIBUTE_UNUSED)
     }
 }
 
-/* See whether a single set SET is a noop.  */
-static int
-reload_cse_noop_set_p (rtx set)
-{
-  if (cselib_reg_set_mode (SET_DEST (set)) != GET_MODE (SET_DEST (set)))
-    return 0;
-
-  return rtx_equal_for_cselib_p (SET_DEST (set), SET_SRC (set));
-}
-
 /* Try to simplify INSN.  Return true if the CFG may have changed.  */
 static bool
 reload_cse_simplify (rtx_insn *insn, rtx testreg)
@@ -118,7 +107,7 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)
          this out, so it's safer to simplify before we delete.  */
       count += reload_cse_simplify_set (body, insn);
 
-      if (!count && reload_cse_noop_set_p (body))
+      if (!count && cselib_redundant_set_p (body))
 	{
 	  if (check_for_inc_dec (insn))
 	    delete_insn_and_edges (insn);
@@ -157,7 +146,7 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)
 	  rtx part = XVECEXP (body, 0, i);
 	  if (GET_CODE (part) == SET)
 	    {
-	      if (! reload_cse_noop_set_p (part))
+	      if (! cselib_redundant_set_p (part))
 		break;
 	      if (REG_P (SET_DEST (part))
 		  && REG_FUNCTION_VALUE_P (SET_DEST (part)))
diff --git a/gcc/profile.cc b/gcc/profile.cc
index a67cce5b199..40e105258fa 100644
--- a/gcc/profile.cc
+++ b/gcc/profile.cc
@@ -1457,11 +1457,13 @@ branch_prob (bool thunk)
 	  if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb)
 	    {
 	      location_t loc = DECL_SOURCE_LOCATION (current_function_decl);
-	      gcc_checking_assert (!RESERVED_LOCATION_P (loc));
-	      seen_locations.add (loc);
-	      expanded_location curr_location = expand_location (loc);
-	      output_location (&streamed_locations, curr_location.file,
-			       MAX (1, curr_location.line), &offset, bb);
+	      if (!RESERVED_LOCATION_P (loc))
+		{
+		  seen_locations.add (loc);
+		  expanded_location curr_location = expand_location (loc);
+		  output_location (&streamed_locations, curr_location.file,
+				   MAX (1, curr_location.line), &offset, bb);
+		}
 	    }
 
 	  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
diff --git a/gcc/range-op.cc b/gcc/range-op.cc
index 464a1f839fd..b5f4627fe2b 100644
--- a/gcc/range-op.cc
+++ b/gcc/range-op.cc
@@ -3230,6 +3230,9 @@ operator_bitwise_xor::op1_range (irange &r, tree type,
 	    r.set_varying (type);
 	  else if (op2.zero_p ())
 	    r = range_true (type);
+	  // See get_bool_state for the rationale
+	  else if (op2.contains_p (build_zero_cst (op2.type ())))
+	    r = range_true_and_false (type);
 	  else
 	    r = range_false (type);
 	  break;
diff --git a/gcc/reg-stack.cc b/gcc/reg-stack.cc
index 5afeadf8c49..0ee0e7648f8 100644
--- a/gcc/reg-stack.cc
+++ b/gcc/reg-stack.cc
@@ -263,14 +263,14 @@ static void swap_to_top (rtx_insn *, stack_ptr, rtx, rtx);
 static bool move_for_stack_reg (rtx_insn *, stack_ptr, rtx);
 static bool move_nan_for_stack_reg (rtx_insn *, stack_ptr, rtx);
 static int swap_rtx_condition_1 (rtx);
-static int swap_rtx_condition (rtx_insn *);
+static int swap_rtx_condition (rtx_insn *, int &);
 static void compare_for_stack_reg (rtx_insn *, stack_ptr, rtx, bool);
 static bool subst_stack_regs_pat (rtx_insn *, stack_ptr, rtx);
 static void subst_asm_stack_regs (rtx_insn *, stack_ptr);
 static bool subst_stack_regs (rtx_insn *, stack_ptr);
 static void change_stack (rtx_insn *, stack_ptr, stack_ptr, enum emit_where);
 static void print_stack (FILE *, stack_ptr);
-static rtx_insn *next_flags_user (rtx_insn *);
+static rtx_insn *next_flags_user (rtx_insn *, int &);
 
 /* Return nonzero if any stack register is mentioned somewhere within PAT.  */
 
@@ -336,7 +336,7 @@ stack_regs_mentioned (const_rtx insn)
 static rtx ix86_flags_rtx;
 
 static rtx_insn *
-next_flags_user (rtx_insn *insn)
+next_flags_user (rtx_insn *insn, int &debug_seen)
 {
   /* Search forward looking for the first use of this value.
      Stop at block boundaries.  */
@@ -346,7 +346,14 @@ next_flags_user (rtx_insn *insn)
       insn = NEXT_INSN (insn);
 
       if (INSN_P (insn) && reg_mentioned_p (ix86_flags_rtx, PATTERN (insn)))
-	return insn;
+	{
+	  if (DEBUG_INSN_P (insn) && debug_seen >= 0)
+	    {
+	      debug_seen = 1;
+	      continue;
+	    }
+	  return insn;
+	}
 
       if (CALL_P (insn))
 	return NULL;
@@ -1247,8 +1254,22 @@ swap_rtx_condition_1 (rtx pat)
   return r;
 }
 
+/* This function swaps condition in cc users and returns true
+   if successful.  It is invoked in 2 different modes, one with
+   DEBUG_SEEN set initially to 0.  In this mode, next_flags_user
+   will skip DEBUG_INSNs that it would otherwise return and just
+   sets DEBUG_SEEN to 1 in that case.  If DEBUG_SEEN is 0 at
+   the end of toplevel swap_rtx_condition which returns true,
+   it means no problematic DEBUG_INSNs were seen and all changes
+   have been applied.  If it returns true but DEBUG_SEEN is 1,
+   it means some problematic DEBUG_INSNs were seen and no changes
+   have been applied so far.  In that case one needs to call
+   swap_rtx_condition again with DEBUG_SEEN set to -1, in which
+   case it doesn't skip DEBUG_INSNs, but instead adjusts the
+   flags related condition in them or resets them as needed.  */
+
 static int
-swap_rtx_condition (rtx_insn *insn)
+swap_rtx_condition (rtx_insn *insn, int &debug_seen)
 {
   rtx pat = PATTERN (insn);
 
@@ -1258,7 +1279,7 @@ swap_rtx_condition (rtx_insn *insn)
       && REG_P (SET_DEST (pat))
       && REGNO (SET_DEST (pat)) == FLAGS_REG)
     {
-      insn = next_flags_user (insn);
+      insn = next_flags_user (insn, debug_seen);
       if (insn == NULL_RTX)
 	return 0;
       pat = PATTERN (insn);
@@ -1280,7 +1301,18 @@ swap_rtx_condition (rtx_insn *insn)
 	{
 	  insn = NEXT_INSN (insn);
 	  if (INSN_P (insn) && reg_mentioned_p (dest, insn))
-	    break;
+	    {
+	      if (DEBUG_INSN_P (insn))
+		{
+		  if (debug_seen >= 0)
+		    debug_seen = 1;
+		  else
+		    /* Reset the DEBUG insn otherwise.  */
+		    INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();
+		  continue;
+		}
+	      break;
+	    }
 	  if (CALL_P (insn))
 	    return 0;
 	}
@@ -1300,7 +1332,7 @@ swap_rtx_condition (rtx_insn *insn)
 	return 0;
 
       /* Now we are prepared to handle this.  */
-      insn = next_flags_user (insn);
+      insn = next_flags_user (insn, debug_seen);
       if (insn == NULL_RTX)
 	return 0;
       pat = PATTERN (insn);
@@ -1309,23 +1341,25 @@ swap_rtx_condition (rtx_insn *insn)
   if (swap_rtx_condition_1 (pat))
     {
       int fail = 0;
-      INSN_CODE (insn) = -1;
-      if (recog_memoized (insn) == -1)
-	fail = 1;
-      /* In case the flags don't die here, recurse to try fix
-         following user too.  */
-      else if (! dead_or_set_p (insn, ix86_flags_rtx))
+      if (DEBUG_INSN_P (insn))
+	gcc_assert (debug_seen < 0);
+      else
 	{
-	  insn = next_flags_user (insn);
-	  if (!insn || !swap_rtx_condition (insn))
+	  INSN_CODE (insn) = -1;
+	  if (recog_memoized (insn) == -1)
 	    fail = 1;
 	}
-      if (fail)
+      /* In case the flags don't die here, recurse to try fix
+	 following user too.  */
+      if (!fail && !dead_or_set_p (insn, ix86_flags_rtx))
 	{
-	  swap_rtx_condition_1 (pat);
-	  return 0;
+	  insn = next_flags_user (insn, debug_seen);
+	  if (!insn || !swap_rtx_condition (insn, debug_seen))
+	    fail = 1;
 	}
-      return 1;
+      if (fail || debug_seen == 1)
+	swap_rtx_condition_1 (pat);
+      return !fail;
     }
   return 0;
 }
@@ -1344,6 +1378,7 @@ compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack,
 {
   rtx *src1, *src2;
   rtx src1_note, src2_note;
+  int debug_seen = 0;
 
   src1 = get_true_reg (&XEXP (pat_src, 0));
   src2 = get_true_reg (&XEXP (pat_src, 1));
@@ -1353,8 +1388,17 @@ compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack,
   if ((! STACK_REG_P (*src1)
        || (STACK_REG_P (*src2)
 	   && get_hard_regnum (regstack, *src2) == FIRST_STACK_REG))
-      && swap_rtx_condition (insn))
+      && swap_rtx_condition (insn, debug_seen))
     {
+      /* If swap_rtx_condition succeeded but some debug insns
+	 were seen along the way, it has actually reverted all the
+	 changes.  Rerun swap_rtx_condition in a mode where DEBUG_ISNSs
+	 will be adjusted as well.  */
+      if (debug_seen)
+	{
+	  debug_seen = -1;
+	  swap_rtx_condition (insn, debug_seen);
+	}
       std::swap (XEXP (pat_src, 0), XEXP (pat_src, 1));
 
       src1 = get_true_reg (&XEXP (pat_src, 0));
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index a8926aad239..1395871f38a 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,868 @@
+2023-01-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/sso-17.c: New test.
+
+2023-01-11  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-12-28  Martin Liska  <mliska@suse.cz>
+
+	PR tree-optimization/108137
+	* gcc.dg/tree-ssa/pr108137.c: New test.
+
+2023-01-10  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	Backported from master:
+	2022-12-30  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	PR target/107714
+	* gcc.target/arm/mve/intrinsics/vldst24q_reg_offset.c: New test.
+
+2023-01-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2022-12-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/108140
+	* gcc.target/aarch64/acle/pr108140.c: New test.
+
+2023-01-05  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106736
+	* gcc.target/powerpc/pr106736-1.c: New test.
+	* gcc.target/powerpc/pr106736-2.c: Likewise.
+	* gcc.target/powerpc/pr106736-3.c: Likewise.
+	* gcc.target/powerpc/pr106736-4.c: Likewise.
+	* gcc.target/powerpc/pr106736-5.c: Likewise.
+
+2023-01-04  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2023-01-04  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/108282
+	* g++.dg/cpp2a/concepts-requires34.C: New test.
+
+2022-12-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-12-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108131
+	* gfortran.dg/pr103505.f90: Adjust expected patterns.
+	* gfortran.dg/pr108131.f90: New test.
+
+2022-12-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	* g++.dg/guality/guality.exp: Skip on hppa*-*-hpux*.
+	* gcc.dg/guality/guality.exp: Likewise.
+	* gfortran.dg/guality/guality.exp: Likewise.
+
+2022-12-19  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-12-15  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/100295
+	PR c++/107579
+	* g++.dg/cpp1z/constexpr-if-lambda5.C: New test.
+
+2022-12-19  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-12-15  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/108104
+	* g++.dg/template/ptrmem33.C: New test.
+
+2022-12-19  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-12-04  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/107417
+	* g++.dg/cpp2a/concepts-requires33.C: New test.
+
+2022-12-19  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-12-03  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/103081
+	* g++.dg/cpp2a/using-enum-10.C: New test.
+	* g++.dg/cpp2a/using-enum-10a.C: New test.
+
+2022-12-19  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-11-30  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/107542
+	* g++.dg/cpp2a/spaceship-sfinae2.C: New test.
+
+2022-12-19  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-12-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c/98487
+	* c-c++-common/Wsuggest-attribute-1.c: New test.
+
+2022-12-18  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2022-12-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/107872
+	* gfortran.dg/pr107872.f90: New test.
+
+2022-12-15  Sebastian Pop  <spop@amazon.com>
+
+	PR target/98776
+	* gcc.target/aarch64/pr98776.c: New.
+	* gcc.target/aarch64/pr92424-2.c: Adjust pattern.
+	* gcc.target/aarch64/pr92424-3.c: Adjust pattern.
+
+2022-12-12  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-12-12  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108055
+	* gdc.dg/torture/imports/pr108055conv.d: New.
+	* gdc.dg/torture/imports/pr108055spec.d: New.
+	* gdc.dg/torture/imports/pr108055write.d: New.
+	* gdc.dg/torture/pr108055.d: New test.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107865
+	* gfortran.dg/graphite/pr107865.f90: New testcase.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-12-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107833
+	PR tree-optimization/107839
+	* gcc.dg/torture/pr107833.c: New testcase.
+	* gcc.dg/uninit-pr107839.c: Likewise.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107686
+	* gcc.dg/pr107686.c: New testcase.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107766
+	* g++.dg/vect/pr107766.cc: New testcase.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107647
+	* gcc.target/i386/pr107647.c: New testcase.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107407
+	* gcc.dg/torture/pr107407.c: New testcase.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-12-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106868
+	* gcc.dg/Wdangling-pointer-pr106868.c: New testcase.
+
+2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108050
+	* gdc.dg/imports/pr108050/mod1.d: New.
+	* gdc.dg/imports/pr108050/mod2.d: New.
+	* gdc.dg/imports/pr108050/package.d: New.
+	* gdc.dg/pr108050.d: New test.
+
+2022-12-09  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-12-09  Martin Liska  <mliska@suse.cz>
+
+	* gcc.target/i386/builtin_target.c: Add more checks.
+
+2022-12-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backported from master:
+	2022-11-30  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* gcc.target/aarch64/mops_5.c: New test.
+	* gcc.target/aarch64/mops_6.c: Likewise.
+	* gcc.target/aarch64/mops_7.c: Likewise.
+
+2022-12-01  liuhongt  <hongtao.liu@intel.com>
+
+	* gcc.target/i386/pr107863.c: New test.
+
+2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/107592
+	* gdc.dg/pr107592.d: New test.
+
+2022-11-25  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-11-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107576
+	* gfortran.dg/null_actual_3.f90: New test.
+
+2022-11-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt100.adb: New test.
+	* gnat.dg/opt100_pkg.adb, gnat.dg/opt100_pkg.ads: New helper.
+
+2022-11-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/sso18.adb: New test.
+
+2022-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/107183
+	* gcc.dg/ubsan/pr107183.c: New test.
+
+2022-11-19  Jinyang He  <hejinyang@loongson.cn>
+
+	Backported from master:
+	2022-11-18  Jinyang He  <hejinyang@loongson.cn>
+
+	PR target/107713
+	* gcc.target/loongarch/pr107713-1.c: New test.
+	* gcc.target/loongarch/pr107713-2.c: New test.
+
+2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/104066
+	* g++.dg/cpp2a/constinit18.C: New test.
+
+2022-11-16  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-10-19  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/107206
+	* g++.dg/tree-ssa/pr107206.C: New test.
+
+2022-11-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/guality/param-6.c: New test.
+
+2022-11-08  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-10-25  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107304
+	* gcc.target/i386/pr107304.c: New test.
+
+2022-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt99.adb: New test.
+	* gnat.dg/opt99_pkg1.ads, gnat.dg/opt99_pkg1.adb: New helper.
+	* gnat.dg/opt99_pkg2.ads: Likewise.
+
+2022-11-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-11-03  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/107404
+	* g++.target/i386/pr107404.C: New test.
+
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-10-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/107358
+	* c-c++-common/pr107358.c: New test.
+
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-10-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/105774
+	* g++.dg/cpp1y/constexpr-105774.C: New test.
+
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107001
+	* c-c++-common/gomp/pr107001.c: New test.
+
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/106981
+	* c-c++-common/gomp/pr106981.c: New test.
+
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/106829
+	* g++.dg/gomp/pr106829.C: New test.
+
+2022-10-29  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-21  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100097
+	PR fortran/100098
+	* gfortran.dg/PR100097.f90: New test.
+	* gfortran.dg/PR100098.f90: New test.
+
+2022-10-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103413
+	* gfortran.dg/illegal_boz_arg_4.f90: New test.
+
+2022-10-26  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2022-10-06  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	* gcc.target/aarch64/cpunative/info_18: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_18.c: New test.
+
+2022-10-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/specs/coverage1.ads: New test.
+	* gnat.dg/specs/variant_part.ads: Minor tweak.
+	* gnat.dg/specs/weak1.ads: Add dg directive.
+
+2022-10-25  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2022-10-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* gcc.target/s390/pr106355.h: Common code for new tests.
+	* gcc.target/s390/pr106355-1.c: New test.
+	* gcc.target/s390/pr106355-2.c: New test.
+	* gcc.target/s390/pr106355-3.c: New test.
+
+2022-10-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-20  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105633
+	* gfortran.dg/pr105633.f90: New test.
+
+2022-10-21  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107323
+	* gcc.dg/tree-ssa/pr107323.c: New testcase.
+
+2022-10-20  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2022-05-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR middle-end/100400
+	* c-c++-common/goacc/kernels-decompose-pr100400-1-2.c: Specify
+	'-Wfatal-errors'.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/sve/acle/general/brka_1.c: Expect a separate
+	PTEST instruction.
+	* gcc.target/aarch64/sve/acle/general/brkb_1.c: Likewise.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/sve/acle/general/brkn_1.c: Expect separate
+	PTEST instructions.
+	* gcc.target/aarch64/sve/acle/general/brkn_2.c: New test.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/pragma_cpp_predefs_1.c: Add RCPC tests.
+
+2022-10-19  Andrew MacLeod  <amacleod@redhat.com>
+
+	PR tree-optimization/102892
+	* gcc.dg/pr102892-1.c: Remove undefined behaviour.
+
+2022-10-19  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/96072
+	* gcc.target/powerpc/pr96072.c: New test.
+
+2022-10-19  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/100645
+	* gcc.target/powerpc/pr100645.c: New test.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107254
+	* gfortran.dg/vect/pr107254.f90: New testcase.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107212
+	* gcc.dg/vect/pr107212-1.c: New testcase.
+	* gcc.dg/vect/pr107212-2.c: Likewise.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107160
+	* gcc.dg/vect/pr107160.c: New testcase.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107107
+	* gcc.dg/pr107107.c: New testcase.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-23  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106922
+	* g++.dg/torture/pr106922.C: New testcase.
+
+2022-10-17  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/106922
+	* g++.dg/tree-ssa/pr106922.C: Scan in cddce3 dump rather than
+	dce3.  Remove -fdump-tree-pre-details from dg-options.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106922
+	* gcc.dg/tree-ssa/ssa-fre-100.c: New testcase.
+	* g++.dg/tree-ssa/pr106922.C: Adjust.
+
+2022-10-13  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-10-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/106925
+	* g++.dg/cpp0x/initlist-defarg3.C: New test.
+
+2022-10-12  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/106817
+	* gfortran.dg/intent_optimize_4.f90: New test.
+
+2022-10-12  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/105012
+	* gfortran.dg/intent_out_15.f90: New test.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106934
+	* gfortran.dg/pr106934.f90: New testcase.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106922
+	* g++.dg/tree-ssa/pr106922.C: New testcase.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106892
+	* gcc.dg/torture/pr106892.c: New testcase.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-08-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105937
+	* g++.dg/uninit-pr105937.C: New testcase.
+
+2022-10-08  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100029
+	PR fortran/100040
+	* gfortran.dg/PR100029.f90: New test.
+	* gfortran.dg/PR100040.f90: New test.
+
+2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-22  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100103
+	* gfortran.dg/PR100103.f90: New test.
+
+2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-20  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100132
+	* gfortran.dg/PR100132.f90: New test.
+
+2022-09-29  Jason Merrill  <jason@redhat.com>
+
+	* g++.dg/cpp2a/cond-triv3.C: New test.
+
+2022-09-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107054
+	* gfortran.dg/pr107054.f90: New test.
+
+2022-09-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82868
+	* gfortran.dg/associate_26a.f90: New test.
+
+2022-09-29  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106985
+	* gfortran.dg/pr106985.f90: New test.
+
+2022-09-29  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-09-28  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107061
+	* gcc.target/i386/keylocker-encodekey128.c: Don't check
+	XMM4-XMM6.
+	* gcc.target/i386/keylocker-encodekey256.c: Likewise.
+
+2022-09-29  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-09-26  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR middle-end/106982
+	* c-c++-common/goacc/reduction-7.c: New test.
+	* c-c++-common/goacc/reduction-8.c: New test.
+
+2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106986
+	* gfortran.dg/pr106986.f90: New test.
+
+2022-09-22  Haochen Jiang  <haochen.jiang@intel.com>
+
+	* gcc.target/i386/amx-check.h (request_perm_xtile_data):
+	New function to check if AMX is usable and enable AMX.
+	(main): Run test if AMX is usable.
+
+2022-09-21  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-13  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/104482
+	* gcc.target/powerpc/pr104482.c: New test.
+
+2022-09-21  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-13  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	PR target/105485
+	* g++.target/powerpc/pr105485.C: New test.
+
+2022-09-19  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-09-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c/106947
+	* c-c++-common/Waddress-7.c: New test.
+
+2022-09-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106857
+	* gfortran.dg/pr106857.f90: New test.
+
+2022-09-16  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-03  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100245
+	* gfortran.dg/PR100245.f90: New test.
+
+2022-09-13  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-07  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR testsuite/106345
+	* lib/target-supports.exp (check_effective_target_powerpc_sqrt): Add
+	a function definition to avoid pedwarn about empty translation unit.
+	(check_effective_target_has_arch_pwr5): Likewise.
+	(check_effective_target_has_arch_pwr6): Likewise.
+	(check_effective_target_has_arch_pwr7): Likewise.
+	(check_effective_target_has_arch_pwr8): Likewise.
+	(check_effective_target_has_arch_pwr9): Likewise.
+	(check_effective_target_has_arch_pwr10): Likewise.
+	(check_effective_target_has_arch_ppc64): Likewise.
+	(check_effective_target_ppc_float128): Likewise.
+	(check_effective_target_ppc_float128_insns): Likewise.
+	(check_effective_target_powerpc_vsx): Likewise.
+
+2022-09-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/93259
+	* g++.dg/cpp0x/initlist-array17.C: New test.
+
+2022-09-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106893
+	PR c++/90451
+	* g++.dg/cpp1y/auto-fn65.C: New test.
+
+2022-09-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106860
+	* g++.dg/opt/pr106860.C: New testcase.
+
+2022-09-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106841
+	* g++.dg/vect/pr106841.cc: New testcase.
+
+2022-09-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106809
+	* gcc.dg/torture/pr106809.c: New testcase.
+
+2022-09-05  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-04  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100136
+	* gfortran.dg/PR100136.f90: New test.
+
+2022-09-03  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-09-01  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/101322
+	* g++.target/powerpc/pr101322.C: New test.
+
+2022-08-30  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-08-25  Tobias Burnus  <tobias@codesourcery.com>
+
+	* gfortran.dg/gomp/strictly-structured-block-4.f90: New test.
+
+2022-08-30  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-08-30  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/106759
+	* g++.dg/ext/has-builtin-1.C: New test.
+
+2022-08-30  Tamar Christina  <tamar.christina@arm.com>
+
+	Backported from master:
+	2022-08-12  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/106524
+	* gcc.target/aarch64/sve/pr106524.c: New test.
+
+2022-08-29  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-08-28  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/106017
+	* gcc.target/powerpc/pr106017.c: New test.
+
+2022-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-08-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* g++.dg/cpp2a/volatile1.C: Adjust for de-deprecation of volatile
+	compound |=, &= and ^= operations.
+	* g++.dg/cpp2a/volatile3.C: Likewise.
+	* g++.dg/cpp2a/volatile5.C: Likewise.
+
+2022-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-08-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/106590
+	* gcc.dg/torture/pr106590.c: New test.
+
+2022-08-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-08-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103694
+	* gfortran.dg/pr103694.f90: New test.
+
+2022-08-26  liuhongt  <hongtao.liu@intel.com>
+
+	* gcc.target/i386/pr106704.c: New test.
+
+2022-08-25  Chenghua Xu  <xuchenghua@loongson.cn>
+
+	Backported from master:
+	2022-08-25  Chenghua Xu  <xuchenghua@loongson.cn>
+
+	* gcc.target/loongarch/pr106459.c: New test.
+
+2022-08-24  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-08-16  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR tree-optimization/106322
+	* gcc.target/i386/pr106322.c: New test.
+	* gcc.target/powerpc/pr106322.c: New test.
+
+2022-08-24  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	Backported from master:
+	2022-08-16  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	PR target/103353
+	* gcc.target/powerpc/pr103353.c: New test.
+
+2022-08-23  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-08-17  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR fortran/106566
+	* gfortran.dg/gomp/declare-simd-6.f90: New test.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/gcc/testsuite/c-c++-common/Waddress-7.c b/gcc/testsuite/c-c++-common/Waddress-7.c
new file mode 100644
index 00000000000..179948553c5
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Waddress-7.c
@@ -0,0 +1,22 @@
+/* PR c/106947 */
+/* { dg-do compile } */
+/* { dg-options "-Waddress" } */
+
+#ifndef __cplusplus
+# define bool _Bool
+#endif
+
+#pragma GCC diagnostic ignored "-Waddress"
+int s; /* { dg-bogus "declared" } */
+bool e = &s;
+int
+main ()
+{
+  int error = 0;
+  {
+    bool e1 = &s;
+    if (!e1)
+      error = 1;
+  }
+  return error;
+}
diff --git a/gcc/testsuite/c-c++-common/Wsuggest-attribute-1.c b/gcc/testsuite/c-c++-common/Wsuggest-attribute-1.c
new file mode 100644
index 00000000000..8b5b398fb78
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wsuggest-attribute-1.c
@@ -0,0 +1,36 @@
+/* PR c/98487 */
+/* { dg-do compile { target { c || c++11 } } } */
+/* { dg-options "-Wsuggest-attribute=format" } */
+
+#include <stdarg.h>
+
+[[gnu::__format__(__printf__, 1, 2)]]
+void
+do_printf(const char * const a0, ...)
+{
+  va_list ap;
+  va_start(ap, a0);
+  __builtin_vprintf(a0, ap);
+  va_end(ap);
+}
+
+[[gnu::__format__(__scanf__, 1, 2)]]
+void
+do_scanf(const char * const a0, ...)
+{
+  va_list ap;
+  va_start(ap, a0);
+  __builtin_vscanf(a0, ap);
+  va_end(ap);
+}
+
+struct tm;
+
+[[gnu::__format__(__strftime__, 1, 0)]]
+void
+do_strftime(const char * const a0, struct tm * a1)
+{
+  char buff[256];
+  __builtin_strftime(buff, sizeof(buff), a0, a1);
+  __builtin_puts(buff);
+}
diff --git a/gcc/testsuite/c-c++-common/goacc/kernels-decompose-pr100400-1-2.c b/gcc/testsuite/c-c++-common/goacc/kernels-decompose-pr100400-1-2.c
index a643f109bf1..8b65e07c623 100644
--- a/gcc/testsuite/c-c++-common/goacc/kernels-decompose-pr100400-1-2.c
+++ b/gcc/testsuite/c-c++-common/goacc/kernels-decompose-pr100400-1-2.c
@@ -1,8 +1,8 @@
 /* { dg-additional-options "--param openacc-kernels=decompose" } */
 
-/* { dg-additional-options "-fchecking" }
-   { dg-ice TODO { c++ } }
-   { dg-prune-output "during GIMPLE pass: omp_oacc_kernels_decompose" } */
+/* Ensure consistent diagnostics, regardless of checking level:
+   { dg-additional-options -Wfatal-errors }
+   { dg-message {terminated due to -Wfatal-errors} TODO { target *-*-* } 0 } */
 
 /* { dg-additional-options "-g" } */
 /* { dg-additional-options "-O1" } so that we may get some 'GIMPLE_DEBUG's.  */
@@ -19,18 +19,16 @@ foo (void)
   /* { dg-bogus {sorry, unimplemented: 'gimple_debug' not yet supported} TODO { xfail *-*-* } .+1 } */
 #pragma acc kernels /* { dg-line l_compute1 } */
   /* { dg-note {OpenACC 'kernels' decomposition: variable 'p' in 'copy' clause requested to be made addressable} {} { target *-*-* } l_compute1 }
-     { dg-note {variable 'p' made addressable} {} { target *-*-* xfail c++ } l_compute1 } */
+     { dg-note {variable 'p' made addressable} {} { xfail *-*-* } l_compute1 } */
   /* { dg-note {variable 'c' declared in block is candidate for adjusting OpenACC privatization level} {} { xfail *-*-* } l_compute1 } */
   /* { dg-note {variable 'c\.0' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { xfail *-*-* } l_compute1 } */
   {
-    /* { dg-bogus {note: beginning 'gang-single' part in OpenACC 'kernels' region} {w/ debug} { xfail c++ } .-1 }
-       { dg-bogus {note: beginning 'gang-single' part in OpenACC 'kernels' region} {w/ debug} { xfail c } .+1 } */
     int c;
 
     /* { dg-note {beginning 'gang-single' part in OpenACC 'kernels' region} {} { xfail *-*-* } .+1 } */
     p = &c;
 
-    /* { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { xfail c++ } .+1 } */
+    /* { dg-note {parallelized loop nest in OpenACC 'kernels' region} {} { xfail *-*-* } .+1 } */
 #pragma acc loop independent /* { dg-line l_loop_c1 } */
     /* { dg-note {variable 'c\.0' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { xfail *-*-* } l_loop_c1 } */
     /* { dg-note {variable 'c' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { xfail *-*-* } l_loop_c1 }
diff --git a/gcc/testsuite/c-c++-common/goacc/reduction-7.c b/gcc/testsuite/c-c++-common/goacc/reduction-7.c
new file mode 100644
index 00000000000..482b0ab1984
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/goacc/reduction-7.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+
+/* PR middle-end/106982 */
+
+long long n = 100;
+int multiplicitive_n = 128;
+
+void test1(double *rand, double *a, double *b, double *c)
+{
+#pragma acc data copyin(a[0:10*multiplicitive_n], b[0:10*multiplicitive_n]) copyout(c[0:10])
+    {
+#pragma acc parallel loop
+        for (int i = 0; i < 10; ++i)
+        {
+        double temp = 1.0;
+#pragma acc loop vector reduction(*:temp)
+        for (int j = 0; j < multiplicitive_n; ++j)
+          temp *= a[(i * multiplicitive_n) + j] + b[(i * multiplicitive_n) + j];
+        c[i] = temp;
+        }
+    }
+}
diff --git a/gcc/testsuite/c-c++-common/goacc/reduction-8.c b/gcc/testsuite/c-c++-common/goacc/reduction-8.c
new file mode 100644
index 00000000000..2c3ed499d5b
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/goacc/reduction-8.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+
+/* PR middle-end/106982 */
+
+void test1(double *c)
+{
+    double reduced[5];
+#pragma acc parallel loop gang private(reduced)
+    for (int x = 0; x < 5; ++x)
+#pragma acc loop worker reduction(*:reduced)
+      for (int y = 0; y < 5; ++y) { }
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr106981.c b/gcc/testsuite/c-c++-common/gomp/pr106981.c
new file mode 100644
index 00000000000..a21d3c2029d
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr106981.c
@@ -0,0 +1,9 @@
+/* PR c/106981 */
+/* { dg-do compile } */
+
+void
+foo (int a, double *b, double *c, double *d, long long e)
+{
+#pragma omp atomic capture
+  c[a] = d[((int) (e / 10 + 1))] = b[a] + d[((int) e / 10 + 1)];	/* { dg-error "invalid form" } */
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr107001.c b/gcc/testsuite/c-c++-common/gomp/pr107001.c
new file mode 100644
index 00000000000..9c19d9b8745
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr107001.c
@@ -0,0 +1,14 @@
+/* PR c/107001 */
+/* { dg-do compile } */
+/* { dg-options "-O0 -fopenmp -fexceptions" } */
+/* { dg-require-effective-target exceptions } */
+
+void bar (void);
+void foo (void)
+{
+  #pragma omp taskgroup
+  {
+    #pragma omp taskgroup
+    bar ();
+  }
+}
diff --git a/gcc/testsuite/c-c++-common/pr107358.c b/gcc/testsuite/c-c++-common/pr107358.c
new file mode 100644
index 00000000000..d976da7393a
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr107358.c
@@ -0,0 +1,30 @@
+/* PR c++/107358 */
+/* { dg-do compile { target c } } */
+/* { dg-options "-O2 -fexcess-precision=standard" } */
+
+typedef float __attribute__((vector_size (4 * sizeof (float)))) A;
+typedef double __attribute__((vector_size (2 * sizeof (double)))) B;
+
+void
+foo (A *x)
+{
+  *x = *x - 124.225514990f;
+}
+
+void
+bar (A *x, float y)
+{
+  *x = *x - y;
+}
+
+void
+baz (B *x)
+{
+  *x = *x + 124.225514990f;
+}
+
+void
+qux (B *x, double y)
+{
+  *x = *x + y;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-array17.C b/gcc/testsuite/g++.dg/cpp0x/initlist-array17.C
new file mode 100644
index 00000000000..c4284a7b391
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-array17.C
@@ -0,0 +1,37 @@
+// PR c++/93259
+// { dg-do compile { target c++11 } }
+
+template <class T, class U> struct is_same;
+template <class T> struct is_same<T,T> { };
+
+using Array = int[];
+
+template <typename ...Ts>
+void bar1(Ts ...)
+{
+  auto && array = Array{ 1, 2, 3 };
+
+  is_same<int (&&)[3], decltype(array)>{}; // this fails, deduces array as int (&&) []
+}
+
+template <typename T>
+void bar2()
+{
+  auto && array = Array{ 1, 2, 3 };
+
+  is_same<int (&&)[3], decltype(array)>{};  // this fails, deduces array as int (&&) []
+}
+
+void bar3()
+{
+  auto && array = Array{ 1, 2, 3 };
+
+  is_same<int (&&)[3], decltype(array)>{}; // OK
+}
+
+int main()
+{
+  bar1<int>(1, 2, 3);
+  bar2<int>();
+  bar3();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-defarg3.C b/gcc/testsuite/g++.dg/cpp0x/initlist-defarg3.C
new file mode 100644
index 00000000000..5c3e886b306
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-defarg3.C
@@ -0,0 +1,13 @@
+// PR c++/106925
+// { dg-do compile { target c++11 } }
+
+struct Foo;
+template <int _Nm> struct __array_traits { typedef Foo _Type[_Nm]; };
+template <int _Nm> struct array {
+  typename __array_traits<_Nm>::_Type _M_elems;
+};
+template <int size> struct MyVector { array<size> data{}; };
+struct Foo {
+  float a{0};
+};
+void foo(MyVector<1> = MyVector<1>());
diff --git a/gcc/testsuite/g++.dg/cpp1y/auto-fn65.C b/gcc/testsuite/g++.dg/cpp1y/auto-fn65.C
new file mode 100644
index 00000000000..78bb004303b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/auto-fn65.C
@@ -0,0 +1,10 @@
+// PR c++/106893
+// { dg-do compile { target c++14 } }
+
+template <typename T>
+struct CoordTraits
+{
+  static auto GetX(T const &p) { return 1; }
+};
+typedef CoordTraits<int> Traits;
+static constexpr auto GetX = Traits::GetX;
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-105774.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-105774.C
new file mode 100644
index 00000000000..8ca6fce7570
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-105774.C
@@ -0,0 +1,15 @@
+// PR c++/105774
+// { dg-do compile { target c++14 } }
+
+constexpr signed char
+foo ()
+{
+#if __SCHAR_MAX__ < __INT_MAX__
+  signed char x = __SCHAR_MAX__;
+#else
+  signed char x = 0;
+#endif
+  return ++x;
+}
+
+constexpr auto a = foo ();
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda5.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda5.C
new file mode 100644
index 00000000000..d2bf0221743
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda5.C
@@ -0,0 +1,15 @@
+// PR c++/100295
+// { dg-do compile { target c++17 } }
+
+template<typename... Ts>
+void f(Ts... ts) {
+  auto lambda = [=](auto x) {
+    if constexpr (sizeof((ts+x) + ...) != 0)
+      (..., ts);
+  };
+  lambda(0);
+}
+
+int main() {
+  f(0, 'a');
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-requires33.C b/gcc/testsuite/g++.dg/cpp2a/concepts-requires33.C
new file mode 100644
index 00000000000..1ff237ac382
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-requires33.C
@@ -0,0 +1,10 @@
+// PR c++/107417
+// { dg-do compile { target c++20 } }
+
+template<class... T>
+void f() requires (requires (T x) { true; } && ...);
+
+int main() {
+  f<int>();
+  f<int, void>(); // { dg-error "no match" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-requires34.C b/gcc/testsuite/g++.dg/cpp2a/concepts-requires34.C
new file mode 100644
index 00000000000..5bbd62f6d8e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-requires34.C
@@ -0,0 +1,19 @@
+// PR c++/108282
+// { dg-do compile { target c++20 } }
+
+template<class T>
+concept TEST = requires { T::TT; };
+
+struct C { };
+
+template<class AT>
+struct B {
+  static void TT() requires TEST<AT>;
+};
+
+int main() {
+  static_assert( !TEST<C> );
+  static_assert( !TEST<B<C>> );
+
+  B<C>::TT();  // { dg-error "no match" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/cond-triv3.C b/gcc/testsuite/g++.dg/cpp2a/cond-triv3.C
new file mode 100644
index 00000000000..d0711cf2607
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/cond-triv3.C
@@ -0,0 +1,44 @@
+// { dg-do compile { target c++20 } }
+
+template<class T>
+struct X
+{
+    T first{};
+
+    X& operator=(const X&) = delete;
+    X& operator=(const X&) requires requires (T& t) { t = t; } { return *this; }
+};
+
+// C++20 std::pair<const int, int>:
+using cxx20_pair = X<const int>;
+static_assert( __is_trivially_constructible(cxx20_pair, const cxx20_pair&), "" );
+static_assert( !__is_assignable(cxx20_pair&, const cxx20_pair&), "" );
+static_assert( __is_trivially_copyable(cxx20_pair), "" );
+
+template<bool, typename, typename F> struct conditional { using type = F; };
+template<typename T, typename F> struct conditional<true, T, F> { using type = T; };
+
+struct base
+{
+    base() = default;
+    ~base() = default;
+    base(const base&) = default;
+    base& operator=(const base&) = delete;
+};
+
+struct nope;
+
+template<class T>
+struct Y : base
+{
+    T first{};
+
+    Y& operator=(typename conditional<__is_assignable(T&, const T&), const Y&, const nope&>::type)
+    { return *this; }
+};
+
+// C++17 std::pair<const int, int>:
+using cxx17_pair = Y<const int>;
+static_assert( __is_trivially_constructible(cxx17_pair, const cxx17_pair&), "" );
+static_assert( ! __is_assignable(cxx17_pair&, const cxx17_pair&), "" );
+static_assert( __is_trivially_copyable(cxx17_pair), "???" );
diff --git a/gcc/testsuite/g++.dg/cpp2a/constinit18.C b/gcc/testsuite/g++.dg/cpp2a/constinit18.C
new file mode 100644
index 00000000000..51b4f0273be
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/constinit18.C
@@ -0,0 +1,12 @@
+// PR c++/104066
+// { dg-do compile { target c++20 } }
+
+constinit void (*p)() = nullptr;
+constinit void (*pp)() = nullptr;
+void fn();
+constinit void (&r)() = fn;
+
+extern constinit long (* const syscall_reexported) (long, ...);
+
+constinit void bad (); // { dg-error ".constinit. on function return type is not allowed" }
+constinit void bad () { } // { dg-error ".constinit. on function return type is not allowed" }
diff --git a/gcc/testsuite/g++.dg/cpp2a/spaceship-sfinae2.C b/gcc/testsuite/g++.dg/cpp2a/spaceship-sfinae2.C
new file mode 100644
index 00000000000..7105a2c7f2a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/spaceship-sfinae2.C
@@ -0,0 +1,29 @@
+// PR c++/107542
+// { dg-do compile { target c++20 } }
+
+#include <compare>
+
+template<class T, class U>
+concept same_as = __is_same(T, U);
+
+template<class Lhs, class Rhs>
+concept Ord = requires(Lhs lhs, Rhs rhs) {
+  { lhs <=> rhs } -> same_as<std::strong_ordering>;
+};
+
+static_assert(Ord<int*, int*>);   // Works.
+static_assert(!Ord<int*, char*>); // ICE.
+
+template<class T>
+struct S {
+  T* p;
+};
+
+template<class T, class U>
+  requires(Ord<const T*, const U*>)
+constexpr inline auto operator<=>(const S<T>& l, const S<U>& r) noexcept {
+  return l.p <=> r.p;
+}
+
+static_assert(Ord<S<int>, S<int>>);   // Works.
+static_assert(!Ord<S<int>, S<char>>); // ICE.
diff --git a/gcc/testsuite/g++.dg/cpp2a/using-enum-10.C b/gcc/testsuite/g++.dg/cpp2a/using-enum-10.C
new file mode 100644
index 00000000000..98fe0644729
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/using-enum-10.C
@@ -0,0 +1,16 @@
+// PR c++/103081
+// { dg-do compile { target c++20 } }
+
+enum class Pig { OINK };
+
+struct Hog {
+  using enum Pig;
+  Hog(Pig) { }
+};
+
+template<int>
+void pen() {
+  Hog(Hog::OINK);
+}
+
+template void pen<0>();
diff --git a/gcc/testsuite/g++.dg/cpp2a/using-enum-10a.C b/gcc/testsuite/g++.dg/cpp2a/using-enum-10a.C
new file mode 100644
index 00000000000..daa3221b77a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/using-enum-10a.C
@@ -0,0 +1,19 @@
+// A version of using-enum-10.C where Hog is a template.
+// PR c++/103081
+// { dg-do compile { target c++20 } }
+
+enum class Pig { OINK };
+
+template<int>
+struct Hog {
+  using enum Pig;
+  Hog(Pig) { OINK; }
+};
+
+template<int N>
+void pen() {
+  Hog<1>(Hog<1>::OINK);
+  Hog<N>(Hog<N>::OINK);
+}
+
+template void pen<0>();
diff --git a/gcc/testsuite/g++.dg/cpp2a/volatile1.C b/gcc/testsuite/g++.dg/cpp2a/volatile1.C
index 7ea6b477ca2..a0264a47bc7 100644
--- a/gcc/testsuite/g++.dg/cpp2a/volatile1.C
+++ b/gcc/testsuite/g++.dg/cpp2a/volatile1.C
@@ -56,6 +56,9 @@ fn2 ()
   vi = i;
   vi = i = 42;
   i = vi = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  i = vi |= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  i = vi &= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  i = vi ^= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   &(vi = i); // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   (vi = 42, 45);
   (i = vi = 42, 10); // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
@@ -74,8 +77,9 @@ fn2 ()
   vi += i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   vi -= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   vi %= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
-  vi ^= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
-  vi |= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  vi ^= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
+  vi |= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
+  vi &= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
   vi /= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   vi = vi += 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   vi += vi = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
@@ -131,7 +135,8 @@ void raccoon ()
   volatile T t, u;
   t = 42;
   u = t = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
-  t &= 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  t += 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  t &= 42; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
 }
 
 void
diff --git a/gcc/testsuite/g++.dg/cpp2a/volatile3.C b/gcc/testsuite/g++.dg/cpp2a/volatile3.C
index f10a29756a9..58816dc3084 100644
--- a/gcc/testsuite/g++.dg/cpp2a/volatile3.C
+++ b/gcc/testsuite/g++.dg/cpp2a/volatile3.C
@@ -57,6 +57,9 @@ fn2 ()
   vi = i;
   vi = i = 42;
   i = vi = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
+  i = vi |= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" }
+  i = vi &= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" }
+  i = vi ^= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" }
   &(vi = i); // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
   (vi = 42, 45);
   (i = vi = 42, 10); // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
@@ -75,8 +78,9 @@ fn2 ()
   vi += i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
   vi -= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
   vi %= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
-  vi ^= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
-  vi |= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
+  vi ^= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
+  vi |= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
+  vi &= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
   vi /= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
   vi = vi += 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
   vi += vi = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
@@ -132,7 +136,8 @@ void raccoon ()
   volatile T t, u;
   t = 42;
   u = t = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
-  t &= 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
+  t += 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
+  t &= 42; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
 }
 
 void
diff --git a/gcc/testsuite/g++.dg/cpp2a/volatile5.C b/gcc/testsuite/g++.dg/cpp2a/volatile5.C
index 1f9d23845b4..3684be9837e 100644
--- a/gcc/testsuite/g++.dg/cpp2a/volatile5.C
+++ b/gcc/testsuite/g++.dg/cpp2a/volatile5.C
@@ -8,8 +8,8 @@ f (bool b)
 {
   (b ? x : y) = 1;
   (b ? x : y) += 1; // { dg-warning "compound assignment" "" { target c++20 } }
-  z = (b ? x : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
-  ((z = 2) ? x : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
-  (b ? (x = 2) : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
-  (b ? x : (y = 5)) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
+  z = (b ? x : y) = 1; // { dg-warning "using value of assignment" "" { target c++20 } }
+  ((z = 2) ? x : y) = 1; // { dg-warning "using value of assignment" "" { target c++20 } }
+  (b ? (x = 2) : y) = 1; // { dg-warning "using value of assignment" "" { target c++20 } }
+  (b ? x : (y = 5)) = 1; // { dg-warning "using value of assignment" "" { target c++20 } }
 }
diff --git a/gcc/testsuite/g++.dg/ext/has-builtin-1.C b/gcc/testsuite/g++.dg/ext/has-builtin-1.C
new file mode 100644
index 00000000000..d89994c30e0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/has-builtin-1.C
@@ -0,0 +1,127 @@
+// PR c++/106759
+// { dg-do compile }
+// Verify that __has_builtin gives the correct answer for C++ built-ins.
+
+#if !__has_builtin (__builtin_addressof)
+# error "__has_builtin (__builtin_addressof) failed"
+#endif
+#if !__has_builtin (__builtin_bit_cast)
+# error "__has_builtin (__builtin_bit_cast) failed"
+#endif
+#if !__has_builtin (__builtin_launder)
+# error "__has_builtin (__builtin_launder) failed"
+#endif
+#if !__has_builtin (__has_nothrow_assign)
+# error "__has_builtin (__has_nothrow_assign) failed"
+#endif
+#if !__has_builtin (__has_nothrow_constructor)
+# error "__has_builtin (__has_nothrow_constructor) failed"
+#endif
+#if !__has_builtin (__has_nothrow_copy)
+# error "__has_builtin (__has_nothrow_copy) failed"
+#endif
+#if !__has_builtin (__has_trivial_assign)
+# error "__has_builtin (__has_trivial_assign) failed"
+#endif
+#if !__has_builtin (__has_trivial_constructor)
+# error "__has_builtin (__has_trivial_constructor) failed"
+#endif
+#if !__has_builtin (__has_trivial_copy)
+# error "__has_builtin (__has_trivial_copy) failed"
+#endif
+#if !__has_builtin (__has_trivial_destructor)
+# error "__has_builtin (__has_trivial_destructor) failed"
+#endif
+#if !__has_builtin (__has_unique_object_representations)
+# error "__has_builtin (__has_unique_object_representations) failed"
+#endif
+#if !__has_builtin (__has_virtual_destructor)
+# error "__has_builtin (__has_virtual_destructor) failed"
+#endif
+#if !__has_builtin (__is_abstract)
+# error "__has_builtin (__is_abstract) failed"
+#endif
+#if !__has_builtin (__is_aggregate)
+# error "__has_builtin (__is_aggregate) failed"
+#endif
+#if !__has_builtin (__is_base_of)
+# error "__has_builtin (__is_base_of) failed"
+#endif
+#if !__has_builtin (__is_class)
+# error "__has_builtin (__is_class) failed"
+#endif
+#if !__has_builtin (__is_empty)
+# error "__has_builtin (__is_empty) failed"
+#endif
+#if !__has_builtin (__is_enum)
+# error "__has_builtin (__is_enum) failed"
+#endif
+#if !__has_builtin (__is_final)
+# error "__has_builtin (__is_final) failed"
+#endif
+#if !__has_builtin (__is_layout_compatible)
+# error "__has_builtin (__is_layout_compatible) failed"
+#endif
+#if !__has_builtin (__is_literal_type)
+# error "__has_builtin (__is_literal_type) failed"
+#endif
+#if !__has_builtin (__is_pointer_interconvertible_base_of)
+# error "__has_builtin (__is_pointer_interconvertible_base_of) failed"
+#endif
+#if !__has_builtin (__is_pod)
+# error "__has_builtin (__is_pod) failed"
+#endif
+#if !__has_builtin (__is_polymorphic)
+# error "__has_builtin (__is_polymorphic) failed"
+#endif
+#if !__has_builtin (__is_same)
+# error "__has_builtin (__is_same) failed"
+#endif
+#if !__has_builtin (__is_same_as)
+# error "__has_builtin (__is_same_as) failed"
+#endif
+#if !__has_builtin (__is_standard_layout)
+# error "__has_builtin (__is_standard_layout) failed"
+#endif
+#if !__has_builtin (__is_trivial)
+# error "__has_builtin (__is_trivial) failed"
+#endif
+#if !__has_builtin (__is_trivially_assignable)
+# error "__has_builtin (__is_trivially_assignable) failed"
+#endif
+#if !__has_builtin (__is_trivially_constructible)
+# error "__has_builtin (__is_trivially_constructible) failed"
+#endif
+#if !__has_builtin (__is_trivially_copyable)
+# error "__has_builtin (__is_trivially_copyable) failed"
+#endif
+#if !__has_builtin (__is_union)
+# error "__has_builtin (__is_union) failed"
+#endif
+#if !__has_builtin (__underlying_type)
+# error "__has_builtin (__underlying_type) failed"
+#endif
+#if !__has_builtin (__is_assignable)
+# error "__has_builtin (__is_assignable) failed"
+#endif
+#if !__has_builtin (__is_constructible)
+# error "__has_builtin (__is_constructible) failed"
+#endif
+#if !__has_builtin (__is_nothrow_assignable)
+# error "__has_builtin (__is_nothrow_assignable) failed"
+#endif
+#if !__has_builtin (__is_nothrow_constructible)
+# error "__has_builtin (__is_nothrow_constructible) failed"
+#endif
+#if !__has_builtin (__builtin_is_constant_evaluated)
+# error "__has_builtin (__builtin_is_constant_evaluated) failed"
+#endif
+#if !__has_builtin (__builtin_source_location)
+# error "__has_builtin (__builtin_source_location) failed"
+#endif
+#if !__has_builtin (__builtin_is_corresponding_member)
+# error "__has_builtin (__builtin_is_corresponding_member) failed"
+#endif
+#if !__has_builtin (__builtin_is_pointer_interconvertible_with_class)
+# error "__has_builtin (__builtin_is_pointer_interconvertible_with_class) failed"
+#endif
diff --git a/gcc/testsuite/g++.dg/gomp/pr106829.C b/gcc/testsuite/g++.dg/gomp/pr106829.C
new file mode 100644
index 00000000000..0295efb88ee
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr106829.C
@@ -0,0 +1,15 @@
+// PR c++/106829
+
+namespace std
+{
+  template <typename> class complex;
+  template <> struct complex<double> { complex (double); _Complex double d; };
+}
+struct S { void static foo (); };
+
+void
+S::foo ()
+{
+#pragma omp target
+  std::complex<double> c = 0.0;
+}
diff --git a/gcc/testsuite/g++.dg/guality/guality.exp b/gcc/testsuite/g++.dg/guality/guality.exp
index 1d5b65fef57..2d736d292e9 100644
--- a/gcc/testsuite/g++.dg/guality/guality.exp
+++ b/gcc/testsuite/g++.dg/guality/guality.exp
@@ -8,6 +8,10 @@ if { [istarget *-*-darwin*] } {
     return
 }
 
+if { [istarget hppa*-*-hpux*] } {
+    return
+}
+
 if { [istarget "powerpc-ibm-aix*"] } {
     set torture_execute_xfail "powerpc-ibm-aix*"
     return
diff --git a/gcc/testsuite/g++.dg/opt/pr106860.C b/gcc/testsuite/g++.dg/opt/pr106860.C
new file mode 100644
index 00000000000..a0209dcf9da
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr106860.C
@@ -0,0 +1,23 @@
+// { dg-do compile }
+// { dg-options "-Ofast -ftrapv -fnon-call-exceptions -fno-tree-fre" }
+
+static const int N = 12;
+int nSlip;
+
+int main ()
+{
+  int i, j, k, fdot = 0;
+  int a[N][N];
+
+  for ( i = 1; i < nSlip; i++)
+    {
+      for ( j = i+1; j < nSlip; j++)
+        {
+          for ( k = 0; k < i; k++)
+            fdot += a[i][k] * a[k][j];
+          a[i][j] = a[i][j] - fdot;
+        }
+   }
+
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/template/ptrmem33.C b/gcc/testsuite/g++.dg/template/ptrmem33.C
new file mode 100644
index 00000000000..dca741ae5e2
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/ptrmem33.C
@@ -0,0 +1,30 @@
+// PR c++/108104
+// { dg-do compile { target c++11 } }
+
+struct A {
+  void x();
+  void y();
+};
+
+enum State { On };
+
+template<State state, void (A::*)()>
+struct B {
+  static void f();
+};
+
+template<State state>
+struct B<state, nullptr> {
+  static void g();
+};
+
+template<State state>
+struct B<state, &A::y> {
+  static void h();
+};
+
+int main() {
+  B<State::On, &A::x>::f();
+  B<State::On, nullptr>::g();
+  B<State::On, &A::y>::h();
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr106922.C b/gcc/testsuite/g++.dg/torture/pr106922.C
new file mode 100644
index 00000000000..046fc6cce76
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr106922.C
@@ -0,0 +1,48 @@
+// { dg-do compile }
+// { dg-require-effective-target c++17 }
+// { dg-additional-options "-Wall" }
+// -O1 doesn't iterate VN and thus has bogus uninit diagnostics
+// { dg-skip-if "" { *-*-* } { "-O1" } { "" } }
+
+#include <vector>
+
+#include <optional>
+template <class T>
+using Optional = std::optional<T>;
+
+#include <sstream>
+
+struct MyOptionalStructWithInt {
+    int myint; /* works without this */
+    Optional<std::vector<std::string>> myoptional;
+};
+
+struct MyOptionalsStruct {
+    MyOptionalStructWithInt external1;
+    MyOptionalStructWithInt external2;
+};
+
+struct MyStruct { };
+std::ostream &operator << (std::ostream &os, const MyStruct &myStruct);
+
+std::vector<MyStruct> getMyStructs();
+
+void test()
+{
+    MyOptionalsStruct externals;
+    MyOptionalStructWithInt internal1;
+    MyOptionalStructWithInt internal2;
+
+    std::vector<MyStruct> myStructs;
+    myStructs = getMyStructs();
+
+    for (const auto& myStruct : myStructs)
+    {
+        std::stringstream address_stream;
+        address_stream << myStruct;
+        internal1.myint = internal2.myint = 0;
+        externals.external1 = internal1;
+        externals.external2 = internal2;
+        externals.external2 = internal2;
+    }
+}
diff --git a/gcc/testsuite/g++.dg/tree-ssa/pr106922.C b/gcc/testsuite/g++.dg/tree-ssa/pr106922.C
new file mode 100644
index 00000000000..2aec4975aa8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-ssa/pr106922.C
@@ -0,0 +1,90 @@
+// { dg-require-effective-target c++20 }
+// { dg-options "-O2 -fdump-tree-cddce3" }
+
+template <typename> struct __new_allocator {
+  void deallocate(int *, int) { operator delete(0); }
+};
+template <typename _Tp> using __allocator_base = __new_allocator<_Tp>;
+template <typename> struct allocator : __allocator_base<int> {
+  [[__gnu__::__always_inline__]] void deallocate(int *__p, int __n) {
+    __allocator_base<int>::deallocate(__p, __n);
+  }
+};
+template <typename> struct allocator_traits;
+template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
+  using allocator_type = allocator<_Tp>;
+  using pointer = _Tp *;
+  using size_type = int;
+  template <typename _Up> using rebind_alloc = allocator<_Up>;
+  static void deallocate(allocator_type &__a, pointer __p, size_type __n) {
+    __a.deallocate(__p, __n);
+  }
+};
+template <typename _Alloc> struct __alloc_traits : allocator_traits<_Alloc> {
+  typedef allocator_traits<_Alloc> _Base_type;
+  template <typename _Tp> struct rebind {
+    typedef _Base_type::template rebind_alloc<_Tp> other;
+  };
+};
+long _M_deallocate___n;
+struct _Vector_base {
+  typedef __alloc_traits<allocator<int>>::rebind<int>::other _Tp_alloc_type;
+  typedef __alloc_traits<_Tp_alloc_type>::pointer pointer;
+  struct _Vector_impl_data {
+    pointer _M_start;
+  };
+  struct _Vector_impl : _Tp_alloc_type, _Vector_impl_data {};
+  ~_Vector_base() { _M_deallocate(_M_impl._M_start); }
+  _Vector_impl _M_impl;
+  void _M_deallocate(pointer __p) {
+    if (__p)
+      __alloc_traits<_Tp_alloc_type>::deallocate(_M_impl, __p,
+                                                 _M_deallocate___n);
+  }
+};
+struct vector : _Vector_base {};
+struct aligned_storage {
+  int dummy_;
+  int *ptr_ref0;
+  vector &ref() {
+    vector *__trans_tmp_2;
+    void *__trans_tmp_1 = &dummy_;
+    union {
+      void *ap_pvoid;
+      vector *as_ptype;
+    } caster{__trans_tmp_1};
+    __trans_tmp_2 = caster.as_ptype;
+    return *__trans_tmp_2;
+  }
+};
+struct optional_base {
+  optional_base operator=(optional_base &) {
+    bool __trans_tmp_3 = m_initialized;
+    if (__trans_tmp_3)
+      m_initialized = false;
+    return *this;
+  }
+  ~optional_base() {
+    if (m_initialized)
+      m_storage.ref().~vector();
+  }
+  bool m_initialized;
+  aligned_storage m_storage;
+};
+struct optional : optional_base {
+  optional() : optional_base() {}
+};
+template <class> using Optional = optional;
+struct Trans_NS___cxx11_basic_stringstream {};
+void operator<<(Trans_NS___cxx11_basic_stringstream, int);
+int testfunctionfoo_myStructs[10];
+void testfunctionfoo() {
+  Optional<char> external, internal;
+  for (auto myStruct : testfunctionfoo_myStructs) {
+    Trans_NS___cxx11_basic_stringstream address_stream;
+    address_stream << myStruct;
+    external = internal;
+  }
+}
+
+// { dg-final { scan-tree-dump-not "m_initialized" "cddce3" } }
diff --git a/gcc/testsuite/g++.dg/tree-ssa/pr107206.C b/gcc/testsuite/g++.dg/tree-ssa/pr107206.C
new file mode 100644
index 00000000000..34810ad2b7b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-ssa/pr107206.C
@@ -0,0 +1,27 @@
+// { dg-do compile }
+// { dg-require-effective-target c++17 }
+// { dg-options "-O -Wuninitialized" }
+
+#include <optional>
+struct X {
+    X() = default;
+    X(X const& r) : i(r.i) {}
+    int i;
+};
+struct Y {
+    Y() : x() {}
+    X x;
+    std::optional<int> o;
+};
+struct Z {
+    Y y;
+    explicit Z(Y y) : y(y) {}
+};
+void f(Y const&);
+void test() {
+    Y const y;
+    Z z(y);
+    z.y.o = 1;
+    auto const w = z;
+    f(w.y);
+}
diff --git a/gcc/testsuite/g++.dg/uninit-pr105937.C b/gcc/testsuite/g++.dg/uninit-pr105937.C
new file mode 100644
index 00000000000..26b4f74c5e1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/uninit-pr105937.C
@@ -0,0 +1,235 @@
+// { dg-do compile }
+// { dg-require-effective-target c++17 }
+// { dg-options "-O2 -Wall" }
+
+#include <stdint.h>
+#include <optional>
+#include <string_view>
+
+using utf8 = char;
+
+enum
+{
+    FONT_SIZE_TINY = 2,
+    FONT_SIZE_SMALL = 0,
+    FONT_SIZE_MEDIUM = 1,
+    FONT_SIZE_COUNT = 3
+};
+
+constexpr const uint16_t FONT_SPRITE_GLYPH_COUNT = 224;
+
+enum class FontSpriteBase : int16_t
+{
+    MEDIUM_EXTRA_DARK = -2,
+    MEDIUM_DARK = -1,
+
+    TINY = FONT_SIZE_TINY * FONT_SPRITE_GLYPH_COUNT,
+    SMALL = FONT_SIZE_SMALL * FONT_SPRITE_GLYPH_COUNT,
+    MEDIUM = FONT_SIZE_MEDIUM * FONT_SPRITE_GLYPH_COUNT,
+};
+
+struct TTFSurface;
+
+class CodepointView
+{
+private:
+    std::string_view _str;
+
+public:
+    class iterator
+    {
+    private:
+        std::string_view _str;
+        size_t _index;
+
+    public:
+        iterator(std::string_view str, size_t index)
+            : _str(str)
+            , _index(index)
+        {
+        }
+
+        bool operator==(const iterator& rhs) const
+        {
+            return _index == rhs._index;
+        }
+        bool operator!=(const iterator& rhs) const
+        {
+            return _index != rhs._index;
+        }
+        char32_t operator*() const
+        {
+            return GetNextCodepoint(&_str[_index], nullptr);
+        }
+        iterator& operator++()
+        {
+            return *this;
+        }
+        iterator operator++(int)
+        {
+            auto result = *this;
+            if (_index < _str.size())
+            {
+                const utf8* nextch;
+                GetNextCodepoint(&_str[_index], &nextch);
+                _index = nextch - _str.data();
+            }
+            return result;
+        }
+
+        size_t GetIndex() const
+        {
+            return _index;
+        }
+
+        static char32_t GetNextCodepoint(const char* ch, const char** next);
+    };
+
+    CodepointView(std::string_view str)
+        : _str(str)
+    {
+    }
+
+    iterator begin() const
+    {
+        return iterator(_str, 0);
+    }
+
+    iterator end() const
+    {
+        return iterator(_str, _str.size());
+    }
+};
+
+struct InternalTTFFont;
+using TTF_Font = InternalTTFFont;
+struct TTFFontDescriptor
+{
+    const utf8* filename;
+    const utf8* font_name;
+    int32_t ptSize;
+    int32_t offset_x;
+    int32_t offset_y;
+    int32_t line_height;
+    int32_t hinting_threshold;
+    TTF_Font* font;
+};
+using codepoint_t = uint32_t;
+
+#define abstract = 0
+
+struct ITTF
+{
+    virtual ~ITTF() = default;
+    virtual TTFFontDescriptor* ttf_get_font_from_sprite_base(FontSpriteBase spriteBase) abstract;
+    virtual TTFSurface* ttf_surface_cache_get_or_add(TTF_Font* font, std::string_view text) abstract;
+};
+
+namespace OpenRCT2 {
+    struct IContext
+    {
+        virtual ~IContext() = default;
+
+        virtual ITTF* GetTTF() abstract;
+    };
+}
+
+static void ttf_draw_string_raw_ttf(OpenRCT2::IContext* context, std::string_view text)
+{
+    TTFFontDescriptor* fontDesc = context->GetTTF()->ttf_get_font_from_sprite_base(FontSpriteBase::MEDIUM_EXTRA_DARK);
+    if (fontDesc->font == nullptr)
+    {
+        return;
+    }
+
+    TTFSurface* surface = context->GetTTF()->ttf_surface_cache_get_or_add(fontDesc->font, text);
+    if (surface == nullptr)
+        return;
+}
+
+namespace UnicodeChar
+{
+    // Punctuation
+    constexpr char32_t leftguillemet = 0xAB;
+    constexpr char32_t rightguillemet = 0xBB;
+    constexpr char32_t german_quote_open = 0x201E;
+    constexpr char32_t quote_open = 0x201C;
+    constexpr char32_t quote_close = 0x201D;
+
+    // Dingbats
+    constexpr char32_t up = 0x25B2;
+    constexpr char32_t small_up = 0x25B4;
+    constexpr char32_t right = 0x25B6;
+    constexpr char32_t down = 0x25BC;
+    constexpr char32_t small_down = 0x25BE;
+    constexpr char32_t left = 0x25C0;
+    constexpr char32_t tick = 0x2713;
+    constexpr char32_t plus = 0x2795;
+    constexpr char32_t minus = 0x2796;
+
+    // Emoji
+    constexpr char32_t cross = 0x274C;
+    constexpr char32_t variation_selector = 0xFE0F;
+    constexpr char32_t eye = 0x1F441;
+    constexpr char32_t road = 0x1F6E3;
+    constexpr char32_t railway = 0x1F6E4;
+}; // namespace UnicodeChar
+
+
+static bool ShouldUseSpriteForCodepoint(char32_t codepoint)
+{
+    switch (codepoint)
+    {
+        case UnicodeChar::up:
+        case UnicodeChar::down:
+        case UnicodeChar::leftguillemet:
+        case UnicodeChar::tick:
+        case UnicodeChar::cross:
+        case UnicodeChar::right:
+        case UnicodeChar::rightguillemet:
+        case UnicodeChar::small_up:
+        case UnicodeChar::small_down:
+        case UnicodeChar::left:
+        case UnicodeChar::quote_open:
+        case UnicodeChar::quote_close:
+        case UnicodeChar::german_quote_open:
+        case UnicodeChar::plus:
+        case UnicodeChar::minus:
+        case UnicodeChar::variation_selector:
+        case UnicodeChar::eye:
+        case UnicodeChar::road:
+        case UnicodeChar::railway:
+            return true;
+        default:
+            return false;
+    }
+}
+
+void ttf_process_string_literal(OpenRCT2::IContext* context, std::string_view text)
+{
+    CodepointView codepoints(text);
+    std::optional<size_t> ttfRunIndex;
+    for (auto it = codepoints.begin(); it != codepoints.end(); it++)
+    {
+        auto codepoint = *it;
+        if (ShouldUseSpriteForCodepoint(codepoint))
+        {
+            if (ttfRunIndex.has_value())
+            {
+                // Draw the TTF run
+                auto len = it.GetIndex() - ttfRunIndex.value();  // { dg-bogus "may be used uninitialized" }
+                ttf_draw_string_raw_ttf(context, text.substr(ttfRunIndex.value(), len));
+                ttfRunIndex = std::nullopt;
+            }
+
+            // Draw the sprite font glyph
+        }
+        else
+        {
+            if (!ttfRunIndex.has_value())
+            {
+                ttfRunIndex = it.GetIndex();
+            }
+        }
+    }
+}
diff --git a/gcc/testsuite/g++.dg/vect/pr106841.cc b/gcc/testsuite/g++.dg/vect/pr106841.cc
new file mode 100644
index 00000000000..7458bc15a25
--- /dev/null
+++ b/gcc/testsuite/g++.dg/vect/pr106841.cc
@@ -0,0 +1,52 @@
+// { dg-do compile }
+// { dg-additional-options "-O3 -ffast-math" }
+// { dg-additional-options "-march=bdver2" { target x86_64-*-* } }
+
+struct R3 {
+  double z;
+  R3(R3 A, R3 B) : z(B.z - A.z) {}
+  double norme() { return z; }
+};
+struct TBoundaryEdge {
+  int *vertices[2];
+  int &operator[](int i) { return *vertices[i]; }
+};
+struct Mesh {
+  int vertices;
+  TBoundaryEdge *bedges;
+  int operator()(int &vv) { return &vv - &vertices; }
+  TBoundaryEdge be(int i) { return bedges[i]; }
+};
+template <typename Data> struct GenericElement {
+  typedef typename Data::V Vertex;
+  static const int nv = Data::NbOfVertices;
+  Vertex *vertices[nv];
+  double mes;
+  void set(int *iv, Vertex *v0) {
+    for (int i = 0; i < nv; ++i)
+      vertices[i] = v0 + iv[i];
+    mes = Data::mesure(vertices);
+  }
+};
+struct DataSeg3 {
+  static const int NbOfVertices = 2;
+  typedef R3 V;
+  static double mesure(V *pv[]) { return R3(*pv[0], *pv[1]).norme(); }
+};
+struct MeshS {
+  MeshS();
+};
+template <class> struct Movemesh_Op { void foo(Mesh, DataSeg3::V *) const; };
+template <> void Movemesh_Op<int>::foo(Mesh pTh, DataSeg3::V *v0) const {
+  GenericElement<DataSeg3> *bS = new GenericElement<DataSeg3>[8];
+  for (int ibe = 0; ibe < 8; ibe++) {
+    TBoundaryEdge K(pTh.be(ibe));
+    int iv[2];
+    for (int i = 0; i < 2; i++) {
+      int &__trans_tmp_2 = K[i];
+      iv[i] = pTh(__trans_tmp_2);
+    }
+    bS[ibe].set(iv, v0);
+  }
+  MeshS T_Th;
+}
diff --git a/gcc/testsuite/g++.dg/vect/pr107766.cc b/gcc/testsuite/g++.dg/vect/pr107766.cc
new file mode 100644
index 00000000000..744bcc900b0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/vect/pr107766.cc
@@ -0,0 +1,23 @@
+// { dg-do compile }
+// { dg-additional-options "-ffp-contract=off" }
+
+typedef double btScalar;
+struct btVector3 {
+  operator btScalar *() const;
+};
+double m_vec[2];
+struct btShapeMatrix {
+  double &operator[](int i) { return m_vec[i]; }
+};
+btScalar shape_function___1pxt1pz, shape_function__fac;
+struct btMiniSDF {
+  void shape_function_(btVector3 const &) const;
+};
+void btMiniSDF::shape_function_(btVector3 const &xi) const {
+  btShapeMatrix res;
+  btScalar _1m3y = 1.0 - 3.0 * xi[1], _1p3y = 1.0 + 3.0 * xi[1],
+           fact1m3y = shape_function__fac * _1m3y,
+           fact1p3y = shape_function__fac * _1p3y;
+  res[22] = fact1m3y * shape_function___1pxt1pz;
+  res[23] = fact1p3y * shape_function___1pxt1pz;
+}
diff --git a/gcc/testsuite/g++.target/i386/pr107404.C b/gcc/testsuite/g++.target/i386/pr107404.C
new file mode 100644
index 00000000000..e47d0fd779d
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/pr107404.C
@@ -0,0 +1,53 @@
+// PR target/107404
+// { dg-do run }
+// { dg-options "-O3" }
+
+unsigned long long a;
+void b(unsigned long long *f, int p2) { *f ^= p2; }
+long c;
+char e, i;
+short g, m;
+long long ab[1][25][21][22];
+unsigned long long aa[1][21][22];
+unsigned long long ae[1][25][21][21];
+long long ac[129360];
+char ad[25][1][21];
+char ah[1][25][1][21];
+short af[100];
+long max(long f, unsigned long p2) { return f < p2 ? p2 : f; }
+const int &max2(const int &f, const int &p2) { return f < p2 ? p2 : f; }
+void foo(unsigned f, unsigned p2, char l, char p4, long long n[][25][21][22],
+        unsigned long long p6[][21][22], unsigned long long u[][25][21][21]) {
+  long an;
+  for (int j = 0; j < 4; j = p2)
+    for (short k = 0; k < 7; k += 2)
+      for (short o = 0; o < (short)p2 + 21742; o = l) {
+        for (signed char p = 2; p < 9; p += p4)
+          if (p6[j][o][p])
+            for (long q(3); 4 ? n[0][k][o][0] : 0;
+                 q += p6[0][o][0] ? p6[j][0][p] : 0)
+              ac[j + q] = 5066799590;
+        for (long r(p4 - 16); r < 21; r += 4) {
+          ad[k][o][r] = max(u[j][k][o][r], f + u[j][k][o][r]);
+          long d = u[j][k][o][r];
+          an = d < p2 ? p2 : d;
+          e = ah[j][k][o][r] = an;
+          af[o * r] = i;
+        }
+        for (short s(c); s < (short)p2; s = 2)
+          for (short am(m); am; am = max2(3, p2))
+            for (long y = 0; y; y = 3)
+              for (short t(0); t < max2(g, 0);)
+                ;
+      }
+}
+int main() {
+  foo(7, 1558227751, 104, 16, ab, aa, ae);
+  for (unsigned long v = 0; v < 5; ++v)
+    for (unsigned long w = 0; w < 1; ++w)
+      for (unsigned long x = 0; x < 21; ++x)
+        b(&a, ad[v][w][x]);
+
+  if (a)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/g++.target/powerpc/pr101322.C b/gcc/testsuite/g++.target/powerpc/pr101322.C
new file mode 100644
index 00000000000..43eaf3afcd4
--- /dev/null
+++ b/gcc/testsuite/g++.target/powerpc/pr101322.C
@@ -0,0 +1,17 @@
+/* PR target/101322 */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+
+/* Verify we don't ICE on the following test cases.  */
+
+void
+foo (char *resp, char *vpp)
+{
+  __builtin_vsx_disassemble_pair (resp, (__vector_pair *) vpp);
+}
+
+void
+bar (char *resp, char *vpp)
+{
+  __builtin_mma_disassemble_acc (resp, (__vector_quad *)vpp);
+}
diff --git a/gcc/testsuite/g++.target/powerpc/pr105485.C b/gcc/testsuite/g++.target/powerpc/pr105485.C
new file mode 100644
index 00000000000..db1bd944aae
--- /dev/null
+++ b/gcc/testsuite/g++.target/powerpc/pr105485.C
@@ -0,0 +1,9 @@
+/* It's to verify no ICE here, ignore error/warning messages
+   since they are not test points here.  */
+/* { dg-excess-errors "pr105485" } */
+
+template <class> void __builtin_vec_vslv();
+typedef  __attribute__((altivec(vector__))) char T;
+T b (T c, T d) {
+    return __builtin_vec_vslv(c, d);
+}
diff --git a/gcc/testsuite/gcc.dg/Wdangling-pointer-pr106868.c b/gcc/testsuite/gcc.dg/Wdangling-pointer-pr106868.c
new file mode 100644
index 00000000000..f782a5e07a1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Wdangling-pointer-pr106868.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O -Wdangling-pointer" } */
+
+void alloc(void **p);
+void false_dangling(char **p)
+{
+  {
+    void *q;
+    alloc(&q);
+    *p = q;
+  }
+  char *a = __builtin_memcpy(*p, "", 1);
+  *a = 0; /* { dg-bogus "dangling" } */
+}
diff --git a/gcc/testsuite/gcc.dg/guality/guality.exp b/gcc/testsuite/gcc.dg/guality/guality.exp
index ba87132aef2..075bebe34e8 100644
--- a/gcc/testsuite/gcc.dg/guality/guality.exp
+++ b/gcc/testsuite/gcc.dg/guality/guality.exp
@@ -8,6 +8,10 @@ if { [istarget *-*-darwin*] } {
     return
 }
 
+if { [istarget hppa*-*-hpux*] } {
+    return
+}
+
 if { [istarget "powerpc-ibm-aix*"] } {
     set torture_execute_xfail "powerpc-ibm-aix*"
     return
diff --git a/gcc/testsuite/gcc.dg/guality/param-6.c b/gcc/testsuite/gcc.dg/guality/param-6.c
new file mode 100644
index 00000000000..9c4ba5cb46a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/guality/param-6.c
@@ -0,0 +1,20 @@
+/* { dg-do run { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-g" } */
+
+void __attribute__((noipa)) bar (void *p)
+{}
+
+void __attribute__((noipa)) foo (int i)
+{
+  void *p = __builtin_alloca (i);
+
+  asm volatile ("" : : : "ebx");
+
+  bar (p); /* { dg-final { gdb-test . "i" "5" } } */
+}
+
+int main (void)
+{
+  foo (5);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr102892-1.c b/gcc/testsuite/gcc.dg/pr102892-1.c
index a9302b536df..051d09016f6 100644
--- a/gcc/testsuite/gcc.dg/pr102892-1.c
+++ b/gcc/testsuite/gcc.dg/pr102892-1.c
@@ -11,7 +11,7 @@ int
 main ()
 {
   long c = 0;
-  for (long a; a < 1; ++a)
+  for (long a = 0; a < 1; ++a)
     for (; c <= 1; c++) {
       bar();
       if (1 == b[c][0])
diff --git a/gcc/testsuite/gcc.dg/pr107107.c b/gcc/testsuite/gcc.dg/pr107107.c
new file mode 100644
index 00000000000..5ad6a63159e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr107107.c
@@ -0,0 +1,25 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ftree-tail-merge" } */
+
+static inline void set_longish(int is_long_long, void *p, long x)
+{
+  if (is_long_long)
+    *(long long*)p = x;
+  else
+    *(long*)p = x;
+}
+static long test(long long *p, int index, int mode)
+{
+  *p = 1;
+  set_longish(mode, p+index, 2);
+  return *p;
+}
+long (*volatile vtest)(long long*, int, int) = test;
+int main(void)
+{
+  long long x;
+  long result = vtest(&x, 0, 1);
+  if (result != 2 || x != 2)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr107686.c b/gcc/testsuite/gcc.dg/pr107686.c
new file mode 100644
index 00000000000..2378103c555
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr107686.c
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { dfp && longlong64 } } } */
+/* { dg-options "-O" } */
+/* { dg-additional-options "-mavx2" { target x86_64-*-* i?86-*-* } } */
+
+typedef _Decimal64 __attribute__((__vector_size__ (64))) D;
+typedef __INT32_TYPE__ __attribute__((__vector_size__ (32))) U;
+typedef __INT64_TYPE__ __attribute__((__vector_size__ (64))) V;
+
+U u;
+D d;
+
+void
+foo (void)
+{
+  d = d < (D) __builtin_convertvector (u, V);
+}
diff --git a/gcc/testsuite/gcc.dg/sso-17.c b/gcc/testsuite/gcc.dg/sso-17.c
new file mode 100644
index 00000000000..67e2d3793fd
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/sso-17.c
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+#define REV_ENDIANNESS __attribute__((scalar_storage_order("big-endian")))
+#else
+#define REV_ENDIANNESS __attribute__((scalar_storage_order("little-endian")))
+#endif
+
+typedef unsigned long long u64;
+
+union DST {
+  u64 val;
+
+  struct {
+    u64 x : 1;
+    u64 y : 1;
+    u64 r: 62;
+  } REV_ENDIANNESS;
+} REV_ENDIANNESS;
+
+
+struct SRC {
+  u64 a;
+} REV_ENDIANNESS;
+
+[[gnu::noipa]]
+void foo () {__builtin_abort();}
+
+[[gnu::noinline]]
+int bar(struct SRC *src)
+{
+  union DST dst;
+  
+  dst.val = src->a;
+
+  if (dst.y) {
+    foo();
+  }
+  return 0;
+}
+
+int main(void)
+{
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+  struct SRC t = {-1ull & (~(0x01ull<<62))};
+#else
+  struct SRC t = {-1ull & (~(0x01ull<<1))};
+#endif
+  bar(&t);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr106590.c b/gcc/testsuite/gcc.dg/torture/pr106590.c
new file mode 100644
index 00000000000..b7b84720148
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr106590.c
@@ -0,0 +1,75 @@
+/* PR rtl-optimization/106590 } */
+/* { dg-do run } */
+/* { dg-additional-options "-mtune=skylake" { target { i?86-*-* x86_64-*-* } } } */
+
+typedef struct A { short a; } A;
+typedef A *B;
+typedef struct C { int c, d; } C;
+typedef C *D;
+
+B
+foo (void)
+{
+  static A r = { .a = 1 };
+  return &r;
+}
+
+D
+bar (void)
+{
+  static C r = { .c = 1, .d = 23 };
+  return &r;
+}
+
+static inline int __attribute__((always_inline))
+baz (short a)
+{
+  int e = 1, f;
+  short g;
+  D h;
+
+  switch (a)
+    {
+    case 1:
+      f = 23;
+      g = 1;
+      break;
+    case 2:
+      f = 20;
+      g = 2;
+      break;
+    }
+
+  h = bar ();
+
+  if (h->d != f || h->c != g)
+    __builtin_abort ();
+  return e;
+}
+
+int
+qux (void)
+{
+  B i = foo ();
+  int e = 1;
+
+  switch (i->a)
+    {
+    case 1:
+    case 2:
+      e = baz (i->a);
+      break;
+    case 3:
+      e = 0;
+      break;
+    }
+
+  return e;
+}
+
+int
+main ()
+{
+  qux ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr106809.c b/gcc/testsuite/gcc.dg/torture/pr106809.c
new file mode 100644
index 00000000000..11e158185cf
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr106809.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-Wuninitialized" } */
+
+int foo (int x, int *val)
+{
+  switch (x)
+    {
+#define C(n) \
+    case n + 0: return *val; \
+    case n + 1: return *val; \
+    case n + 2: return *val; \
+    case n + 3: return *val; \
+    case n + 4: return *val; \
+    case n + 5: return *val; \
+    case n + 6: return *val; \
+    case n + 7: return *val; \
+    case n + 8: return *val; \
+    case n + 9: return *val;
+#define C1(n) \
+    C(n+00) C(n+10) C(n+20) C(n+30) C(n+40) \
+    C(n+50) C(n+60) C(n+70) C(n+80) C(n+90)
+#define C10(n) \
+    C1(n+000) C1(n+100) C1(n+200) C1(n+300) C1(n+400) \
+    C1(n+500) C1(n+600) C1(n+700) C1(n+800) C1(n+900)
+    C10(1000)
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr106892.c b/gcc/testsuite/gcc.dg/torture/pr106892.c
new file mode 100644
index 00000000000..73a66a037b7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr106892.c
@@ -0,0 +1,30 @@
+/* { dg-do run } */
+
+int a, b, c, d, e;
+int f[8];
+static int g() {
+  while (a)
+    a >>= 4;
+  return 0;
+}
+static int h(int i) {
+  if (i >= '0')
+    return i - '0';
+  //__builtin_unreachable ();
+}
+void __attribute__((noipa)) j(int i) {
+  for (b = 2; g() <= 7; b++)
+    if (i) {
+      for (; e <= 7; e++)
+        for (c = 1; c <= 7; c++) {
+          d = h(b + '0');
+          f[-d + 4] ^= 3;
+        }
+      return;
+    }
+}
+int main() {
+  j(1);
+  if (f[2] != 0)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr107407.c b/gcc/testsuite/gcc.dg/torture/pr107407.c
new file mode 100644
index 00000000000..228fce1e699
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr107407.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+
+int *a;
+int c[4];
+int d;
+
+static int
+f(char k, int j)
+{
+  for (; k <= 3; k++)
+    {
+      a = &c[k];
+      for (; d <= 1; d++)
+        *a = 3;
+    }
+  *a = 0;
+}
+
+int main()
+{
+  int i;
+  f(0, 0);
+  if (c[0] != 3)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr107833.c b/gcc/testsuite/gcc.dg/torture/pr107833.c
new file mode 100644
index 00000000000..0edf7c328ba
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr107833.c
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+int a, b[1] = { 0 }, c, *d = b, e, *f, g;
+
+__attribute__((noipa)) int
+foo (const char *x)
+{
+  (void) x;
+  return 0;
+}
+
+int
+main ()
+{
+  for (int h = 0; a < 2; a++)
+    {
+      int i;
+      for (g = 0; g < 2; g++)
+	if (a < h)
+	  {
+	    e = i % 2;
+	    c = *f;
+	  }
+      for (h = 0; h < 3; h++)
+	{
+	  if (d)
+	    break;
+	  i--;
+	  foo ("0");
+	}
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr107323.c b/gcc/testsuite/gcc.dg/tree-ssa/pr107323.c
new file mode 100644
index 00000000000..1204b6e36d5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr107323.c
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-vectorize" } */
+
+int A[4];
+int B[4];
+
+static const char *__attribute__((noipa)) foo()
+{
+  return "1";
+}
+
+int main()
+{
+  const char *s = foo();
+
+  A[0] = 1000;
+  for(int i = 1; i < 4; ++i) {
+      B[i] = 0;
+      A[i] = 0;
+      if(s[0])
+	B[i] = 1;
+      A[i] = A[i - 1];
+  }
+
+  if (A[3] != 1000)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr108137.c b/gcc/testsuite/gcc.dg/tree-ssa/pr108137.c
new file mode 100644
index 00000000000..f0cb71b2267
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr108137.c
@@ -0,0 +1,8 @@
+// PR tree-optimization/108137
+// { dg-do compile }
+// { dg-options "-Wformat-overflow" }
+
+void f(unsigned short x_port, unsigned int x_host)
+{
+    __builtin_printf("missing %s", x_port ? "host" : &"host:port"[x_host ? 5 : 0]);
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-100.c b/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-100.c
new file mode 100644
index 00000000000..ead76548f3d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-100.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-fre1" } */
+
+float bar, baz;
+void foo (int *p, int n)
+{
+  *p = 0;
+  do
+    {
+      bar = 1.;
+      /* When iterating we should have optimistically value-numbered
+	 *p to zero, on the second iteration we have to prove the
+	 store below does not affect the value of this load though.
+	 We can compare the stored value against the value from the
+	 previous iteration instead relying on a non-walking lookup.  */
+      if (*p)
+        {
+          baz = 2.;
+          *p = 0;
+        }
+    }
+  while (--n);
+}
+
+/* { dg-final { scan-tree-dump-not "baz" "fre1" } } */
diff --git a/gcc/testsuite/gcc.dg/ubsan/pr107183.c b/gcc/testsuite/gcc.dg/ubsan/pr107183.c
new file mode 100644
index 00000000000..e54a361c7c9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ubsan/pr107183.c
@@ -0,0 +1,12 @@
+/* PR target/107183 */
+/* { dg-do compile } */
+/* { dg-options "-O -fsanitize=float-cast-overflow -fcompare-debug" } */
+
+long double a, b, c;
+
+int
+foo (void)
+{
+  unsigned u = b || __builtin_rintl (c);
+  return u + (unsigned) a;
+}
diff --git a/gcc/testsuite/gcc.dg/uninit-pr107839.c b/gcc/testsuite/gcc.dg/uninit-pr107839.c
new file mode 100644
index 00000000000..c2edcfaee22
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/uninit-pr107839.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wuninitialized" } */
+
+int f (int);
+void g (int c)
+{
+  int v;
+  if (c)
+    v = f(0);
+  while (1)
+    if (c)
+      f(v + v); /* { dg-bogus "uninitialized" } */ 
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr107160.c b/gcc/testsuite/gcc.dg/vect/pr107160.c
new file mode 100644
index 00000000000..4f9f853cafb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr107160.c
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+
+#include <math.h>
+
+#define N 128
+float fl[N];
+
+__attribute__ ((noipa)) void
+init ()
+{
+  for (int i = 0; i < N; i++)
+    fl[i] = i;
+}
+
+__attribute__ ((noipa)) float
+foo (int n1)
+{
+  float sum0, sum1, sum2, sum3;
+  sum0 = sum1 = sum2 = sum3 = 0.0f;
+
+  int n = (n1 / 4) * 4;
+  for (int i = 0; i < n; i += 4)
+    {
+      sum0 += fabs (fl[i]);
+      sum1 += fabs (fl[i + 1]);
+      sum2 += fabs (fl[i + 2]);
+      sum3 += fabs (fl[i + 3]);
+    }
+
+  return sum0 + sum1 + sum2 + sum3;
+}
+
+int
+main ()
+{
+  init ();
+  float res = foo (80);
+  if (res != 3160)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr107212-1.c b/gcc/testsuite/gcc.dg/vect/pr107212-1.c
new file mode 100644
index 00000000000..5343f9b6b23
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr107212-1.c
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+int main()
+{
+  check_vect ();
+
+  unsigned int tab[6][2] = { {69, 73}, {36, 40}, {24, 16},
+        {16, 11}, {4, 5}, {3, 1} };
+
+  int sum_0 = 0;
+  int sum_1 = 0;
+
+  for(int t=0; t<6; t++) {
+      sum_0 += tab[t][0];
+      sum_1 += tab[t][1];
+  }
+
+  int x1 = (sum_0 < 100);
+  int x2 = (sum_0 > 200);
+
+  if (x1 || x2 || sum_1 != 146)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr107212-2.c b/gcc/testsuite/gcc.dg/vect/pr107212-2.c
new file mode 100644
index 00000000000..109c2b991a6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr107212-2.c
@@ -0,0 +1,23 @@
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+int sum_1 = 0;
+
+int main()
+{
+  check_vect ();
+
+  unsigned int tab[6][2] = {{150, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}};
+  
+  int sum_0 = 0;
+  
+  for (int t = 0; t < 6; t++) {
+    sum_0 += tab[t][0];
+    sum_1 += tab[t][0];
+  }
+  
+  if (sum_0 < 100 || sum_0 > 200)
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/acle/pr108140.c b/gcc/testsuite/gcc.target/aarch64/acle/pr108140.c
new file mode 100644
index 00000000000..967928a7dca
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/acle/pr108140.c
@@ -0,0 +1,15 @@
+/* PR target/108140  */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include<arm_acle.h>
+
+int
+main(int argc, char *argv[])
+{
+	unsigned long long input = argc-1;
+	unsigned long long v = __clz(__rbit(input));
+	__builtin_printf("%d %d\n", argc, v >= 64 ? 123 : 456);
+	return 0;
+}
+
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_18 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_18
new file mode 100644
index 00000000000..25061a4abe8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_18
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 2000.00
+Features	: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma lrcpc dcpop sha3 asimddp sha512 asimdfhm dit uscat ilrcpc flagm ssbs sb dcpodp flagm2 frint i8mm bf16 rng ecv
+CPU implementer	: 0xc0
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xac3
+CPU revision	: 0
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_18.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_18.c
new file mode 100644
index 00000000000..b5f0a3005f5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_18.c
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_18" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8.6-a\+crc\+fp16\+aes\+sha3\+rng} } } */
+
+/* Test one where the boundary of buffer size would overwrite the last
+   character read when stitching the fgets-calls together.  With the
+   test data provided, this would truncate the 'sha512' into 'ha512'
+   (dropping the 'sha3' feature). */
diff --git a/gcc/testsuite/gcc.target/aarch64/mops_5.c b/gcc/testsuite/gcc.target/aarch64/mops_5.c
new file mode 100644
index 00000000000..8a2626786eb
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/mops_5.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8.6-a+mops" } */
+
+#include <stddef.h>
+
+void g();
+void foo (int a, size_t N, char *__restrict__ in,
+         char *__restrict__ out)
+{
+  if (a != 3)
+    __builtin_memcpy (out, in, N);
+  if (a > 3)
+    g ();
+}
+
+/* { dg-final { scan-assembler-times {cmp\tw0, *} 2 } } */
+
diff --git a/gcc/testsuite/gcc.target/aarch64/mops_6.c b/gcc/testsuite/gcc.target/aarch64/mops_6.c
new file mode 100644
index 00000000000..c6c9a548351
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/mops_6.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8.6-a+mops" } */
+
+#include <stddef.h>
+
+void g();
+void foo (int a, size_t N, char *__restrict__ in,
+         char *__restrict__ out)
+{
+  if (a != 3)
+    __builtin_memmove (out, in, N);
+  if (a > 3)
+    g ();
+}
+
+/* { dg-final { scan-assembler-times {cmp\tw0, *} 2 } } */
+
diff --git a/gcc/testsuite/gcc.target/aarch64/mops_7.c b/gcc/testsuite/gcc.target/aarch64/mops_7.c
new file mode 100644
index 00000000000..79720ca164c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/mops_7.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8.6-a+mops" } */
+
+#include <stddef.h>
+
+void g();
+void foo (int a, size_t N, char *__restrict__ out)
+{
+  if (a != 3)
+    __builtin_memset (out, 0, N);
+  if (a > 3)
+    g ();
+}
+
+/* { dg-final { scan-assembler-times {cmp\tw0, *} 2 } } */
+
diff --git a/gcc/testsuite/gcc.target/aarch64/pr92424-2.c b/gcc/testsuite/gcc.target/aarch64/pr92424-2.c
index 0e75657a153..86bb92e6f32 100644
--- a/gcc/testsuite/gcc.target/aarch64/pr92424-2.c
+++ b/gcc/testsuite/gcc.target/aarch64/pr92424-2.c
@@ -9,4 +9,4 @@ __attribute__ ((target("branch-protection=bti"),
 f10_bti ()
 {
 }
-/* { dg-final { scan-assembler "f10_bti:\n\thint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\tret\n" } } */
+/* { dg-final { scan-assembler "hint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\tret\n" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/pr92424-3.c b/gcc/testsuite/gcc.target/aarch64/pr92424-3.c
index 0a1f74d4096..daac2faf18e 100644
--- a/gcc/testsuite/gcc.target/aarch64/pr92424-3.c
+++ b/gcc/testsuite/gcc.target/aarch64/pr92424-3.c
@@ -9,4 +9,4 @@ __attribute__ ((target("branch-protection=bti+pac-ret+leaf"),
 f10_pac ()
 {
 }
-/* { dg-final { scan-assembler "f10_pac:\n\thint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\thint\t25 // paciasp\n.*\thint\t29 // autiasp\n.*\tret\n" } } */
+/* { dg-final { scan-assembler "hint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\thint\t25 // paciasp\n.*\thint\t29 // autiasp\n.*\tret\n" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/pr98776.c b/gcc/testsuite/gcc.target/aarch64/pr98776.c
new file mode 100644
index 00000000000..d193df8e66d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr98776.c
@@ -0,0 +1,11 @@
+/* { dg-do "compile" } */
+/* { dg-options "-O1 -fpatchable-function-entry=1 -fasynchronous-unwind-tables" } */
+
+/* Test the placement of the .LPFE1 label.  */
+
+void
+foo (void)
+{
+}
+
+/* { dg-final { scan-assembler "\t\.cfi_startproc\n.*\.LPFE1:\n\tnop\n\tret\n" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c b/gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c
index bfb044f5d14..307fa3d67da 100644
--- a/gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c
@@ -248,6 +248,26 @@
 #error "__ARM_FEATURE_CRC32 is not defined but should be!"
 #endif
 
+#pragma GCC target ("arch=armv8.2-a")
+#ifdef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is defined but should not be!"
+#endif
+
+#pragma GCC target ("arch=armv8.2-a+rcpc")
+#ifndef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is not defined but should be!"
+#endif
+
+#pragma GCC target ("+norcpc")
+#ifdef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is defined but should not be!"
+#endif
+
+#pragma GCC target ("arch=armv8.3-a")
+#ifndef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is not defined but should be!"
+#endif
+
 int
 foo (int a)
 {
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_1.c b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_1.c
index 24aa8f317c4..6146ef82849 100644
--- a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_1.c
@@ -18,5 +18,6 @@ test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
   return svptest_any (pg, res);
 }
 
-/* { dg-final { scan-assembler-times {\tbrkas\tp[0-9]+\.b, p[0-9]+/m,} 2 } } */
-/* { dg-final { scan-assembler-not {\tbrka\t} } } */
+/* { dg-final { scan-assembler-times {\tbrka\t} 2 } } */
+/* { dg-final { scan-assembler-times {\tptest\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkas\t} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_1.c b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_1.c
index 07e3622ed6a..7f1c75837de 100644
--- a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_1.c
@@ -18,5 +18,6 @@ test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
   return svptest_any (pg, res);
 }
 
-/* { dg-final { scan-assembler-times {\tbrkbs\tp[0-9]+\.b, p[0-9]+/m,} 2 } } */
-/* { dg-final { scan-assembler-not {\tbrkb\t} } } */
+/* { dg-final { scan-assembler-times {\tbrkb\t} 2 } } */
+/* { dg-final { scan-assembler-times {\tptest\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkbs\t} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_1.c b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_1.c
index 7fd9318c13f..c548810f169 100644
--- a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_1.c
@@ -18,5 +18,6 @@ test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
   return svptest_any (pg, res);
 }
 
-/* { dg-final { scan-assembler-times {\tbrkns\t} 2 } } */
-/* { dg-final { scan-assembler-not {\tbrkn\t} } } */
+/* { dg-final { scan-assembler-times {\tbrkn\t} 2 } } */
+/* { dg-final { scan-assembler-times {\tptest\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkns\t} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_2.c b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_2.c
new file mode 100644
index 00000000000..74b6927410a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_2.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include <arm_sve.h>
+
+void
+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)
+{
+  svbool_t res = svbrkn_z (pg, x, y);
+  *any = svptest_any (svptrue_b8 (), res);
+  *ptr = res;
+}
+
+int
+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
+{
+  svbool_t res = svbrkn_z (pg, x, y);
+  return svptest_any (svptrue_b8 (), res);
+}
+
+/* { dg-final { scan-assembler-times {\tbrkns\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkn\t} } } */
+/* { dg-final { scan-assembler-not {\tptest\t} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr106524.c b/gcc/testsuite/gcc.target/aarch64/sve/pr106524.c
new file mode 100644
index 00000000000..a9f650f971a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr106524.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+sve -O2 -fno-move-loop-invariants" } */
+
+void
+test__zero (int *restrict dest, int *restrict src, float *a, int count)
+{
+  int i;
+
+  for (i = 0; i < count; ++i)
+    dest[i] = !__builtin_isunordered (a[i], 0) ? src[i] : 0;
+}
diff --git a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldst24q_reg_offset.c b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldst24q_reg_offset.c
new file mode 100644
index 00000000000..d028b91e81a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldst24q_reg_offset.c
@@ -0,0 +1,300 @@
+/* { dg-require-effective-target arm_v8_1m_mve_ok } */
+/* { dg-add-options arm_v8_1m_mve } */
+/* { dg-additional-options "-O1" } */
+/* { dg-final { check-function-bodies "**" "" } } */
+
+#include "arm_mve.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+**test:
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test(const uint8_t * in, uint8_t * out, int width)
+{
+  uint8x16x2_t rg = vld2q(in);
+  uint8x16x2_t gb = vld2q(in + width);
+  vst2q (out, rg);
+  vst2q (out + width, gb);
+}
+
+/*
+**test2:
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]!
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]!
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test2(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x2_t rg = vld2q(in);
+  uint8x16x2_t gb = vld2q(in + 32);
+  vst2q (out, rg);
+  vst2q (out + 32, gb);
+}
+
+/*
+**test3:
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test3(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x2_t rg = vld2q(in);
+  uint8x16x2_t gb = vld2q(in - 32);
+  vst2q (out, rg);
+  vst2q (out - 32, gb);
+}
+
+/*
+**test4:
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test4(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x2_t rg = vld2q(in);
+  uint8x16x2_t gb = vld2q(in + 64);
+  vst2q (out, rg);
+  vst2q (out + 64, gb);
+}
+
+/*
+**test5:
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test5(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x2_t rg = vld2q(in);
+  uint8x16x2_t gb = vld2q(in + 42);
+  vst2q (out, rg);
+  vst2q (out + 42, gb);
+}
+
+/*
+**test6:
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test6(const uint8_t * in, uint8_t * out, int width)
+{
+  uint8x16x4_t rg = vld4q(in);
+  uint8x16x4_t gb = vld4q(in + width);
+  vst4q (out, rg);
+  vst4q (out + width, gb);
+}
+
+/*
+**test7:
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test7(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x4_t rg = vld4q(in);
+  uint8x16x4_t gb = vld4q(in + 32);
+  vst4q (out, rg);
+  vst4q (out + 32, gb);
+}
+
+/*
+**test8:
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]!
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]!
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test8(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x4_t rg = vld4q(in);
+  uint8x16x4_t gb = vld4q(in + 64);
+  vst4q (out, rg);
+  vst4q (out + 64, gb);
+}
+
+/*
+**test9:
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test9(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x4_t rg = vld4q(in);
+  uint8x16x4_t gb = vld4q(in - 64);
+  vst4q (out, rg);
+  vst4q (out - 64, gb);
+}
+
+/*
+**test10:
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test10(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x4_t rg = vld4q(in);
+  uint8x16x4_t gb = vld4q(in + 42);
+  vst4q (out, rg);
+  vst4q (out + 42, gb);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/* { dg-final { scan-assembler-not "__ARM_undef" } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/i386/amx-check.h b/gcc/testsuite/gcc.target/i386/amx-check.h
index 434b0e59703..6fff5ff4631 100644
--- a/gcc/testsuite/gcc.target/i386/amx-check.h
+++ b/gcc/testsuite/gcc.target/i386/amx-check.h
@@ -4,11 +4,24 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdint.h>
+#include <unistd.h>
+#ifdef __linux__
+#include <sys/syscall.h>
+#endif
 #ifdef DEBUG
 #include <stdio.h>
 #endif
 #include "cpuid.h"
 
+#define XFEATURE_XTILECFG	17
+#define XFEATURE_XTILEDATA	18
+#define XFEATURE_MASK_XTILECFG	(1 << XFEATURE_XTILECFG)
+#define XFEATURE_MASK_XTILEDATA	(1 << XFEATURE_XTILEDATA)
+#define XFEATURE_MASK_XTILE	(XFEATURE_MASK_XTILECFG | XFEATURE_MASK_XTILEDATA)
+
+#define ARCH_GET_XCOMP_PERM	0x1022
+#define ARCH_REQ_XCOMP_PERM	0x1023
+
 /* TODO: The tmm emulation is temporary for current
    AMX implementation with no tmm regclass, should
    be changed in the future. */
@@ -44,6 +57,20 @@ typedef struct __tile
 /* Stride (colum width in byte) used for tileload/store */
 #define _STRIDE 64
 
+#ifdef __linux__
+/* We need syscall to use amx functions */
+int request_perm_xtile_data()
+{
+  unsigned long bitmask;
+
+  if (syscall (SYS_arch_prctl, ARCH_REQ_XCOMP_PERM, XFEATURE_XTILEDATA) ||
+      syscall (SYS_arch_prctl, ARCH_GET_XCOMP_PERM, &bitmask))
+    return 0;
+
+  return (bitmask & XFEATURE_MASK_XTILE) != 0;
+}
+#endif
+
 /* Initialize tile config by setting all tmm size to 16x64 */
 void init_tile_config (__tilecfg_u *dst)
 {
@@ -185,6 +212,9 @@ main ()
 #endif
 #ifdef AMX_BF16
       && __builtin_cpu_supports ("amx-bf16")
+#endif
+#ifdef __linux__
+      && request_perm_xtile_data ()
 #endif
       )
     {
diff --git a/gcc/testsuite/gcc.target/i386/builtin_target.c b/gcc/testsuite/gcc.target/i386/builtin_target.c
index 3e7505a8c3a..fff643c13b0 100644
--- a/gcc/testsuite/gcc.target/i386/builtin_target.c
+++ b/gcc/testsuite/gcc.target/i386/builtin_target.c
@@ -95,6 +95,11 @@ quick_check ()
 
   assert (__builtin_cpu_supports ("avx512vpopcntdq") >= 0);
 
+  assert (__builtin_cpu_supports ("x86-64") >= 0);
+  assert (__builtin_cpu_supports ("x86-64-v2") >= 0);
+  assert (__builtin_cpu_supports ("x86-64-v3") >= 0);
+  assert (__builtin_cpu_supports ("x86-64-v4") >= 0);
+
   /* Check CPU type.  */
   assert (__builtin_cpu_is ("amd") >= 0);
 
diff --git a/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c b/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c
index 805e0628673..57fa9bdc831 100644
--- a/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c
+++ b/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c
@@ -6,7 +6,6 @@
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm0,\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm1,\[^\\n\\r\]*16\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm2,\[^\\n\\r\]*32\[^\\n\\r\]*" } } */
-/* { dg-final { scan-assembler "(?:movdqa|movaps)\[ \\t\]+\[^\\n\]*%xmm\[4-6\],\[^\\n\\r\]*" } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c b/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c
index 26f04dcf014..a9398b4e7a2 100644
--- a/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c
+++ b/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c
@@ -8,7 +8,6 @@
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm1,\[^\\n\\r\]*16\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm2,\[^\\n\\r\]*32\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm3,\[^\\n\\r\]*48\[^\\n\\r\]*" } } */
-/* { dg-final { scan-assembler "(?:movdqa|movaps)\[ \\t\]+\[^\\n\]*%xmm\[4-6\],\[^\\n\\r\]*" } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/pr106322.c b/gcc/testsuite/gcc.target/i386/pr106322.c
new file mode 100644
index 00000000000..31333c5fdcc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr106322.c
@@ -0,0 +1,51 @@
+/* { dg-do run } */
+/* { dg-require-effective-target ia32 } */
+/* { dg-options "-O2 -mtune=generic -march=i686" } */
+
+/* As PR106322, verify this can execute well (not abort).  */
+
+#define N 64
+typedef unsigned short int uh;
+typedef unsigned short int uw;
+uh a[N];
+uh b[N];
+uh c[N];
+uh e[N];
+
+__attribute__ ((noipa)) void
+foo ()
+{
+  for (int i = 0; i < N; i++)
+    c[i] = ((uw) b[i] * (uw) a[i]) >> 16;
+}
+
+__attribute__ ((optimize ("-O0"))) void
+init ()
+{
+  for (int i = 0; i < N; i++)
+    {
+      a[i] = (uh) (0x7ABC - 0x5 * i);
+      b[i] = (uh) (0xEAB + 0xF * i);
+      e[i] = ((uw) b[i] * (uw) a[i]) >> 16;
+    }
+}
+
+__attribute__ ((optimize ("-O0"))) void
+check ()
+{
+  for (int i = 0; i < N; i++)
+    {
+      if (c[i] != e[i])
+	__builtin_abort ();
+    }
+}
+
+int
+main ()
+{
+  init ();
+  foo ();
+  check ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr106704.c b/gcc/testsuite/gcc.target/i386/pr106704.c
new file mode 100644
index 00000000000..44e052a4caa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr106704.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx -O2 -mno-avx2" } */
+/* { dg-final { scan-assembler-times {vblendvps[ \t]+%ymm[0-9]+} 1 } } */
+/* { dg-final { scan-assembler-times {vblendvpd[ \t]+%ymm[0-9]+} 1 } } */
+
+#include <immintrin.h>
+
+__m256 bend_stuff( __m256 a, __m256 b, __m256 mask)
+{
+  return _mm256_blendv_ps(a, b, mask);
+}
+
+__m256d bend_stuff1( __m256d a, __m256d b, __m256d mask)
+{
+  return _mm256_blendv_pd(a, b, mask);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr107304.c b/gcc/testsuite/gcc.target/i386/pr107304.c
new file mode 100644
index 00000000000..24d68795e7f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr107304.c
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -march=tigerlake" } */
+
+#include <stdint.h>
+
+typedef union {
+  uint8_t v __attribute__((aligned(256))) __attribute__ ((vector_size(64 * sizeof(uint8_t))));
+  uint8_t i[64] __attribute__((aligned(256)));
+} stress_vec_u8_64_t;
+
+typedef struct {
+ struct {
+  stress_vec_u8_64_t s;
+  stress_vec_u8_64_t o;
+  stress_vec_u8_64_t mask1;
+  stress_vec_u8_64_t mask2;
+ } u8_64;
+} stress_vec_data_t;
+
+__attribute__((target_clones("arch=alderlake", "default"))) 
+void
+stress_vecshuf_u8_64(stress_vec_data_t *data)
+{
+  stress_vec_u8_64_t *__restrict s;
+  stress_vec_u8_64_t *__restrict mask1;
+  stress_vec_u8_64_t *__restrict mask2;
+  register int i;
+
+  s = &data->u8_64.s;
+  mask1 = &data->u8_64.mask1;
+  mask2 = &data->u8_64.mask2;
+
+  for (i = 0; i < 256; i++) {	/* was i < 65536 */
+      stress_vec_u8_64_t tmp;
+
+      tmp.v = __builtin_shuffle(s->v, mask1->v);
+      s->v = __builtin_shuffle(tmp.v, mask2->v);
+  }
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr107647.c b/gcc/testsuite/gcc.target/i386/pr107647.c
new file mode 100644
index 00000000000..45fcb55d698
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr107647.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ffp-contract=off -mavx2 -mfma" } */
+
+void cscal(int n, float da_r, float *x)
+{
+  for (int i = 0; i < n; i += 4)
+    {
+      float temp0  =  da_r * x[i]   - x[i+1];
+      float temp1  =  da_r * x[i+2] - x[i+3];
+      x[i+1]       =  da_r * x[i+1] + x[i];
+      x[i+3]       =  da_r * x[i+3] + x[i+2];
+      x[i]         =  temp0;
+      x[i+2]       =  temp1;
+    }
+}
+
+/* { dg-final { scan-assembler-not "fma" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr107863.c b/gcc/testsuite/gcc.target/i386/pr107863.c
new file mode 100644
index 00000000000..99fd85d9765
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr107863.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx2 -O" } */
+
+typedef char v16qi __attribute__((vector_size(16)));
+
+v16qi foo(v16qi a){
+  return __builtin_ia32_vec_set_v16qi (a, -1, 2);
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/pr106459.c b/gcc/testsuite/gcc.target/loongarch/pr106459.c
new file mode 100644
index 00000000000..eb737dc49c1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/pr106459.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+
+/* https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106459 */
+
+typedef unsigned int UDItype __attribute__((mode(DI)));
+int foo(UDItype x) {
+  x = x & (((UDItype)(((UDItype)(((UDItype)0x0F << 8) | 0x0F) << (2 * 8)) |
+                      (((UDItype)0x0F << 8) | 0x0F))
+            << (4 * 8)) |
+           (((UDItype)(((UDItype)0x0F << 8) | 0x0F) << (2 * 8)) |
+            (((UDItype)0x0F << 8) | 0x0F)));
+  return x;
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/pr107713-1.c b/gcc/testsuite/gcc.target/loongarch/pr107713-1.c
new file mode 100644
index 00000000000..d1536c95b27
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/pr107713-1.c
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-require-effective-target pthread } */
+/* { dg-options "-pthread" } */
+
+#include <pthread.h>
+
+char x, x1, x2;
+
+void *
+work1 (void *)
+{
+  for (int i = 0; i < 100; i++)
+    x1 = __atomic_exchange_n (&x, x1, __ATOMIC_SEQ_CST);
+  return NULL;
+}
+
+void *
+work2 (void *)
+{
+  for (int i = 0; i < 100; i++)
+    x2 = __atomic_exchange_n (&x, x2, __ATOMIC_SEQ_CST);
+  return NULL;
+}
+
+void
+test (void)
+{
+  x = 0;
+  x1 = 1;
+  x2 = 2;
+  pthread_t w1, w2;
+  if (pthread_create (&w1, NULL, work1, NULL) != 0)
+    __builtin_abort ();
+  if (pthread_create (&w2, NULL, work2, NULL) != 0)
+    __builtin_abort ();
+  if (pthread_join (w1, NULL) != 0)
+    __builtin_abort ();
+  if (pthread_join (w2, NULL) != 0)
+    __builtin_abort ();
+  if ((x ^ x1 ^ x2) != 3)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 10000; i++)
+    test ();
+}
diff --git a/gcc/testsuite/gcc.target/loongarch/pr107713-2.c b/gcc/testsuite/gcc.target/loongarch/pr107713-2.c
new file mode 100644
index 00000000000..82d44db3d51
--- /dev/null
+++ b/gcc/testsuite/gcc.target/loongarch/pr107713-2.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-final { scan-assembler-times "beq|bne" 1 } } */
+
+char
+t (char *p, char x)
+{
+  return __atomic_exchange_n (p, x, __ATOMIC_RELAXED);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr100645.c b/gcc/testsuite/gcc.target/powerpc/pr100645.c
new file mode 100644
index 00000000000..c4e92cc8052
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr100645.c
@@ -0,0 +1,13 @@
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-mdejagnu-cpu=power6 -maltivec" } */
+
+/* This used to ICE.  */
+
+typedef long long v2di __attribute__ ((vector_size (16)));
+
+v2di
+foo_v2di_l (v2di x)
+{
+  return __builtin_shuffle ((v2di){0, 0}, x, (v2di){3, 0});
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr103353.c b/gcc/testsuite/gcc.target/powerpc/pr103353.c
new file mode 100644
index 00000000000..5d519fb1b7b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr103353.c
@@ -0,0 +1,22 @@
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* If the default cpu type is power10 or later, MMA is enabled by default.
+   To keep the test point available all the time, this case specifies
+   -mdejagnu-cpu=power6 to make it be tested without MMA.  */
+/* { dg-options "-maltivec -mdejagnu-cpu=power6" } */
+
+/* Verify there is no ICE and don't check the error messages on MMA
+   requirement since they could be fragile and are not test points
+   of this case.  */
+/* { dg-excess-errors "pr103353" } */
+
+void
+foo (__vector_pair *dst, double *x)
+{
+  dst[0] = __builtin_vsx_lxvp (0, (__vector_pair *)(void *)x);
+}
+
+void
+bar (__vector_pair *src, double *x)
+{
+  __builtin_vsx_stxvp (src[0], 0, (__vector_pair *)(void *)x);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr104482.c b/gcc/testsuite/gcc.target/powerpc/pr104482.c
new file mode 100644
index 00000000000..92191265e4c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr104482.c
@@ -0,0 +1,16 @@
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-mvsx" } */
+
+/* It's to verify no ICE here, ignore error messages about
+   mismatch argument number since they are not test points
+   here.  */
+/* { dg-excess-errors "pr104482" } */
+
+__attribute__ ((altivec (vector__))) int vsi;
+
+double
+testXXPERMDI (void)
+{
+  return __builtin_vsx_xxpermdi (vsi, vsi, 2, 4);
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106017.c b/gcc/testsuite/gcc.target/powerpc/pr106017.c
new file mode 100644
index 00000000000..46d6c7a4a33
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106017.c
@@ -0,0 +1,19 @@
+/* PR target/106017 */
+/* { dg-options "-O1 -mdejagnu-cpu=power10" } */
+/* { dg-require-effective-target power10_ok } */
+
+/* Make sure we do not flag any errors on the following test cases.  */
+
+void takeacc(__vector_quad *);
+void
+foo (void)
+{
+  __vector_quad arr[4];
+  takeacc (arr);
+}
+
+unsigned char *
+bar (__vector_quad *a)
+{
+  return (unsigned char *)a;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106322.c b/gcc/testsuite/gcc.target/powerpc/pr106322.c
new file mode 100644
index 00000000000..c05072d3416
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106322.c
@@ -0,0 +1,50 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -mdejagnu-cpu=power4" } */
+
+/* As PR106322, verify this can execute well (not abort).  */
+
+#define N 64
+typedef unsigned short int uh;
+typedef unsigned short int uw;
+uh a[N];
+uh b[N];
+uh c[N];
+uh e[N];
+
+__attribute__ ((noipa)) void
+foo ()
+{
+  for (int i = 0; i < N; i++)
+    c[i] = ((uw) b[i] * (uw) a[i]) >> 16;
+}
+
+__attribute__ ((optimize ("-O0"))) void
+init ()
+{
+  for (int i = 0; i < N; i++)
+    {
+      a[i] = (uh) (0x7ABC - 0x5 * i);
+      b[i] = (uh) (0xEAB + 0xF * i);
+      e[i] = ((uw) b[i] * (uw) a[i]) >> 16;
+    }
+}
+
+__attribute__ ((optimize ("-O0"))) void
+check ()
+{
+  for (int i = 0; i < N; i++)
+    {
+      if (c[i] != e[i])
+	__builtin_abort ();
+    }
+}
+
+int
+main ()
+{
+  init ();
+  foo ();
+  check ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106736-1.c b/gcc/testsuite/gcc.target/powerpc/pr106736-1.c
new file mode 100644
index 00000000000..65bd79d3dce
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106736-1.c
@@ -0,0 +1,20 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-1" } */
+
+extern void bar (__vector_quad *);
+
+void
+foo (__vector_quad *a, __vector_quad *b)
+{
+  __vector_quad arr[2] = {*a, *b};
+  bar (&arr[0]);
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106736-2.c b/gcc/testsuite/gcc.target/powerpc/pr106736-2.c
new file mode 100644
index 00000000000..12ad936fccc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106736-2.c
@@ -0,0 +1,17 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_pair is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-2" } */
+
+void
+foo (__vector_pair *a, __vector_pair *b)
+{
+  *a = *b;
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106736-3.c b/gcc/testsuite/gcc.target/powerpc/pr106736-3.c
new file mode 100644
index 00000000000..4fb368b8fb5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106736-3.c
@@ -0,0 +1,18 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-3" } */
+
+__vector_quad ga;
+void
+foo (__vector_quad *a)
+{
+  ga = *a;
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106736-4.c b/gcc/testsuite/gcc.target/powerpc/pr106736-4.c
new file mode 100644
index 00000000000..4b366416b0a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106736-4.c
@@ -0,0 +1,19 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-4" } */
+
+__vector_quad ga;
+__vector_quad gb;
+void
+foo ()
+{
+  gb = ga;
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106736-5.c b/gcc/testsuite/gcc.target/powerpc/pr106736-5.c
new file mode 100644
index 00000000000..d7370b81e81
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106736-5.c
@@ -0,0 +1,18 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_pair is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-5" } */
+
+__vector_pair ga;
+void
+foo (__vector_pair *a)
+{
+  *a = ga;
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr96072.c b/gcc/testsuite/gcc.target/powerpc/pr96072.c
new file mode 100644
index 00000000000..10341c91d2f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr96072.c
@@ -0,0 +1,14 @@
+/* { dg-options "-O2" } */
+
+/* This used to ICE with the SYSV ABI (PR96072).  */
+
+void
+he (int jn)
+{
+  {
+    int bh[jn];
+    if (jn != 0)
+      goto wa;
+  }
+wa:;
+}
diff --git a/gcc/testsuite/gcc.target/s390/pr106355-1.c b/gcc/testsuite/gcc.target/s390/pr106355-1.c
new file mode 100644
index 00000000000..1ec0f6b25ac
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr106355-1.c
@@ -0,0 +1,42 @@
+/* { dg-do compile } */
+/* { dg-options "-foptimize-sibling-calls" } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar4} } } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar8} } } */
+
+/* Parameter E is passed in GPR 6 which is call-saved which prohibits
+   sibling call optimization.  This must hold true also if the mode of the
+   parameter is BLKmode.  */
+
+/* 4 byte */
+
+typedef struct
+{
+  char x;
+  char y[3];
+} t4;
+
+extern t4 e4;
+
+extern void bar4 (int a, int b, int c, int d, t4 e4);
+
+void foo4 (int a, int b, int c, int d)
+{
+  bar4 (a, b, c, d, e4);
+}
+
+/* 8 byte */
+
+typedef struct
+{
+  short x;
+  char y[6];
+} t8;
+
+extern t8 e8;
+
+extern void bar8 (int a, int b, int c, int d, t8 e8);
+
+void foo8 (int a, int b, int c, int d)
+{
+  bar8 (a, b, c, d, e8);
+}
diff --git a/gcc/testsuite/gcc.target/s390/pr106355-2.c b/gcc/testsuite/gcc.target/s390/pr106355-2.c
new file mode 100644
index 00000000000..ddbdba5d278
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr106355-2.c
@@ -0,0 +1,8 @@
+/* { dg-do compile { target { s390-*-* } } } */
+/* { dg-options "-foptimize-sibling-calls -mzarch" } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar} } } */
+
+/* This tests function s390_call_saved_register_used where
+   GET_CODE (parm_rtx) == PARALLEL holds.  */
+
+#include "pr106355.h"
diff --git a/gcc/testsuite/gcc.target/s390/pr106355-3.c b/gcc/testsuite/gcc.target/s390/pr106355-3.c
new file mode 100644
index 00000000000..39daea44fc4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr106355-3.c
@@ -0,0 +1,8 @@
+/* { dg-do compile { target { s390-*-* } } } */
+/* { dg-options "-foptimize-sibling-calls -mesa" } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar} } } */
+
+/* This tests function s390_call_saved_register_used where
+   REG_P (parm_rtx) and nregs == 2 holds.  */
+
+#include "pr106355.h"
diff --git a/gcc/testsuite/gcc.target/s390/pr106355.h b/gcc/testsuite/gcc.target/s390/pr106355.h
new file mode 100644
index 00000000000..362908e5913
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr106355.h
@@ -0,0 +1,18 @@
+/* For the S/390 ABI parameter D is passed in GPR 5 and 6 and the latter is
+   call-saved which prohibits sibling call optimization.  This must hold true
+   also if the mode of the parameter is BLKmode.  */
+
+typedef struct
+{
+  short x;
+  char y[6];
+} t;
+
+extern t d;
+
+extern void bar (int a, int b, int c, t d);
+
+void foo (int a, int b, int c)
+{
+  bar (a, b, c, d);
+}
diff --git a/gcc/testsuite/gdc.dg/imports/pr108050/mod1.d b/gcc/testsuite/gdc.dg/imports/pr108050/mod1.d
new file mode 100644
index 00000000000..f27a13dc051
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/imports/pr108050/mod1.d
@@ -0,0 +1,2 @@
+module imports.pr108050.mod1;
+string[] split() { return null; }
diff --git a/gcc/testsuite/gdc.dg/imports/pr108050/mod2.d b/gcc/testsuite/gdc.dg/imports/pr108050/mod2.d
new file mode 100644
index 00000000000..29d8aa8f53e
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/imports/pr108050/mod2.d
@@ -0,0 +1,2 @@
+module imports.pr108050.mod2;
+string[] split() { return null; }
diff --git a/gcc/testsuite/gdc.dg/imports/pr108050/package.d b/gcc/testsuite/gdc.dg/imports/pr108050/package.d
new file mode 100644
index 00000000000..b8b03b832af
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/imports/pr108050/package.d
@@ -0,0 +1,2 @@
+module imports.pr108050;
+public import imports.pr108050.mod1, imports.pr108050.mod2;
diff --git a/gcc/testsuite/gdc.dg/pr107592.d b/gcc/testsuite/gdc.dg/pr107592.d
new file mode 100644
index 00000000000..59f34477356
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr107592.d
@@ -0,0 +1,13 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=107592
+// { dg-do compile }
+
+void test107592(Things...)(Things things)
+{
+    label:
+    foreach (thing; things)
+    {
+        continue label;
+    }
+}
+
+alias a107592 = test107592!(string);
diff --git a/gcc/testsuite/gdc.dg/pr108050.d b/gcc/testsuite/gdc.dg/pr108050.d
new file mode 100644
index 00000000000..69134e73137
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr108050.d
@@ -0,0 +1,4 @@
+// { dg-do compile }
+// { dg-additional-sources "imports/pr108050/package.d imports/pr108050/mod1.d imports/pr108050/mod2.d" }
+// { dg-options "-g" }
+import imports.pr108050 : split;
diff --git a/gcc/testsuite/gdc.dg/torture/imports/pr108055conv.d b/gcc/testsuite/gdc.dg/torture/imports/pr108055conv.d
new file mode 100644
index 00000000000..93ebba747b1
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/torture/imports/pr108055conv.d
@@ -0,0 +1,26 @@
+module imports.pr108055conv;
+
+T toStr(T, S)(S src)
+{
+    static if (is(typeof(T.init[0]) E))
+    {
+        struct Appender
+        {
+            inout(E)[] data;
+        }
+
+        import imports.pr108055spec;
+        import imports.pr108055write;
+
+        auto w = Appender();
+        FormatSpec!E f;
+        formatValue(w, src, f);
+        return w.data;
+    }
+}
+
+T to(T, A)(A args)
+{
+    return toStr!T(args);
+}
+
diff --git a/gcc/testsuite/gdc.dg/torture/imports/pr108055spec.d b/gcc/testsuite/gdc.dg/torture/imports/pr108055spec.d
new file mode 100644
index 00000000000..801c5810516
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/torture/imports/pr108055spec.d
@@ -0,0 +1,18 @@
+module imports.pr108055spec;
+
+template Unqual(T : const U, U)
+{
+    alias Unqual = U;
+}
+
+template FormatSpec(Char)
+if (!is(Unqual!Char == Char))
+{
+    alias FormatSpec = FormatSpec!(Unqual!Char);
+}
+
+struct FormatSpec(Char)
+if (is(Unqual!Char == Char))
+{
+    const(Char)[] nested;
+}
diff --git a/gcc/testsuite/gdc.dg/torture/imports/pr108055write.d b/gcc/testsuite/gdc.dg/torture/imports/pr108055write.d
new file mode 100644
index 00000000000..fe41d7baa7c
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/torture/imports/pr108055write.d
@@ -0,0 +1,19 @@
+module imports.pr108055write;
+import imports.pr108055spec;
+
+void formatValueImpl(Writer, T, Char)(ref Writer , const(T) ,
+                                      scope const ref FormatSpec!Char )
+{
+    T val;
+    char spec;
+
+    (ref val) @trusted {
+        return (cast(const char*) &val)[0 .. val.sizeof];
+    }(val);
+
+}
+
+void formatValue(Writer, T, Char)(Writer w, T val, Char f)
+{
+    formatValueImpl(w, val, f);
+}
diff --git a/gcc/testsuite/gdc.dg/torture/pr108055.d b/gcc/testsuite/gdc.dg/torture/pr108055.d
new file mode 100644
index 00000000000..c4ffad26d1e
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/torture/pr108055.d
@@ -0,0 +1,12 @@
+// { dg-do link }
+// { dg-additional-files "imports/pr108055conv.d imports/pr108055spec.d imports/pr108055write.d" }
+// { dg-additional-options "-I[srcdir] -fno-druntime" }
+import imports.pr108055conv;
+
+extern(C) int main()
+{
+    float zis;
+    static if (is(typeof(to!string(&zis))))
+        to!string(&zis);
+    return 0;
+}
diff --git a/gcc/testsuite/gfortran.dg/PR100029.f90 b/gcc/testsuite/gfortran.dg/PR100029.f90
new file mode 100644
index 00000000000..fd7e4c46032
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100029.f90
@@ -0,0 +1,22 @@
+! { dg-do run }
+!
+! Test the fix for PR100029
+!
+
+program foo_p
+  implicit none
+
+  type :: foo_t
+  end type foo_t
+  
+  class(foo_t), allocatable :: pout
+
+  call foo_s(pout)
+
+contains
+
+  subroutine foo_s(that)
+    class(foo_t), allocatable, intent(out) :: that(..)
+  end subroutine foo_s
+
+end program foo_p
diff --git a/gcc/testsuite/gfortran.dg/PR100040.f90 b/gcc/testsuite/gfortran.dg/PR100040.f90
new file mode 100644
index 00000000000..0a135ff30a3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100040.f90
@@ -0,0 +1,36 @@
+! { dg-do run }
+!
+! Test the fix for PR100040
+!
+
+program foo_p
+  implicit none
+
+  integer, parameter :: n = 11
+
+  type :: foo_t
+    integer :: i
+  end type foo_t
+  
+  type(foo_t), parameter :: a = foo_t(n)
+  
+  class(foo_t), allocatable :: pout
+
+  call foo_s(pout)
+  if(.not.allocated(pout)) stop 1
+  if(pout%i/=n) stop 2
+
+contains
+
+  subroutine foo_s(that)
+    class(foo_t), allocatable, intent(out) :: that(..)
+
+    select rank(that)
+    rank(0)
+      that = a
+    rank default
+      stop 3
+    end select
+  end subroutine foo_s
+
+end program foo_p
diff --git a/gcc/testsuite/gfortran.dg/PR100097.f90 b/gcc/testsuite/gfortran.dg/PR100097.f90
new file mode 100644
index 00000000000..f927d293e2c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100097.f90
@@ -0,0 +1,41 @@
+! { dg-do run }
+! { dg-options "-fdump-tree-original" }
+!
+! Test the fix for PR100097
+!
+
+program main_p
+  implicit none
+
+  class(*), pointer     :: bar_p(:)
+  class(*), allocatable :: bar_a(:)
+
+  call foo_p(bar_p)
+  call foo_a(bar_a)
+
+contains
+
+  subroutine foo_p(that)
+    class(*), pointer, intent(out) :: that(..)
+
+    select rank(that)
+    rank(1)
+    rank default
+      stop 1
+    end select
+  end subroutine foo_p
+
+  subroutine foo_a(that)
+    class(*), allocatable, intent(out) :: that(..)
+
+    select rank(that)
+    rank(1)
+    rank default
+      stop 2
+    end select
+  end subroutine foo_a
+
+end program main_p
+
+! { dg-final { scan-tree-dump "bar_a._data.dtype = \\{.* .rank=1,.*\\}" "original" } }
+! { dg-final { scan-tree-dump "bar_p._data.dtype = \\{.* .rank=1,.*\\}" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/PR100098.f90 b/gcc/testsuite/gfortran.dg/PR100098.f90
new file mode 100644
index 00000000000..26ac0c88425
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100098.f90
@@ -0,0 +1,45 @@
+! { dg-do run }
+! { dg-options "-fdump-tree-original" }
+!
+! Test the fix for PR100098
+!
+
+program main_p
+  implicit none
+
+  type :: foo_t
+    integer :: i
+  end type foo_t
+
+  class(foo_t), pointer     :: bar_p(:)
+  class(foo_t), allocatable :: bar_a(:)
+
+  call foo_p(bar_p)
+  call foo_a(bar_a)
+
+contains
+
+  subroutine foo_p(that)
+    class(foo_t), pointer, intent(out) :: that(..)
+
+    select rank(that)
+    rank(1)
+    rank default
+      stop 1
+    end select
+  end subroutine foo_p
+
+  subroutine foo_a(that)
+    class(foo_t), allocatable, intent(out) :: that(..)
+
+    select rank(that)
+    rank(1)
+    rank default
+      stop 2
+    end select
+  end subroutine foo_a
+
+end program main_p
+
+! { dg-final { scan-tree-dump "bar_a._data.dtype = \\{.* .rank=1,.*\\}" "original" } }
+! { dg-final { scan-tree-dump "bar_p._data.dtype = \\{.* .rank=1,.*\\}" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/PR100103.f90 b/gcc/testsuite/gfortran.dg/PR100103.f90
new file mode 100644
index 00000000000..21405610a71
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100103.f90
@@ -0,0 +1,76 @@
+! { dg-do run }
+!
+! Test the fix for PR100103
+!
+
+program main_p
+  implicit none
+
+  integer            :: i
+  integer, parameter :: n = 11
+
+  type :: foo_t
+    integer :: i
+  end type foo_t
+
+  type(foo_t), parameter :: a(*) = [(foo_t(i), i=1,n)]
+
+  type(foo_t),  allocatable :: bar_d(:)
+  class(foo_t), allocatable :: bar_p(:)
+  class(*),     allocatable :: bar_u(:)
+
+
+  call foo_d(bar_d)
+  if(.not.allocated(bar_d)) stop 1
+  if(any(bar_d%i/=a%i)) stop 2
+  deallocate(bar_d)
+  call foo_p(bar_p)
+  if(.not.allocated(bar_p)) stop 3
+  if(any(bar_p%i/=a%i)) stop 4
+  deallocate(bar_p)
+  call foo_u(bar_u)
+  if(.not.allocated(bar_u)) stop 5
+  select type(bar_u)
+  type is(foo_t)
+    if(any(bar_u%i/=a%i)) stop 6
+  class default
+    stop 7
+  end select
+  deallocate(bar_u)
+
+contains
+
+  subroutine foo_d(that)
+    type(foo_t), allocatable, intent(out) :: that(..)
+
+    select rank(that)
+    rank(1)
+      that = a
+    rank default
+      stop 8
+    end select
+  end subroutine foo_d
+
+  subroutine foo_p(that)
+    class(foo_t), allocatable, intent(out) :: that(..)
+
+    select rank(that)
+    rank(1)
+      that = a
+    rank default
+      stop 9
+    end select
+  end subroutine foo_p
+
+  subroutine foo_u(that)
+    class(*), allocatable, intent(out) :: that(..)
+
+    select rank(that)
+    rank(1)
+      that = a
+    rank default
+      stop 10
+    end select
+  end subroutine foo_u
+
+end program main_p
diff --git a/gcc/testsuite/gfortran.dg/PR100132.f90 b/gcc/testsuite/gfortran.dg/PR100132.f90
new file mode 100644
index 00000000000..78ae6702810
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100132.f90
@@ -0,0 +1,75 @@
+! { dg-do run }
+!
+! Test the fix for PR100132
+!
+
+module main_m
+  implicit none
+
+  private
+
+  public :: &
+    foo_t
+
+  public :: &
+    set,    &
+    get
+
+  type :: foo_t
+    integer :: i
+  end type foo_t
+
+  type(foo_t), save, pointer :: data => null()
+
+contains
+
+  subroutine set(this)
+    class(foo_t), pointer, intent(in) :: this
+
+    if(associated(data)) stop 1
+    data => this
+  end subroutine set
+
+  subroutine get(this)
+    type(foo_t), pointer, intent(out) :: this
+
+    if(.not.associated(data)) stop 4
+    this => data
+    nullify(data)
+  end subroutine get
+
+end module main_m
+
+program main_p
+
+  use :: main_m, only: &
+    foo_t, set, get
+
+  implicit none
+
+  integer, parameter :: n = 1000
+
+  type(foo_t), pointer :: ps
+  type(foo_t),  target :: s
+  integer              :: i, j, yay, nay
+
+  yay = 0
+  nay = 0
+  do i = 1, n
+    s%i = i
+    call set(s)
+    call get(ps)
+    if(.not.associated(ps)) stop 13
+    j = ps%i
+    if(i/=j) stop 14
+    if(i/=s%i) stop 15
+    if(ps%i/=s%i) stop 16
+    if(associated(ps, s))then
+      yay = yay + 1
+    else
+      nay = nay + 1
+    end if
+  end do
+  if((yay/=n).or.(nay/=0)) stop 17
+
+end program main_p
diff --git a/gcc/testsuite/gfortran.dg/PR100136.f90 b/gcc/testsuite/gfortran.dg/PR100136.f90
new file mode 100644
index 00000000000..922af4aecc3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100136.f90
@@ -0,0 +1,39 @@
+! { dg-do run }
+! { dg-options "-fcheck=pointer" }
+! { dg-shouldfail "Argument not allocated" }
+! { dg-output "Fortran runtime error: Allocatable actual argument 'c_init2' is not allocated" }
+!
+! Tests fix for PR100136
+!
+! Test cut down from PR58586
+!
+
+module test_pr58586_mod
+  implicit none
+
+  type :: a
+  end type
+
+  type :: c
+     type(a), allocatable :: a
+  end type
+
+contains
+
+  subroutine add_class_c (d)
+    class(c), value :: d
+  end subroutine
+
+  class(c) function c_init2()
+    allocatable :: c_init2
+  end function
+
+end module test_pr58586_mod
+
+program test_pr58586
+  use test_pr58586_mod
+
+  ! This needs to execute, to see whether the segfault at runtime is resolved
+  call add_class_c(c_init2())
+
+end program
diff --git a/gcc/testsuite/gfortran.dg/PR100245.f90 b/gcc/testsuite/gfortran.dg/PR100245.f90
new file mode 100644
index 00000000000..07c1f7b3a1c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100245.f90
@@ -0,0 +1,28 @@
+! { dg-do run }
+!
+! Test the fix for PR100245
+!
+
+program main_p
+
+  implicit none
+
+  type :: foo_t
+    integer :: a
+  end type foo_t
+
+  integer, parameter :: a = 42
+
+  class(foo_t), allocatable :: val
+  class(foo_t), allocatable :: rs1
+  type(foo_t),  allocatable :: rs2
+
+  allocate(val, source=foo_t(42))
+  if (val%a/=a) stop 1
+  rs1 = val
+  if (rs1%a/=a) stop 2
+  rs2 = val
+  if (rs2%a/=a) stop 3
+  deallocate(val, rs1, rs2)
+
+end program main_p
diff --git a/gcc/testsuite/gfortran.dg/associate_26a.f90 b/gcc/testsuite/gfortran.dg/associate_26a.f90
new file mode 100644
index 00000000000..85aebebd4d8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_26a.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+!
+! Test the fix for PR78152 and the followup in PR82868
+!
+! Contributed by <physiker@toast2.net>
+!
+program co_assoc
+  implicit none
+  integer, parameter :: p = 5
+  real, allocatable :: a(:,:)[:,:]
+  allocate (a(p,p)[2,*])
+  associate (i => a(1:p, 1:p))
+  end associate
+end program co_assoc
diff --git a/gcc/testsuite/gfortran.dg/gomp/declare-simd-6.f90 b/gcc/testsuite/gfortran.dg/gomp/declare-simd-6.f90
new file mode 100644
index 00000000000..83f2c0ab7cb
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/declare-simd-6.f90
@@ -0,0 +1,42 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-gimple" }
+!
+! PR fortran/106566
+!
+! { dg-final { scan-tree-dump-times "__attribute__\\(\\(omp declare simd \\(linear\\(ref\\(0\\):4\\) simdlen\\(8\\)\\)\\)\\)" 2 "gimple" } }
+! { dg-final { scan-tree-dump-times "__attribute__\\(\\(omp declare simd \\(linear\\(ref\\(0\\):8\\) simdlen\\(8\\)\\)\\)\\)" 2 "gimple" } }
+
+subroutine add_one2(p)
+  implicit none
+  !$omp declare simd(add_one2) linear(ref(p)) simdlen(8)
+  integer(kind=4) :: p
+
+  p = p + 1
+end subroutine
+
+subroutine linear_add_one2(p)
+  implicit none
+  !$omp declare simd(linear_add_one2) linear(ref(p) : 2) simdlen(8)
+  integer(kind=4) :: p
+
+  p = p + 1
+end subroutine
+
+module m
+   integer, parameter :: NN = 1023
+   integer(kind=4) :: a(NN)
+contains
+  subroutine module_add_one2(q)
+    implicit none
+    !$omp declare simd(module_add_one2) linear(ref(q)) simdlen(8)
+    integer(kind=4) :: q
+    q = q + 1
+  end subroutine
+
+  subroutine linear_add_one2(q)
+    implicit none
+    !$omp declare simd(linear_add_one2) linear(ref(q) : 2) simdlen(8)
+    integer(kind=4) :: q
+    q = q + 1
+  end subroutine
+end module
diff --git a/gcc/testsuite/gfortran.dg/gomp/strictly-structured-block-4.f90 b/gcc/testsuite/gfortran.dg/gomp/strictly-structured-block-4.f90
new file mode 100644
index 00000000000..66cf0a3925e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/gomp/strictly-structured-block-4.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+implicit none
+integer ::x,z
+x = 42
+print '(*(z16:" "))', loc(x)
+!$omp target map(x, z)
+block
+  integer :: y
+  x = 123
+  y = 99
+  !$omp target device(ancestor:1) map(always,tofrom:x) map(y) ! { dg-error "'ancestor' device modifier not preceded by 'requires' directive with 'reverse_offload' clause" }
+    print '(*(z16:" "))', loc(x), loc(y)
+    print * ,x, y
+    x = -x
+    y = -y
+  !$omp end target ! { dg-error "Unexpected ..OMP END TARGET statement" }
+  z = y
+end block
+    print * ,x !, z
+end
+
diff --git a/gcc/testsuite/gfortran.dg/graphite/pr107865.f90 b/gcc/testsuite/gfortran.dg/graphite/pr107865.f90
new file mode 100644
index 00000000000..6bddb17a1be
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/graphite/pr107865.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-options "-O1 -floop-parallelize-all -ftree-parallelize-loops=2" }
+
+      SUBROUTINE FNC (F)
+
+      IMPLICIT REAL (A-H)
+      DIMENSION F(N)
+
+      DO I = 1, 6
+         DO J = 1, 6
+            IF (J .NE. I) THEN
+               F(I) = F(I) + 1
+            END IF
+         END DO
+      END DO
+
+      RETURN
+      END
diff --git a/gcc/testsuite/gfortran.dg/guality/guality.exp b/gcc/testsuite/gfortran.dg/guality/guality.exp
index 0375edfffe4..86a966a9133 100644
--- a/gcc/testsuite/gfortran.dg/guality/guality.exp
+++ b/gcc/testsuite/gfortran.dg/guality/guality.exp
@@ -8,6 +8,10 @@ if { [istarget *-*-darwin*] } {
   return
 }
 
+if { [istarget hppa*-*-hpux*] } {
+    return
+}
+
 if { [istarget "powerpc-ibm-aix*"] } {
     set torture_execute_xfail "powerpc-ibm-aix*"
     return
diff --git a/gcc/testsuite/gfortran.dg/illegal_boz_arg_4.f90 b/gcc/testsuite/gfortran.dg/illegal_boz_arg_4.f90
new file mode 100644
index 00000000000..856cfa9211f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/illegal_boz_arg_4.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-options "-std=f2018" }
+! PR fortran/103413
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     class(*), allocatable :: a
+  end type
+  type(t) :: x
+  allocate (x%a, source=z'1') ! { dg-error "type incompatible" }
+  allocate (x%a, mold=z'1')   ! { dg-error "type incompatible" }
+end
diff --git a/gcc/testsuite/gfortran.dg/intent_optimize_4.f90 b/gcc/testsuite/gfortran.dg/intent_optimize_4.f90
new file mode 100644
index 00000000000..effbaa12a2d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intent_optimize_4.f90
@@ -0,0 +1,43 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+! { dg-final { scan-tree-dump-times "CLOBBER" 2 "original" } }
+!
+! PR fortran/106817
+! Check that for an actual argument whose dummy is INTENT(OUT),
+! the clobber that is emitted in the caller before a procedure call
+! happens after any expression depending on the argument value has been
+! evaluated.
+! 
+
+module m
+  implicit none
+contains
+  subroutine copy1(out, in)
+    integer, intent(in) :: in
+    integer, intent(out) :: out
+    out = in
+  end subroutine copy1
+  subroutine copy2(in, out)
+    integer, intent(in) :: in
+    integer, intent(out) :: out
+    out = in
+  end subroutine copy2
+end module m
+
+program p
+  use m
+  implicit none
+  integer :: a, b
+
+  ! Clobbering of a should happen after a+1 has been evaluated.
+  a = 3
+  call copy1(a, a+1)
+  if (a /= 4) stop 1
+
+  ! Clobbering order does not depend on the order of arguments.
+  ! It should also come last with reversed arguments.
+  b = 12
+  call copy2(b+1, b)
+  if (b /= 13) stop 2
+
+end program p
diff --git a/gcc/testsuite/gfortran.dg/intent_out_15.f90 b/gcc/testsuite/gfortran.dg/intent_out_15.f90
new file mode 100644
index 00000000000..64334e6f038
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intent_out_15.f90
@@ -0,0 +1,27 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-original" }
+!
+! PR fortran/105012
+! The following case was triggering an ICE because of a clobber
+! on the DERFC function decl instead of its result.
+
+module error_function
+integer, parameter :: r8 = selected_real_kind(12) ! 8 byte real
+contains
+SUBROUTINE CALERF_r8(ARG, RESULT, JINT)
+   integer, parameter :: rk = r8
+   real(rk), intent(in)  :: arg
+   real(rk), intent(out) :: result
+   IF (Y .LE. THRESH) THEN
+   END IF
+end SUBROUTINE CALERF_r8
+FUNCTION DERFC(X)
+   integer, parameter :: rk = r8 ! 8 byte real
+   real(rk), intent(in) :: X
+   real(rk) :: DERFC
+   CALL CALERF_r8(X, DERFC, JINT)
+END FUNCTION DERFC
+end module error_function
+
+! { dg-final { scan-tree-dump-times "CLOBBER" 1 "original" } }
+! { dg-final { scan-tree-dump "__result_derfc = {CLOBBER};" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/null_actual_3.f90 b/gcc/testsuite/gfortran.dg/null_actual_3.f90
new file mode 100644
index 00000000000..ea49f9630c9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/null_actual_3.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-options "-fallow-argument-mismatch -w" }
+! PR fortran/107576
+! Contributed by G.Steinmetz
+
+program p
+  implicit none
+  interface
+     subroutine r(y)
+       integer, pointer :: y(:)
+     end subroutine r
+  end interface
+  integer, pointer :: z(:) => null()
+  call r(z)
+  call s(z)
+  call r(null(z))
+  call s(null(z)) ! { dg-error "requires an explicit interface" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr103505.f90 b/gcc/testsuite/gfortran.dg/pr103505.f90
index 522e53efcb2..01308019b2c 100644
--- a/gcc/testsuite/gfortran.dg/pr103505.f90
+++ b/gcc/testsuite/gfortran.dg/pr103505.f90
@@ -3,7 +3,9 @@
 ! Testcase by G.Steinmetz
 
 program p
-  integer, parameter :: a((2.))   = [4,8] ! { dg-error "scalar INTEGER" }
-  integer, parameter :: z(1:(2.)) = [4,8] ! { dg-error "scalar INTEGER" }
-  print *, a(1:1)                         ! { dg-error "Syntax error" }
+  integer, parameter :: a((2.))   = [4,8] ! { dg-error "INTEGER type" }
+  integer, parameter :: z(1:(2.)) = [4,8] ! { dg-error "INTEGER type" }
+  print *, a(1:1)
 end
+
+! { dg-prune-output "Parameter array" }
diff --git a/gcc/testsuite/gfortran.dg/pr103694.f90 b/gcc/testsuite/gfortran.dg/pr103694.f90
new file mode 100644
index 00000000000..3ed8b2088da
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103694.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/103694 - ICE in gfc_conv_expr_op
+! Contributed by G.Steinmetz
+
+subroutine s
+  type t
+     integer :: a(2)
+  end type
+  type(t) :: x((0.)/0)
+  integer :: n = size(x(1)%a) ! { dg-error "does not reduce to a constant expression" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr105633.f90 b/gcc/testsuite/gfortran.dg/pr105633.f90
new file mode 100644
index 00000000000..f2dbc5e742a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr105633.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/105633 - ICE in find_array_section
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1,2] ! { dg-error "deferred shape" }
+  print *, [a([1,2])]
+end
diff --git a/gcc/testsuite/gfortran.dg/pr106857.f90 b/gcc/testsuite/gfortran.dg/pr106857.f90
new file mode 100644
index 00000000000..4b0f86a75a6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106857.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/106857 - ICE in gfc_simplify_pack
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     integer :: n
+  end type
+  type(t), parameter :: a(2,2) = t(1)
+  type(t), parameter :: b(4) = reshape(a, [2])                          ! { dg-error "Different shape" }
+  type(t), parameter :: c(2) = pack(b, [.false.,.true.,.false.,.true.]) ! { dg-error "Different shape" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr106934.f90 b/gcc/testsuite/gfortran.dg/pr106934.f90
new file mode 100644
index 00000000000..ac58a3e82e3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106934.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! { dg-options "-O" }
+subroutine s
+   logical(1) :: a = .true.
+   logical(2) :: b
+   a = transfer(b, a)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr106985.f90 b/gcc/testsuite/gfortran.dg/pr106985.f90
new file mode 100644
index 00000000000..f4ed92577a3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106985.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/106985 - ICE in gfc_simplify_expr
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(2) = 1
+  integer, parameter :: b = a(2) + b ! { dg-error "before its definition is complete" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr106986.f90 b/gcc/testsuite/gfortran.dg/pr106986.f90
new file mode 100644
index 00000000000..a309b25d181
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106986.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/106986 - ICE in simplify_findloc_nodim
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1] ! { dg-error "deferred shape" }
+  print *, findloc (a, 1)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr107054.f90 b/gcc/testsuite/gfortran.dg/pr107054.f90
new file mode 100644
index 00000000000..bbfe646beba
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr107054.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR fortran/107054 - ICE in gfc_simplify_unpack
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     integer :: n = 0
+  end type
+  type(t), parameter :: a(4) = t(2)
+  type(t), parameter :: b(4) = reshape(a,[2]) ! { dg-error "Different shape" }
+  type(t), parameter :: c(2) = pack(b,[.false.,.true.,.false.,.true.]) ! { dg-error "Different shape" }
+  type(t), parameter :: d(4) = unpack(c,[.false.,.true.,.false.,.true.],a)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr107872.f90 b/gcc/testsuite/gfortran.dg/pr107872.f90
new file mode 100644
index 00000000000..09838479e92
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr107872.f90
@@ -0,0 +1,40 @@
+! { dg-do run }
+!
+! Test the fix for PR107872, where an ICE occurred in
+! resolve.cc(derived_inaccessible) because derived types with
+! recursive allocatable components were not catered for.
+!
+module mod1
+  type t
+     integer :: data
+     type(t), allocatable :: next
+   contains
+     procedure, private :: write_t
+     generic :: write(formatted) => write_t
+  end type
+contains
+  recursive subroutine write_t(this, unit, iotype, v_list, iostat, iomsg)
+    class(t), intent(in) :: this
+    integer, intent(in) :: unit
+    character(*), intent(in) :: iotype
+    integer, intent(in) :: v_list(:)
+    integer, intent(out) :: iostat
+    character(*), intent(inout) :: iomsg
+    if (ALLOCATED(this%next)) &
+         write (unit, '(dt)') this%next
+    write (unit, '(i2)') this%data
+  end subroutine
+end module
+
+  use mod1
+  type(t) :: a
+  character (8) :: buffer
+  a%data = 1
+  allocate (a%next)
+  a%next%data = 2
+  allocate (a%next%next)
+  a%next%next%data = 3
+  write (buffer, '(dt)')a
+  deallocate (a%next)
+  if (trim (buffer) .ne. ' 3 2 1') stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/pr108131.f90 b/gcc/testsuite/gfortran.dg/pr108131.f90
new file mode 100644
index 00000000000..8bf36d361ba
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr108131.f90
@@ -0,0 +1,25 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+! PR fortran/108131
+!
+! Incorrect array bounds when bound intrinsic used in declaration
+
+program test
+  implicit none
+  integer, parameter :: mg(7:10)                 = 0
+  integer, parameter :: u =   ubound(mg, dim=1)
+  integer, parameter :: cx(-1:ubound(mg, dim=1)) = 1
+  integer, parameter :: dx(lbound(mg, dim=1):ubound(cx, dim=1)) = 2
+
+  write(*,*) ubound(mg, dim=1)
+  write(*,*) ubound(cx, dim=1)
+  if (u /= 10) stop 1
+  if (ubound(mg, dim=1) /= 10) stop 2
+  if (ubound(cx, dim=1) /= 10) stop 3
+  if (ubound(dx, dim=1) /= 10) stop 4
+  if (lbound(mg, dim=1) /=  7) stop 5
+  if (lbound(cx, dim=1) /= -1) stop 6
+  if (lbound(dx, dim=1) /=  7) stop 7
+end program test
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/vect/pr107254.f90 b/gcc/testsuite/gfortran.dg/vect/pr107254.f90
new file mode 100644
index 00000000000..85bcb5f3fa2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/vect/pr107254.f90
@@ -0,0 +1,49 @@
+! { dg-do run }
+
+subroutine dlartg( f, g, s, r )
+  implicit none
+  double precision :: f, g, r, s
+  double precision :: d, p
+
+  d = sqrt( f*f + g*g )
+  p = 1.d0 / d
+  if( abs( f ) > 1 ) then
+     s = g*sign( p, f )
+     r = sign( d, f )
+  else
+     s = g*sign( p, f )
+     r = sign( d, f )
+  end if
+end subroutine
+
+subroutine dhgeqz( n, h, t )
+  implicit none
+  integer            n
+  double precision   h( n, * ), t( n, * )
+  integer            jc
+  double precision   c, s, temp, temp2, tempr
+  temp2 = 10d0
+  call dlartg( 10d0, temp2, s, tempr )
+  c = 0.9d0
+  s = 1.d0
+  do jc = 1, n
+     temp = c*h( 1, jc ) + s*h( 2, jc )
+     h( 2, jc ) = -s*h( 1, jc ) + c*h( 2, jc )
+     h( 1, jc ) = temp
+     temp2 = c*t( 1, jc ) + s*t( 2, jc )
+     t( 2, jc ) = -s*t( 1, jc ) + c*t( 2, jc )
+     t( 1, jc ) = temp2
+  enddo
+end subroutine dhgeqz
+
+program test
+  implicit none
+  double precision h(2,2), t(2,2)  
+  h = 0
+  t(1,1) = 1
+  t(2,1) = 0
+  t(1,2) = 0
+  t(2,2) = 0
+  call dhgeqz( 2, h, t )
+  if (t(2,2).ne.0) STOP 1
+end program test
diff --git a/gcc/testsuite/gnat.dg/opt100.adb b/gcc/testsuite/gnat.dg/opt100.adb
new file mode 100644
index 00000000000..83270b64339
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt100.adb
@@ -0,0 +1,13 @@
+-- { dg-do run }
+-- { dg-options "-O2 -gnatp" }
+
+with Opt100_Pkg; use Opt100_Pkg;
+
+procedure Opt100 is
+  R : constant Rec := (K => B, N => 1);
+
+begin
+  if Func (R) /= 1 then
+     raise Program_Error;
+  end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/opt100_pkg.adb b/gcc/testsuite/gnat.dg/opt100_pkg.adb
new file mode 100644
index 00000000000..42bf8830d53
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt100_pkg.adb
@@ -0,0 +1,17 @@
+package body Opt100_Pkg is
+
+   function Func (R : Rec) return Integer is
+   begin
+      if R in Small_Rec then
+         case R.K is
+            when A => return 0;
+            when B => return 1;
+            when C => return 2;
+            when others => raise Program_Error;
+         end case;
+      else
+         return -1;
+      end if;
+   end;
+
+end Opt100_Pkg;
diff --git a/gcc/testsuite/gnat.dg/opt100_pkg.ads b/gcc/testsuite/gnat.dg/opt100_pkg.ads
new file mode 100644
index 00000000000..a45f887d665
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt100_pkg.ads
@@ -0,0 +1,23 @@
+with Interfaces; use Interfaces;
+
+package Opt100_Pkg is
+
+  A : constant Unsigned_8 := 0;
+  B : constant Unsigned_8 := 1;
+  C : constant Unsigned_8 := 2;
+
+  subtype Small_Unsigned_8 is Unsigned_8 range A .. C;
+
+  type Rec is record
+    K : Unsigned_8;
+    N : Natural;
+  end record;
+
+  subtype Small_Rec is Rec
+    with Dynamic_Predicate =>
+      Small_Rec.K in Small_Unsigned_8 and
+        ((Small_Rec.N in Positive) = (Small_Rec.K in B | C));
+
+   function Func (R : Rec) return Integer;
+
+end Opt100_Pkg;
diff --git a/gcc/testsuite/gnat.dg/opt99.adb b/gcc/testsuite/gnat.dg/opt99.adb
new file mode 100644
index 00000000000..8805d47c122
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt99.adb
@@ -0,0 +1,15 @@
+-- { dg-do run }
+-- { dg-options "-O" }
+
+with Opt99_Pkg1; use Opt99_Pkg1;
+
+procedure Opt99 is
+  C : constant My_Character := (D => True, C => ' ');
+  D : Derived;
+
+begin
+  Set (D, C, C);
+  if not D.C2.D then
+    raise Program_Error;
+  end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/opt99_pkg1.adb b/gcc/testsuite/gnat.dg/opt99_pkg1.adb
new file mode 100644
index 00000000000..476b09c9524
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt99_pkg1.adb
@@ -0,0 +1,10 @@
+package body Opt99_Pkg1 is
+
+  procedure Set (D: in out Derived; C1, C2 : My_Character) is
+  begin
+    D.I  := 0;
+    D.C1 := C1;
+    D.C2 := C2;
+  end;
+
+end Opt99_Pkg1;
diff --git a/gcc/testsuite/gnat.dg/opt99_pkg1.ads b/gcc/testsuite/gnat.dg/opt99_pkg1.ads
new file mode 100644
index 00000000000..3e265616d14
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt99_pkg1.ads
@@ -0,0 +1,19 @@
+with Opt99_Pkg2;
+
+package Opt99_Pkg1 is
+
+  type My_Character (D : Boolean := False) is record
+    case D is
+      when False => null;
+      when True  => C : Character;
+    end case;
+  end record;
+
+  type Derived is new Opt99_Pkg2.Root with record
+    I : Integer;
+    C1, C2 : My_Character;
+  end record;
+
+  procedure Set (D: in out Derived; C1, C2 : My_Character);
+
+end Opt99_Pkg1;
diff --git a/gcc/testsuite/gnat.dg/opt99_pkg2.ads b/gcc/testsuite/gnat.dg/opt99_pkg2.ads
new file mode 100644
index 00000000000..09aaff14e01
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt99_pkg2.ads
@@ -0,0 +1,13 @@
+package Opt99_Pkg2 is
+
+  function Get_Max return Positive is (4);
+
+  C : constant Positive := Get_Max;
+
+  type Arr is array (1 .. C) of Integer;
+
+  type Root is tagged record
+    Data : Arr;
+  end record;
+
+end Opt99_Pkg2;
diff --git a/gcc/testsuite/gnat.dg/specs/coverage1.ads b/gcc/testsuite/gnat.dg/specs/coverage1.ads
new file mode 100644
index 00000000000..af7b61ce4e6
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/specs/coverage1.ads
@@ -0,0 +1,10 @@
+-- { dg-do compile }
+-- { dg-options "-ftest-coverage" }
+
+package Coverage1 is
+
+  type Rec is record
+    I : Integer := 0;
+  end record;
+
+end Coverage1;
diff --git a/gcc/testsuite/gnat.dg/specs/variant_part.ads b/gcc/testsuite/gnat.dg/specs/variant_part.ads
index afc92cde5d7..72da4108588 100644
--- a/gcc/testsuite/gnat.dg/specs/variant_part.ads
+++ b/gcc/testsuite/gnat.dg/specs/variant_part.ads
@@ -1,4 +1,5 @@
 -- { dg-do compile }
+
 package Variant_Part is
    type T1(b: boolean) is record
      case (b) is    -- { dg-error "discriminant name may not be parenthesized" }
diff --git a/gcc/testsuite/gnat.dg/specs/weak1.ads b/gcc/testsuite/gnat.dg/specs/weak1.ads
index 82cddc09ac2..ece05ea68a7 100644
--- a/gcc/testsuite/gnat.dg/specs/weak1.ads
+++ b/gcc/testsuite/gnat.dg/specs/weak1.ads
@@ -1,3 +1,5 @@
+-- { dg-do compile }
+
 package Weak1 is
 
    Myconst : constant Integer := 1234;
diff --git a/gcc/testsuite/gnat.dg/sso18.adb b/gcc/testsuite/gnat.dg/sso18.adb
new file mode 100644
index 00000000000..7496e965fd3
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/sso18.adb
@@ -0,0 +1,21 @@
+--  { dg-do run }
+--  { dg-options "-O2" }
+
+with System;
+
+procedure SSO18 is
+
+  type Arr is array (1..32) of Short_Integer;
+  type Rev_Arr is array (1..32) of Short_Integer
+    with Scalar_Storage_Order => System.High_Order_First;
+  C : constant Arr := (others => 16);
+  RA : Rev_Arr;
+  A  : Arr;
+
+begin
+  RA := Rev_Arr(C);
+  A := Arr (RA);
+  if A /= C or else RA(1) /= 16 then
+     raise Program_Error;
+  end if;
+end;
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index 244fe2306f4..3a4f65b9be6 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -6240,9 +6240,12 @@ proc check_effective_target_powerpc_sqrt { } {
     }
 
     return [check_no_compiler_messages powerpc_sqrt object {
+	void test (void)
+	{
 	#ifndef _ARCH_PPCSQ
 	#error _ARCH_PPCSQ is not defined
 	#endif
+	}
     } {}]
 }
 
@@ -6350,71 +6353,92 @@ proc check_effective_target_powerpc_p9modulo_ok { } {
 # as provided by the test.
 proc check_effective_target_has_arch_pwr5 { } {
 	return [check_no_compiler_messages_nocache arch_pwr5 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR5
 		#error does not have power5 support.
 		#else
 		/* "has power5 support" */
 		#endif
+		}
 	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr6 { } {
 	return [check_no_compiler_messages_nocache arch_pwr6 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR6
 		#error does not have power6 support.
 		#else
 		/* "has power6 support" */
 		#endif
+		}
 	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr7 { } {
 	return [check_no_compiler_messages_nocache arch_pwr7 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR7
 		#error does not have power7 support.
 		#else
 		/* "has power7 support" */
 		#endif
+		}
 	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr8 { } {
 	return [check_no_compiler_messages_nocache arch_pwr8 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR8
 		#error does not have power8 support.
 		#else
 		/* "has power8 support" */
 		#endif
+		}
 	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr9 { } {
 	return [check_no_compiler_messages_nocache arch_pwr9 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR9
 		#error does not have power9 support.
 		#else
 		/* "has power9 support" */
 		#endif
+		}
 	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr10 { } {
 	return [check_no_compiler_messages_nocache arch_pwr10 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR10
 		#error does not have power10 support.
 		#else
 		/* "has power10 support" */
 		#endif
+		}
 	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_ppc64 { } {
 	return [check_no_compiler_messages_nocache arch_ppc64 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PPC64
 		#error does not have ppc64 support.
 		#else
 		/* "has ppc64 support" */
 		#endif
+		}
 	} [current_compiler_flags]]
 }
 
@@ -6501,9 +6525,12 @@ proc check_effective_target_powerpc_float128_hw_ok { } {
 
 proc check_effective_target_ppc_float128 { } {
     return [check_no_compiler_messages_nocache ppc_float128 object {
+	void test (void)
+	{
 	#ifndef __FLOAT128__
 	  nope no good
 	#endif
+	}
     }]
 }
 
@@ -6511,9 +6538,12 @@ proc check_effective_target_ppc_float128 { } {
 
 proc check_effective_target_ppc_float128_insns { } {
     return [check_no_compiler_messages_nocache ppc_float128 object {
+	void test (void)
+	{
 	#ifndef __FLOAT128_HARDWARE__
 	  nope no good
 	#endif
+	}
     }]
 }
 
@@ -6521,9 +6551,12 @@ proc check_effective_target_ppc_float128_insns { } {
 
 proc check_effective_target_powerpc_vsx { } {
     return [check_no_compiler_messages_nocache powerpc_vsx object {
+	void test (void)
+	{
 	#ifndef __VSX__
 	  nope no vsx
 	#endif
+	}
     }]
 }
 
diff --git a/gcc/tree-cfg.cc b/gcc/tree-cfg.cc
index e321d929fd0..05fc4514714 100644
--- a/gcc/tree-cfg.cc
+++ b/gcc/tree-cfg.cc
@@ -3475,7 +3475,7 @@ verify_gimple_call (gcall *stmt)
       if (is_constant_size_arg0 && is_constant_size_lhs)
 	if (maybe_ne (size_from_arg0, size_from_lhs))
 	  {
-	    error ("%<DEFFERED_INIT%> calls should have same "
+	    error ("%<DEFERRED_INIT%> calls should have same "
 		   "constant size for the first argument and LHS");
 	    return true;
 	  }
@@ -7737,6 +7737,8 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,
       if (bb->loop_father->header == bb)
 	{
 	  class loop *this_loop = bb->loop_father;
+	  /* Avoid the need to remap SSA names used in nb_iterations.  */
+	  free_numbers_of_iterations_estimates (this_loop);
 	  class loop *outer = loop_outer (this_loop);
 	  if (outer == loop
 	      /* If the SESE region contains some bbs ending with
diff --git a/gcc/tree-loop-distribution.cc b/gcc/tree-loop-distribution.cc
index 086b59ca2be..606eb05e64a 100644
--- a/gcc/tree-loop-distribution.cc
+++ b/gcc/tree-loop-distribution.cc
@@ -1770,10 +1770,15 @@ loop_distribution::classify_builtin_ldst (loop_p loop, struct graph *rdg,
   if (res != 2)
     return;
 
-  /* They much have the same access size.  */
+  /* They must have the same access size.  */
   if (!operand_equal_p (size, src_size, 0))
     return;
 
+  /* They must have the same storage order.  */
+  if (reverse_storage_order_for_component_p (DR_REF (dst_dr))
+      != reverse_storage_order_for_component_p (DR_REF (src_dr)))
+    return;
+
   /* Load and store in loop nest must access memory in the same way, i.e,
      their must have the same steps in each loop of the nest.  */
   if (dst_steps.length () != src_steps.length ())
@@ -2181,8 +2186,6 @@ struct pg_edge_callback_data
   bitmap sccs_to_merge;
   /* Array constains component information for all vertices.  */
   int *vertices_component;
-  /* Array constains postorder information for all vertices.  */
-  int *vertices_post;
   /* Vector to record all data dependence relations which are needed
      to break strong connected components by runtime alias checks.  */
   vec<ddr_p> *alias_ddrs;
@@ -2432,6 +2435,33 @@ pg_collect_alias_ddrs (struct graph *g, struct graph_edge *e, void *data)
     cbdata->alias_ddrs->safe_splice (edata->alias_ddrs);
 }
 
+/* Callback function for traversing edge E.  DATA is private
+   callback data.  */
+
+static void
+pg_unmark_merged_alias_ddrs (struct graph *, struct graph_edge *e, void *data)
+{
+  int i, j, component;
+  struct pg_edge_callback_data *cbdata;
+  struct pg_edata *edata = (struct pg_edata *) e->data;
+
+  if (edata == NULL || edata->alias_ddrs.length () == 0)
+    return;
+
+  cbdata = (struct pg_edge_callback_data *) data;
+  i = e->src;
+  j = e->dest;
+  component = cbdata->vertices_component[i];
+  /* Make sure to not skip vertices inside SCCs we are going to merge.  */
+  if (component == cbdata->vertices_component[j]
+      && bitmap_bit_p (cbdata->sccs_to_merge, component))
+    {
+      edata->alias_ddrs.release ();
+      delete edata;
+      e->data = NULL;
+    }
+}
+
 /* This is the main function breaking strong conected components in
    PARTITIONS giving reduced depdendence graph RDG.  Store data dependence
    relations for runtime alias check in ALIAS_DDRS.  */
@@ -2491,7 +2521,6 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,
       cbdata.sccs_to_merge = sccs_to_merge;
       cbdata.alias_ddrs = alias_ddrs;
       cbdata.vertices_component = XNEWVEC (int, pg->n_vertices);
-      cbdata.vertices_post = XNEWVEC (int, pg->n_vertices);
       /* Record the component information which will be corrupted by next
 	 graph scc finding call.  */
       for (i = 0; i < pg->n_vertices; ++i)
@@ -2500,17 +2529,18 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,
       /* Collect data dependences for runtime alias checks to break SCCs.  */
       if (bitmap_count_bits (sccs_to_merge) != (unsigned) num_sccs)
 	{
-	  /* Record the postorder information which will be corrupted by next
-	     graph SCC finding call.  */
-	  for (i = 0; i < pg->n_vertices; ++i)
-	    cbdata.vertices_post[i] = pg->vertices[i].post;
+	  /* For SCCs we want to merge clear all alias_ddrs for edges
+	     inside the component.  */
+	  for_each_edge (pg, pg_unmark_merged_alias_ddrs, &cbdata);
 
 	  /* Run SCC finding algorithm again, with alias dependence edges
 	     skipped.  This is to topologically sort partitions according to
 	     compilation time known dependence.  Note the topological order
 	     is stored in the form of pg's post order number.  */
 	  num_sccs_no_alias = graphds_scc (pg, NULL, pg_skip_alias_edge);
-	  gcc_assert (partitions->length () == (unsigned) num_sccs_no_alias);
+	  /* We cannot assert partitions->length () == num_sccs_no_alias
+	     since we are not ignoring alias edges in cycles we are
+	     going to merge.  That's required to compute correct postorder.  */
 	  /* With topological order, we can construct two subgraphs L and R.
 	     L contains edge <x, y> where x < y in terms of post order, while
 	     R contains edge <x, y> where x > y.  Edges for compilation time
@@ -2545,16 +2575,14 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,
 	      first->type = PTYPE_SEQUENTIAL;
 	    }
 	}
-      /* Restore the postorder information if it's corrupted in finding SCC
-	 with alias dependence edges skipped.  If reduction partition's SCC is
-	 broken by runtime alias checks, we force a negative post order to it
-	 making sure it will be scheduled in the last.  */
+      /* If reduction partition's SCC is broken by runtime alias checks,
+	 we force a negative post order to it making sure it will be scheduled
+	 in the last.  */
       if (num_sccs_no_alias > 0)
 	{
 	  j = -1;
 	  for (i = 0; i < pg->n_vertices; ++i)
 	    {
-	      pg->vertices[i].post = cbdata.vertices_post[i];
 	      struct pg_vdata *data = (struct pg_vdata *)pg->vertices[i].data;
 	      if (data->partition && partition_reduction_p (data->partition))
 		{
@@ -2567,7 +2595,6 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,
 	}
 
       free (cbdata.vertices_component);
-      free (cbdata.vertices_post);
     }
 
   sort_partitions_by_post_order (pg, partitions);
diff --git a/gcc/tree-predcom.cc b/gcc/tree-predcom.cc
index fb457250bbd..3666b90ba5c 100644
--- a/gcc/tree-predcom.cc
+++ b/gcc/tree-predcom.cc
@@ -1771,10 +1771,24 @@ ref_at_iteration (data_reference_p dr, int iter,
 	  ref = TREE_OPERAND (ref, 0);
 	}
     }
-  tree addr = fold_build_pointer_plus (DR_BASE_ADDRESS (dr), off);
+  /* We may not associate the constant offset across the pointer plus
+     expression because that might form a pointer to before the object
+     then.  But for some cases we can retain that to allow tree_could_trap_p
+     to return false - see gcc.dg/tree-ssa/predcom-1.c  */
+  tree addr, alias_ptr;
+  if (integer_zerop  (off))
+    {
+      alias_ptr = fold_convert (reference_alias_ptr_type (ref), coff);
+      addr = DR_BASE_ADDRESS (dr);
+    }
+  else
+    {
+      alias_ptr = build_zero_cst (reference_alias_ptr_type (ref));
+      off = size_binop (PLUS_EXPR, off, coff);
+      addr = fold_build_pointer_plus (DR_BASE_ADDRESS (dr), off);
+    }
   addr = force_gimple_operand_1 (unshare_expr (addr), stmts,
 				 is_gimple_mem_ref_addr, NULL_TREE);
-  tree alias_ptr = fold_convert (reference_alias_ptr_type (ref), coff);
   tree type = build_aligned_type (TREE_TYPE (ref),
 				  get_object_alignment (ref));
   ref = build2 (MEM_REF, type, addr, alias_ptr);
diff --git a/gcc/tree-sra.cc b/gcc/tree-sra.cc
index 099e8dbe873..09dbd7be77f 100644
--- a/gcc/tree-sra.cc
+++ b/gcc/tree-sra.cc
@@ -260,6 +260,9 @@ struct access
 
   /* Should TREE_NO_WARNING of a replacement be set?  */
   unsigned grp_no_warning : 1;
+
+  /* Result of propagation accross link from LHS to RHS.  */
+  unsigned grp_result_of_prop_from_lhs : 1;
 };
 
 typedef struct access *access_p;
@@ -2532,6 +2535,9 @@ analyze_access_subtree (struct access *root, struct access *parent,
   if (allow_replacements && expr_with_var_bounded_array_refs_p (root->expr))
     allow_replacements = false;
 
+  if (!totally && root->grp_result_of_prop_from_lhs)
+    allow_replacements = false;
+
   for (child = root->first_child; child; child = child->next_sibling)
     {
       hole |= covered_to < child->offset;
@@ -2959,6 +2965,7 @@ propagate_subaccesses_from_lhs (struct access *lacc, struct access *racc)
 	  struct access *new_acc
 	    = create_artificial_child_access (racc, lchild, norm_offset,
 					      true, false);
+	  new_acc->grp_result_of_prop_from_lhs = 1;
 	  propagate_subaccesses_from_lhs (lchild, new_acc);
 	}
       else
@@ -3851,7 +3858,23 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)
 	    }
 	}
       else
-	*expr = repl;
+	{
+	  /* If we are going to replace a scalar field in a structure with
+	     reverse storage order by a stand-alone scalar, we are going to
+	     effectively byte-swap the scalar and we also need to byte-swap
+	     the portion of it represented by the bit-field.  */
+	  if (bfr && REF_REVERSE_STORAGE_ORDER (bfr))
+	    {
+	      REF_REVERSE_STORAGE_ORDER (bfr) = 0;
+	      TREE_OPERAND (bfr, 2)
+		= size_binop (MINUS_EXPR, TYPE_SIZE (TREE_TYPE (repl)),
+			      size_binop (PLUS_EXPR, TREE_OPERAND (bfr, 1),
+						     TREE_OPERAND (bfr, 2)));
+	    }
+
+	  *expr = repl;
+	}
+
       sra_stats.exprs++;
     }
   else if (write && access->grp_to_be_debug_replaced)
diff --git a/gcc/tree-ssa-dse.cc b/gcc/tree-ssa-dse.cc
index 881a2d0f98d..e647f0e7368 100644
--- a/gcc/tree-ssa-dse.cc
+++ b/gcc/tree-ssa-dse.cc
@@ -930,14 +930,6 @@ dse_classify_store (ao_ref *ref, gimple *stmt,
 
       if (gimple_code (temp) == GIMPLE_PHI)
 	{
-	  /* If we visit this PHI by following a backedge then we have to
-	     make sure ref->ref only refers to SSA names that are invariant
-	     with respect to the loop represented by this PHI node.  */
-	  if (dominated_by_p (CDI_DOMINATORS, gimple_bb (stmt),
-			      gimple_bb (temp))
-	      && !for_each_index (ref->ref ? &ref->ref : &ref->base,
-				  check_name, gimple_bb (temp)))
-	    return DSE_STORE_LIVE;
 	  defvar = PHI_RESULT (temp);
 	  bitmap_set_bit (visited, SSA_NAME_VERSION (defvar));
 	}
@@ -971,6 +963,15 @@ dse_classify_store (ao_ref *ref, gimple *stmt,
 	      if (!bitmap_bit_p (visited,
 				 SSA_NAME_VERSION (PHI_RESULT (use_stmt))))
 		{
+		  /* If we visit this PHI by following a backedge then we have
+		     to make sure ref->ref only refers to SSA names that are
+		     invariant with respect to the loop represented by this
+		     PHI node.  */
+		  if (dominated_by_p (CDI_DOMINATORS, gimple_bb (stmt),
+				      gimple_bb (use_stmt))
+		      && !for_each_index (ref->ref ? &ref->ref : &ref->base,
+					  check_name, gimple_bb (use_stmt)))
+		    return DSE_STORE_LIVE;
 		  defs.safe_push (use_stmt);
 		  if (!first_phi_def)
 		    first_phi_def = use_stmt;
diff --git a/gcc/tree-ssa-forwprop.cc b/gcc/tree-ssa-forwprop.cc
index 484491fa1c5..260d5dac83b 100644
--- a/gcc/tree-ssa-forwprop.cc
+++ b/gcc/tree-ssa-forwprop.cc
@@ -3118,7 +3118,11 @@ optimize_vector_load (gimple_stmt_iterator *gsi)
 	      && (def == lhs
 		  || (known_eq (bit_field_size (use_rhs), def_eltsize)
 		      && constant_multiple_p (bit_field_offset (use_rhs),
-					      def_eltsize))))
+					      def_eltsize)
+		      /* We can simulate the VEC_UNPACK_{HI,LO}_EXPR
+			 via a NOP_EXPR only for integral types.
+			 ???  Support VEC_UNPACK_FLOAT_{HI,LO}_EXPR.  */
+		      && INTEGRAL_TYPE_P (TREE_TYPE (use_rhs)))))
 	    {
 	      bf_stmts.safe_push (use_stmt);
 	      continue;
diff --git a/gcc/tree-ssa-loop-im.cc b/gcc/tree-ssa-loop-im.cc
index 6d9316eed1f..3926e5c14a4 100644
--- a/gcc/tree-ssa-loop-im.cc
+++ b/gcc/tree-ssa-loop-im.cc
@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "alias.h"
 #include "builtins.h"
 #include "tree-dfa.h"
+#include "tree-ssa.h"
 #include "dbgcnt.h"
 
 /* TODO:  Support for predicated code motion.  I.e.
@@ -331,8 +332,8 @@ enum move_pos
    because it may trap), return MOVE_PRESERVE_EXECUTION.
    Otherwise return MOVE_IMPOSSIBLE.  */
 
-enum move_pos
-movement_possibility (gimple *stmt)
+static enum move_pos
+movement_possibility_1 (gimple *stmt)
 {
   tree lhs;
   enum move_pos ret = MOVE_POSSIBLE;
@@ -422,6 +423,23 @@ movement_possibility (gimple *stmt)
   return ret;
 }
 
+static enum move_pos
+movement_possibility (gimple *stmt)
+{
+  enum move_pos pos = movement_possibility_1 (stmt);
+  if (pos == MOVE_POSSIBLE)
+    {
+      use_operand_p use_p;
+      ssa_op_iter ssa_iter;
+      FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, ssa_iter, SSA_OP_USE)
+	if (TREE_CODE (USE_FROM_PTR (use_p)) == SSA_NAME
+	    && ssa_name_maybe_undef_p (USE_FROM_PTR (use_p)))
+	  return MOVE_PRESERVE_EXECUTION;
+    }
+  return pos;
+}
+
+
 /* Compare the profile count inequality of bb and loop's preheader, it is
    three-state as stated in profile-count.h, FALSE is returned if inequality
    cannot be decided.  */
@@ -3524,6 +3542,8 @@ loop_invariant_motion_in_fun (function *fun, bool store_motion)
 
   tree_ssa_lim_initialize (store_motion);
 
+  mark_ssa_maybe_undefs ();
+
   /* Gathers information about memory accesses in the loops.  */
   analyze_memory_references (store_motion);
 
diff --git a/gcc/tree-ssa-loop-ivopts.cc b/gcc/tree-ssa-loop-ivopts.cc
index 549168aebd6..a67f5d549e6 100644
--- a/gcc/tree-ssa-loop-ivopts.cc
+++ b/gcc/tree-ssa-loop-ivopts.cc
@@ -3071,117 +3071,6 @@ get_loop_invariant_expr (struct ivopts_data *data, tree inv_expr)
   return *slot;
 }
 
-/* Return TRUE iff VAR is marked as maybe-undefined.  See
-   mark_ssa_maybe_undefs.  */
-
-static inline bool
-ssa_name_maybe_undef_p (tree var)
-{
-  gcc_checking_assert (TREE_CODE (var) == SSA_NAME);
-  return TREE_VISITED (var);
-}
-
-/* Set (or clear, depending on VALUE) VAR's maybe-undefined mark.  */
-
-static inline void
-ssa_name_set_maybe_undef (tree var, bool value = true)
-{
-  gcc_checking_assert (TREE_CODE (var) == SSA_NAME);
-  TREE_VISITED (var) = value;
-}
-
-/* Return TRUE iff there are any non-PHI uses of VAR that dominate the
-   end of BB.  If we return TRUE and BB is a loop header, then VAR we
-   be assumed to be defined within the loop, even if it is marked as
-   maybe-undefined.  */
-
-static inline bool
-ssa_name_any_use_dominates_bb_p (tree var, basic_block bb)
-{
-  imm_use_iterator iter;
-  use_operand_p use_p;
-  FOR_EACH_IMM_USE_FAST (use_p, iter, var)
-    {
-      if (is_a <gphi *> (USE_STMT (use_p))
-	  || is_gimple_debug (USE_STMT (use_p)))
-	continue;
-      basic_block dombb = gimple_bb (USE_STMT (use_p));
-      if (dominated_by_p (CDI_DOMINATORS, bb, dombb))
-	return true;
-    }
-
-  return false;
-}
-
-/* Mark as maybe_undef any SSA_NAMEs that are unsuitable as ivopts
-   candidates for potentially involving undefined behavior.  */
-
-static void
-mark_ssa_maybe_undefs (void)
-{
-  auto_vec<tree> queue;
-
-  /* Scan all SSA_NAMEs, marking the definitely-undefined ones as
-     maybe-undefined and queuing them for propagation, while clearing
-     the mark on others.  */
-  unsigned int i;
-  tree var;
-  FOR_EACH_SSA_NAME (i, var, cfun)
-    {
-      if (SSA_NAME_IS_VIRTUAL_OPERAND (var)
-	  || !ssa_undefined_value_p (var, false))
-	ssa_name_set_maybe_undef (var, false);
-      else
-	{
-	  ssa_name_set_maybe_undef (var);
-	  queue.safe_push (var);
-	  if (dump_file && (dump_flags & TDF_DETAILS))
-	    fprintf (dump_file, "marking _%i as maybe-undef\n",
-		     SSA_NAME_VERSION (var));
-	}
-    }
-
-  /* Now propagate maybe-undefined from a DEF to any other PHI that
-     uses it, as long as there isn't any intervening use of DEF.  */
-  while (!queue.is_empty ())
-    {
-      var = queue.pop ();
-      imm_use_iterator iter;
-      use_operand_p use_p;
-      FOR_EACH_IMM_USE_FAST (use_p, iter, var)
-	{
-	  /* Any uses of VAR that aren't PHI args imply VAR must be
-	     defined, otherwise undefined behavior would have been
-	     definitely invoked.  Only PHI args may hold
-	     maybe-undefined values without invoking undefined
-	     behavior for that reason alone.  */
-	  if (!is_a <gphi *> (USE_STMT (use_p)))
-	    continue;
-	  gphi *phi = as_a <gphi *> (USE_STMT (use_p));
-
-	  tree def = gimple_phi_result (phi);
-	  if (ssa_name_maybe_undef_p (def))
-	    continue;
-
-	  /* Look for any uses of the maybe-unused SSA_NAME that
-	     dominates the block that reaches the incoming block
-	     corresponding to the PHI arg in which it is mentioned.
-	     That means we can assume the SSA_NAME is defined in that
-	     path, so we only mark a PHI result as maybe-undef if we
-	     find an unused reaching SSA_NAME.  */
-	  int idx = phi_arg_index_from_use (use_p);
-	  basic_block bb = gimple_phi_arg_edge (phi, idx)->src;
-	  if (ssa_name_any_use_dominates_bb_p (var, bb))
-	    continue;
-
-	  ssa_name_set_maybe_undef (def);
-	  queue.safe_push (def);
-	  if (dump_file && (dump_flags & TDF_DETAILS))
-	    fprintf (dump_file, "marking _%i as maybe-undef because of _%i\n",
-		     SSA_NAME_VERSION (def), SSA_NAME_VERSION (var));
-	}
-    }
-}
 
 /* Return *TP if it is an SSA_NAME marked with TREE_VISITED, i.e., as
    unsuitable as ivopts candidates for potentially involving undefined
diff --git a/gcc/tree-ssa-loop-split.cc b/gcc/tree-ssa-loop-split.cc
index b93ee4c8769..b819c0676c9 100644
--- a/gcc/tree-ssa-loop-split.cc
+++ b/gcc/tree-ssa-loop-split.cc
@@ -533,16 +533,17 @@ split_loop (class loop *loop1)
   tree guard_iv;
   tree border = NULL_TREE;
   affine_iv iv;
+  edge exit1;
 
-  if (!single_exit (loop1)
+  if (!(exit1 = single_exit (loop1))
+      || EDGE_COUNT (exit1->src->succs) != 2
       /* ??? We could handle non-empty latches when we split the latch edge
 	 (not the exit edge), and put the new exit condition in the new block.
 	 OTOH this executes some code unconditionally that might have been
 	 skipped by the original exit before.  */
       || !empty_block_p (loop1->latch)
       || !easy_exit_values (loop1)
-      || !number_of_iterations_exit (loop1, single_exit (loop1), &niter,
-				     false, true)
+      || !number_of_iterations_exit (loop1, exit1, &niter, false, true)
       || niter.cmp == ERROR_MARK
       /* We can't yet handle loops controlled by a != predicate.  */
       || niter.cmp == NE_EXPR)
@@ -646,10 +647,13 @@ split_loop (class loop *loop1)
 	fix_loop_bb_probability (loop1, loop2, true_edge, false_edge);
 
 	/* Fix first loop's exit probability after scaling.  */
-	edge exit_to_latch1 = single_pred_edge (loop1->latch);
+	edge exit_to_latch1;
+	if (EDGE_SUCC (exit1->src, 0) == exit1)
+	  exit_to_latch1 = EDGE_SUCC (exit1->src, 1);
+	else
+	  exit_to_latch1 = EDGE_SUCC (exit1->src, 0);
 	exit_to_latch1->probability *= true_edge->probability;
-	single_exit (loop1)->probability
-	  = exit_to_latch1->probability.invert ();
+	exit1->probability = exit_to_latch1->probability.invert ();
 
 	/* Finally patch out the two copies of the condition to be always
 	   true/false (or opposite).  */
diff --git a/gcc/tree-ssa-pre.cc b/gcc/tree-ssa-pre.cc
index 47d70c85c3c..98134b5d3ad 100644
--- a/gcc/tree-ssa-pre.cc
+++ b/gcc/tree-ssa-pre.cc
@@ -1248,7 +1248,11 @@ translate_vuse_through_block (vec<vn_reference_op_s> operands,
   if (same_valid)
     *same_valid = true;
 
-  if (gimple_bb (phi) != phiblock)
+  /* If value-numbering provided a memory state for this
+     that dominates PHIBLOCK we can just use that.  */
+  if (gimple_nop_p (phi)
+      || (gimple_bb (phi) != phiblock
+	  && dominated_by_p (CDI_DOMINATORS, phiblock, gimple_bb (phi))))
     return vuse;
 
   /* We have pruned expressions that are killed in PHIBLOCK via
@@ -2043,11 +2047,13 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)
 	    {
 	      gimple *def_stmt = SSA_NAME_DEF_STMT (ref->vuse);
 	      if (!gimple_nop_p (def_stmt)
-		  && ((gimple_bb (def_stmt) != block
-		       && !dominated_by_p (CDI_DOMINATORS,
-					   block, gimple_bb (def_stmt)))
-		      || (gimple_bb (def_stmt) == block
-			  && value_dies_in_block_x (expr, block))))
+		  /* If value-numbering provided a memory state for this
+		     that dominates BLOCK we're done, otherwise we have
+		     to check if the value dies in BLOCK.  */
+		  && !(gimple_bb (def_stmt) != block
+		       && dominated_by_p (CDI_DOMINATORS,
+					  block, gimple_bb (def_stmt)))
+		  && value_dies_in_block_x (expr, block))
 		to_remove = i;
 	    }
 	  /* If the REFERENCE may trap make sure the block does not contain
diff --git a/gcc/tree-ssa-sccvn.cc b/gcc/tree-ssa-sccvn.cc
index e22c7026556..a63f5c8c307 100644
--- a/gcc/tree-ssa-sccvn.cc
+++ b/gcc/tree-ssa-sccvn.cc
@@ -1802,7 +1802,8 @@ struct vn_walk_cb_data
 		   vn_lookup_kind vn_walk_kind_, bool tbaa_p_, tree mask_,
 		   bool redundant_store_removal_p_)
     : vr (vr_), last_vuse_ptr (last_vuse_ptr_), last_vuse (NULL_TREE),
-      mask (mask_), masked_result (NULL_TREE), vn_walk_kind (vn_walk_kind_),
+      mask (mask_), masked_result (NULL_TREE), same_val (NULL_TREE),
+      vn_walk_kind (vn_walk_kind_),
       tbaa_p (tbaa_p_), redundant_store_removal_p (redundant_store_removal_p_),
       saved_operands (vNULL), first_set (-2), first_base_set (-2),
       known_ranges (NULL)
@@ -1862,6 +1863,7 @@ struct vn_walk_cb_data
   tree last_vuse;
   tree mask;
   tree masked_result;
+  tree same_val;
   vn_lookup_kind vn_walk_kind;
   bool tbaa_p;
   bool redundant_store_removal_p;
@@ -1900,6 +1902,8 @@ vn_walk_cb_data::finish (alias_set_type set, alias_set_type base_set, tree val)
       masked_result = val;
       return (void *) -1;
     }
+  if (same_val && !operand_equal_p (val, same_val))
+    return (void *) -1;
   vec<vn_reference_op_s> &operands
     = saved_operands.exists () ? saved_operands : vr->operands;
   return vn_reference_lookup_or_insert_for_pieces (last_vuse, set, base_set,
@@ -2666,36 +2670,61 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
 	 and return the found value.  */
       if (is_gimple_reg_type (TREE_TYPE (lhs))
 	  && types_compatible_p (TREE_TYPE (lhs), vr->type)
-	  && (ref->ref || data->orig_ref.ref))
-	{
-	  tree *saved_last_vuse_ptr = data->last_vuse_ptr;
-	  /* Do not update last_vuse_ptr in vn_reference_lookup_2.  */
-	  data->last_vuse_ptr = NULL;
-	  tree saved_vuse = vr->vuse;
-	  hashval_t saved_hashcode = vr->hashcode;
-	  void *res = vn_reference_lookup_2 (ref, gimple_vuse (def_stmt), data);
-	  /* Need to restore vr->vuse and vr->hashcode.  */
-	  vr->vuse = saved_vuse;
-	  vr->hashcode = saved_hashcode;
-	  data->last_vuse_ptr = saved_last_vuse_ptr;
-	  if (res && res != (void *)-1)
+	  && (ref->ref || data->orig_ref.ref)
+	  && !data->mask
+	  && data->partial_defs.is_empty ()
+	  && multiple_p (get_object_alignment
+			   (ref->ref ? ref->ref : data->orig_ref.ref),
+			   ref->size)
+	  && multiple_p (get_object_alignment (lhs), ref->size))
+	{
+	  tree rhs = gimple_assign_rhs1 (def_stmt);
+	  /* ???  We may not compare to ahead values which might be from
+	     a different loop iteration but only to loop invariants.  Use
+	     CONSTANT_CLASS_P (unvalueized!) as conservative approximation.
+	     The one-hop lookup below doesn't have this issue since there's
+	     a virtual PHI before we ever reach a backedge to cross.
+	     We can skip multiple defs as long as they are from the same
+	     value though.  */
+	  if (data->same_val
+	      && !operand_equal_p (data->same_val, rhs))
+	    ;
+	  else if (CONSTANT_CLASS_P (rhs))
 	    {
-	      vn_reference_t vnresult = (vn_reference_t) res;
-	      tree rhs = gimple_assign_rhs1 (def_stmt);
-	      if (TREE_CODE (rhs) == SSA_NAME)
-		rhs = SSA_VAL (rhs);
-	      if (vnresult->result
-		  && operand_equal_p (vnresult->result, rhs, 0)
-		  /* We have to honor our promise about union type punning
-		     and also support arbitrary overlaps with
-		     -fno-strict-aliasing.  So simply resort to alignment to
-		     rule out overlaps.  Do this check last because it is
-		     quite expensive compared to the hash-lookup above.  */
-		  && multiple_p (get_object_alignment
-				   (ref->ref ? ref->ref : data->orig_ref.ref),
-				 ref->size)
-		  && multiple_p (get_object_alignment (lhs), ref->size))
-		return res;
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		{
+		  fprintf (dump_file,
+			   "Skipping possible redundant definition ");
+		  print_gimple_stmt (dump_file, def_stmt, 0);
+		}
+	      /* Delay the actual compare of the values to the end of the walk
+		 but do not update last_vuse from here.  */
+	      data->last_vuse_ptr = NULL;
+	      data->same_val = rhs;
+	      return NULL;
+	    }
+	  else
+	    {
+	      tree *saved_last_vuse_ptr = data->last_vuse_ptr;
+	      /* Do not update last_vuse_ptr in vn_reference_lookup_2.  */
+	      data->last_vuse_ptr = NULL;
+	      tree saved_vuse = vr->vuse;
+	      hashval_t saved_hashcode = vr->hashcode;
+	      void *res = vn_reference_lookup_2 (ref, gimple_vuse (def_stmt),
+						 data);
+	      /* Need to restore vr->vuse and vr->hashcode.  */
+	      vr->vuse = saved_vuse;
+	      vr->hashcode = saved_hashcode;
+	      data->last_vuse_ptr = saved_last_vuse_ptr;
+	      if (res && res != (void *)-1)
+		{
+		  vn_reference_t vnresult = (vn_reference_t) res;
+		  if (TREE_CODE (rhs) == SSA_NAME)
+		    rhs = SSA_VAL (rhs);
+		  if (vnresult->result
+		      && operand_equal_p (vnresult->result, rhs, 0))
+		    return res;
+		}
 	    }
 	}
     }
@@ -3656,6 +3685,14 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set,
       if (ops_for_ref != shared_lookup_references)
 	ops_for_ref.release ();
       gcc_checking_assert (vr1.operands == shared_lookup_references);
+      if (*vnresult
+	  && data.same_val
+	  && (!(*vnresult)->result
+	      || !operand_equal_p ((*vnresult)->result, data.same_val)))
+	{
+	  *vnresult = NULL;
+	  return NULL_TREE;
+	}
     }
 
   if (*vnresult)
@@ -3734,6 +3771,10 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,
       if (wvnresult)
 	{
 	  gcc_assert (mask == NULL_TREE);
+	  if (data.same_val
+	      && (!wvnresult->result
+		  || !operand_equal_p (wvnresult->result, data.same_val)))
+	    return NULL_TREE;
 	  if (vnresult)
 	    *vnresult = wvnresult;
 	  return wvnresult->result;
@@ -4660,41 +4701,44 @@ dominated_by_p_w_unex (basic_block bb1, basic_block bb2, bool allow_back)
     }
 
   /* Iterate to the single executable bb2 successor.  */
-  edge succe = NULL;
-  FOR_EACH_EDGE (e, ei, bb2->succs)
-    if ((e->flags & EDGE_EXECUTABLE)
-	|| (!allow_back && (e->flags & EDGE_DFS_BACK)))
-      {
-	if (succe)
-	  {
-	    succe = NULL;
-	    break;
-	  }
-	succe = e;
-      }
-  if (succe)
+  if (EDGE_COUNT (bb2->succs) > 1)
     {
-      /* Verify the reached block is only reached through succe.
-	 If there is only one edge we can spare us the dominator
-	 check and iterate directly.  */
-      if (EDGE_COUNT (succe->dest->preds) > 1)
-	{
-	  FOR_EACH_EDGE (e, ei, succe->dest->preds)
-	    if (e != succe
-		&& ((e->flags & EDGE_EXECUTABLE)
-		    || (!allow_back && (e->flags & EDGE_DFS_BACK))))
+      edge succe = NULL;
+      FOR_EACH_EDGE (e, ei, bb2->succs)
+	if ((e->flags & EDGE_EXECUTABLE)
+	    || (!allow_back && (e->flags & EDGE_DFS_BACK)))
+	  {
+	    if (succe)
 	      {
 		succe = NULL;
 		break;
 	      }
-	}
+	    succe = e;
+	  }
       if (succe)
 	{
-	  bb2 = succe->dest;
+	  /* Verify the reached block is only reached through succe.
+	     If there is only one edge we can spare us the dominator
+	     check and iterate directly.  */
+	  if (EDGE_COUNT (succe->dest->preds) > 1)
+	    {
+	      FOR_EACH_EDGE (e, ei, succe->dest->preds)
+		if (e != succe
+		    && ((e->flags & EDGE_EXECUTABLE)
+			|| (!allow_back && (e->flags & EDGE_DFS_BACK))))
+		  {
+		    succe = NULL;
+		    break;
+		  }
+	    }
+	  if (succe)
+	    {
+	      bb2 = succe->dest;
 
-	  /* Re-do the dominance check with changed bb2.  */
-	  if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))
-	    return true;
+	      /* Re-do the dominance check with changed bb2.  */
+	      if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))
+		return true;
+	    }
 	}
     }
 
@@ -5446,19 +5490,6 @@ visit_reference_op_store (tree lhs, tree op, gimple *stmt)
 
   if (!resultsame)
     {
-      /* Only perform the following when being called from PRE
-	 which embeds tail merging.  */
-      if (default_vn_walk_kind == VN_WALK)
-	{
-	  assign = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, op);
-	  vn_reference_lookup (assign, vuse, VN_NOWALK, &vnresult, false);
-	  if (vnresult)
-	    {
-	      VN_INFO (vdef)->visited = true;
-	      return set_ssa_val_to (vdef, vnresult->result_vdef);
-	    }
-	}
-
       if (dump_file && (dump_flags & TDF_DETAILS))
 	{
 	  fprintf (dump_file, "No store match\n");
@@ -5483,7 +5514,9 @@ visit_reference_op_store (tree lhs, tree op, gimple *stmt)
       if (default_vn_walk_kind == VN_WALK)
 	{
 	  assign = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, op);
-	  vn_reference_insert (assign, lhs, vuse, vdef);
+	  vn_reference_lookup (assign, vuse, VN_NOWALK, &vnresult, false);
+	  if (!vnresult)
+	    vn_reference_insert (assign, lhs, vuse, vdef);
 	}
     }
   else
diff --git a/gcc/tree-ssa-strlen.cc b/gcc/tree-ssa-strlen.cc
index 9ae25d1dde2..2d7db6da5bc 100644
--- a/gcc/tree-ssa-strlen.cc
+++ b/gcc/tree-ssa-strlen.cc
@@ -1136,14 +1136,15 @@ get_range_strlen_phi (tree src, gphi *phi,
 
       /* Adjust the minimum and maximum length determined so far and
 	 the upper bound on the array size.  */
-      if (!pdata->minlen
-	  || tree_int_cst_lt (argdata.minlen, pdata->minlen))
+      if (TREE_CODE (argdata.minlen) == INTEGER_CST
+	  && (!pdata->minlen
+	      || tree_int_cst_lt (argdata.minlen, pdata->minlen)))
 	pdata->minlen = argdata.minlen;
 
-      if (!pdata->maxlen
-	  || (argdata.maxlen
-	      && TREE_CODE (argdata.maxlen) == INTEGER_CST
-	      && tree_int_cst_lt (pdata->maxlen, argdata.maxlen)))
+      if (TREE_CODE (argdata.maxlen) == INTEGER_CST
+	  && (!pdata->maxlen
+	      || (argdata.maxlen
+		  && tree_int_cst_lt (pdata->maxlen, argdata.maxlen))))
 	pdata->maxlen = argdata.maxlen;
 
       if (!pdata->maxbound
diff --git a/gcc/tree-ssa-uninit.cc b/gcc/tree-ssa-uninit.cc
index f326f1775c0..30aafda68f7 100644
--- a/gcc/tree-ssa-uninit.cc
+++ b/gcc/tree-ssa-uninit.cc
@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "gimple-predicate-analysis.h"
 #include "domwalk.h"
 #include "tree-ssa-sccvn.h"
+#include "cfganal.h"
 
 /* This implements the pass that does predicate aware warning on uses of
    possibly uninitialized variables.  The pass first collects the set of
@@ -1191,8 +1192,16 @@ find_uninit_use (gphi *phi, unsigned uninit_opnds,
 
       basic_block use_bb;
       if (gphi *use_phi = dyn_cast<gphi *> (use_stmt))
-	use_bb = gimple_phi_arg_edge (use_phi,
-				      PHI_ARG_INDEX_FROM_USE (use_p))->src;
+	{
+	  edge e = gimple_phi_arg_edge (use_phi,
+					PHI_ARG_INDEX_FROM_USE (use_p));
+	  use_bb = e->src;
+	  /* Do not look for uses in the next iteration of a loop, predicate
+	     analysis will not use the appropriate predicates to prove
+	     reachability.  */
+	  if (e->flags & EDGE_DFS_BACK)
+	    continue;
+	}
       else
 	use_bb = gimple_bb (use_stmt);
 
@@ -1339,6 +1348,7 @@ execute_late_warn_uninitialized (function *fun)
   /* Mark all edges executable, warn_uninitialized_vars will skip
      unreachable blocks.  */
   set_all_edges_as_executable (fun);
+  mark_dfs_back_edges (fun);
 
   /* Re-do the plain uninitialized variable check, as optimization may have
      straightened control flow.  Do this first so that we don't accidentally
diff --git a/gcc/tree-ssa.cc b/gcc/tree-ssa.cc
index a362a0a9ea6..d36d2273f9d 100644
--- a/gcc/tree-ssa.cc
+++ b/gcc/tree-ssa.cc
@@ -1400,6 +1400,99 @@ gimple_uses_undefined_value_p (gimple *stmt)
 }
 
 
+/* Return TRUE iff there are any non-PHI uses of VAR that dominate the
+   end of BB.  If we return TRUE and BB is a loop header, then VAR we
+   be assumed to be defined within the loop, even if it is marked as
+   maybe-undefined.  */
+
+bool
+ssa_name_any_use_dominates_bb_p (tree var, basic_block bb)
+{
+  imm_use_iterator iter;
+  use_operand_p use_p;
+  FOR_EACH_IMM_USE_FAST (use_p, iter, var)
+    {
+      if (is_a <gphi *> (USE_STMT (use_p))
+	  || is_gimple_debug (USE_STMT (use_p)))
+	continue;
+      basic_block dombb = gimple_bb (USE_STMT (use_p));
+      if (dominated_by_p (CDI_DOMINATORS, bb, dombb))
+	return true;
+    }
+
+  return false;
+}
+
+/* Mark as maybe_undef any SSA_NAMEs that are unsuitable as ivopts
+   candidates for potentially involving undefined behavior.  */
+
+void
+mark_ssa_maybe_undefs (void)
+{
+  auto_vec<tree> queue;
+
+  /* Scan all SSA_NAMEs, marking the definitely-undefined ones as
+     maybe-undefined and queuing them for propagation, while clearing
+     the mark on others.  */
+  unsigned int i;
+  tree var;
+  FOR_EACH_SSA_NAME (i, var, cfun)
+    {
+      if (SSA_NAME_IS_VIRTUAL_OPERAND (var)
+	  || !ssa_undefined_value_p (var, false))
+	ssa_name_set_maybe_undef (var, false);
+      else
+	{
+	  ssa_name_set_maybe_undef (var);
+	  queue.safe_push (var);
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file, "marking _%i as maybe-undef\n",
+		     SSA_NAME_VERSION (var));
+	}
+    }
+
+  /* Now propagate maybe-undefined from a DEF to any other PHI that
+     uses it, as long as there isn't any intervening use of DEF.  */
+  while (!queue.is_empty ())
+    {
+      var = queue.pop ();
+      imm_use_iterator iter;
+      use_operand_p use_p;
+      FOR_EACH_IMM_USE_FAST (use_p, iter, var)
+	{
+	  /* Any uses of VAR that aren't PHI args imply VAR must be
+	     defined, otherwise undefined behavior would have been
+	     definitely invoked.  Only PHI args may hold
+	     maybe-undefined values without invoking undefined
+	     behavior for that reason alone.  */
+	  if (!is_a <gphi *> (USE_STMT (use_p)))
+	    continue;
+	  gphi *phi = as_a <gphi *> (USE_STMT (use_p));
+
+	  tree def = gimple_phi_result (phi);
+	  if (ssa_name_maybe_undef_p (def))
+	    continue;
+
+	  /* Look for any uses of the maybe-unused SSA_NAME that
+	     dominates the block that reaches the incoming block
+	     corresponding to the PHI arg in which it is mentioned.
+	     That means we can assume the SSA_NAME is defined in that
+	     path, so we only mark a PHI result as maybe-undef if we
+	     find an unused reaching SSA_NAME.  */
+	  int idx = phi_arg_index_from_use (use_p);
+	  basic_block bb = gimple_phi_arg_edge (phi, idx)->src;
+	  if (ssa_name_any_use_dominates_bb_p (var, bb))
+	    continue;
+
+	  ssa_name_set_maybe_undef (def);
+	  queue.safe_push (def);
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file, "marking _%i as maybe-undef because of _%i\n",
+		     SSA_NAME_VERSION (def), SSA_NAME_VERSION (var));
+	}
+    }
+}
+
 
 /* If necessary, rewrite the base of the reference tree *TP from
    a MEM_REF to a plain or converted symbol.  */
@@ -1459,6 +1552,8 @@ maybe_rewrite_mem_ref_base (tree *tp, bitmap suitable_for_renaming)
 	       && (! INTEGRAL_TYPE_P (TREE_TYPE (*tp)) 
 		   || (wi::to_offset (TYPE_SIZE (TREE_TYPE (*tp)))
 		       == TYPE_PRECISION (TREE_TYPE (*tp))))
+	       && (! INTEGRAL_TYPE_P (TREE_TYPE (sym))
+		   || type_has_mode_precision_p (TREE_TYPE (sym)))
 	       && wi::umod_trunc (wi::to_offset (TYPE_SIZE (TREE_TYPE (*tp))),
 				  BITS_PER_UNIT) == 0)
 	{
@@ -1531,6 +1626,10 @@ non_rewritable_mem_ref_base (tree ref)
 	  && (! INTEGRAL_TYPE_P (TREE_TYPE (base))
 	      || (wi::to_offset (TYPE_SIZE (TREE_TYPE (base)))
 		  == TYPE_PRECISION (TREE_TYPE (base))))
+	  /* ???  Likewise for extracts from bitfields, we'd have
+	     to pun the base object to a size precision mode first.  */
+	  && (! INTEGRAL_TYPE_P (TREE_TYPE (decl))
+	      || type_has_mode_precision_p (TREE_TYPE (decl)))
 	  && wi::umod_trunc (wi::to_offset (TYPE_SIZE (TREE_TYPE (base))),
 			     BITS_PER_UNIT) == 0)
 	return NULL_TREE;
diff --git a/gcc/tree-ssa.h b/gcc/tree-ssa.h
index 008535454a8..19c1eedc9f9 100644
--- a/gcc/tree-ssa.h
+++ b/gcc/tree-ssa.h
@@ -55,6 +55,31 @@ extern tree find_released_ssa_name (tree *, int *, void *);
 extern bool ssa_defined_default_def_p (tree t);
 extern bool ssa_undefined_value_p (tree, bool = true);
 extern bool gimple_uses_undefined_value_p (gimple *);
+
+
+bool ssa_name_any_use_dominates_bb_p (tree var, basic_block bb);
+extern void mark_ssa_maybe_undefs (void);
+
+/* Return TRUE iff VAR is marked as maybe-undefined.  See
+   mark_ssa_maybe_undefs.  */
+
+static inline bool
+ssa_name_maybe_undef_p (tree var)
+{
+  gcc_checking_assert (TREE_CODE (var) == SSA_NAME);
+  return TREE_VISITED (var);
+}
+
+/* Set (or clear, depending on VALUE) VAR's maybe-undefined mark.  */
+
+static inline void
+ssa_name_set_maybe_undef (tree var, bool value = true)
+{
+  gcc_checking_assert (TREE_CODE (var) == SSA_NAME);
+  TREE_VISITED (var) = value;
+}
+
+
 extern void execute_update_addresses_taken (void);
 
 /* Given an edge_var_map V, return the PHI arg definition.  */
diff --git a/gcc/tree-vect-loop.cc b/gcc/tree-vect-loop.cc
index aed14e9b686..001f7dd8ab3 100644
--- a/gcc/tree-vect-loop.cc
+++ b/gcc/tree-vect-loop.cc
@@ -4287,7 +4287,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,
       if (dump_enabled_p ())
 	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
 			 "can't unroll as unrolled vectorization factor larger"
-			 " than maximum vectorization factor: %d\n",
+			 " than maximum vectorization factor: "
+			 HOST_WIDE_INT_PRINT_UNSIGNED "\n",
 			 LOOP_VINFO_MAX_VECT_FACTOR (loop_vinfo));
       *suggested_unroll_factor = 1;
     }
@@ -6082,7 +6083,8 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,
     }
 
   /* Record this operation if it could be reused by the epilogue loop.  */
-  if (STMT_VINFO_REDUC_TYPE (reduc_info) == TREE_CODE_REDUCTION)
+  if (STMT_VINFO_REDUC_TYPE (reduc_info) == TREE_CODE_REDUCTION
+      && vec_num == 1)
     loop_vinfo->reusable_accumulators.put (scalar_results[0],
 					   { orig_reduc_input, reduc_info });
 
@@ -6677,10 +6679,20 @@ vectorizable_reduction (loop_vec_info loop_vinfo,
 	}
       if (!REDUC_GROUP_FIRST_ELEMENT (vdef))
 	only_slp_reduc_chain = false;
-      /* ???  For epilogue generation live members of the chain need
+      /* For epilogue generation live members of the chain need
          to point back to the PHI via their original stmt for
-	 info_for_reduction to work.  */
-      if (STMT_VINFO_LIVE_P (vdef))
+	 info_for_reduction to work.  For SLP we need to look at
+	 all lanes here - even though we only will vectorize from
+	 the SLP node with live lane zero the other live lanes also
+	 need to be identified as part of a reduction to be able
+	 to skip code generation for them.  */
+      if (slp_for_stmt_info)
+	{
+	  for (auto s : SLP_TREE_SCALAR_STMTS (slp_for_stmt_info))
+	    if (STMT_VINFO_LIVE_P (s))
+	      STMT_VINFO_REDUC_DEF (vect_orig_stmt (s)) = phi_info;
+	}
+      else if (STMT_VINFO_LIVE_P (vdef))
 	STMT_VINFO_REDUC_DEF (def) = phi_info;
       gimple_match_op op;
       if (!gimple_extract_op (vdef->stmt, &op))
@@ -8753,10 +8765,6 @@ vectorizable_live_operation (vec_info *vinfo,
 	     all involved stmts together.  */
 	  else if (slp_index != 0)
 	    return true;
-	  else
-	    /* For SLP reductions the meta-info is attached to
-	       the representative.  */
-	    stmt_info = SLP_TREE_REPRESENTATIVE (slp_node);
 	}
       stmt_vec_info reduc_info = info_for_reduction (loop_vinfo, stmt_info);
       gcc_assert (reduc_info->is_reduc_info);
diff --git a/gcc/tree-vect-patterns.cc b/gcc/tree-vect-patterns.cc
index 217bdfd7045..6c157b93eb1 100644
--- a/gcc/tree-vect-patterns.cc
+++ b/gcc/tree-vect-patterns.cc
@@ -4603,6 +4603,8 @@ vect_recog_mask_conversion_pattern (vec_info *vinfo,
       else
 	{
 	  lhs = gimple_call_lhs (last_stmt);
+	  if (!lhs)
+	    return NULL;
 	  vectype1 = get_vectype_for_scalar_type (vinfo, TREE_TYPE (lhs));
 	}
 
diff --git a/gcc/tree-vect-slp-patterns.cc b/gcc/tree-vect-slp-patterns.cc
index 879d17fd947..9157d713291 100644
--- a/gcc/tree-vect-slp-patterns.cc
+++ b/gcc/tree-vect-slp-patterns.cc
@@ -96,8 +96,8 @@ vect_pattern_validate_optab (internal_fn ifn, slp_tree node)
         {
 	  if (!vectype)
 	    dump_printf_loc (MSG_NOTE, vect_location,
-			     "Target does not support vector type for %T\n",
-			     SLP_TREE_DEF_TYPE (node));
+			     "Target does not support vector type for %G\n",
+			     STMT_VINFO_STMT (SLP_TREE_REPRESENTATIVE (node)));
 	  else
 	    dump_printf_loc (MSG_NOTE, vect_location,
 			     "Target does not support %s for vector type "
@@ -1035,8 +1035,11 @@ complex_mul_pattern::matches (complex_operation_t op,
   auto_vec<slp_tree> left_op, right_op;
   slp_tree add0 = NULL;
 
-  /* Check if we may be a multiply add.  */
+  /* Check if we may be a multiply add.  It's only valid to form FMAs
+     with -ffp-contract=fast.  */
   if (!mul0
+      && (flag_fp_contract_mode == FP_CONTRACT_FAST
+	  || !FLOAT_TYPE_P (SLP_TREE_VECTYPE (*node)))
       && vect_match_expression_p (l0node[0], PLUS_EXPR))
     {
       auto vals = SLP_TREE_CHILDREN (l0node[0]);
@@ -1501,9 +1504,13 @@ addsub_pattern::recognize (slp_tree_to_load_perm_map_t *,
     }
 
   /* Now we have either { -, +, -, + ... } (!l0add_p) or { +, -, +, - ... }
-     (l0add_p), see whether we have FMA variants.  */
-  if (!l0add_p
-      && vect_match_expression_p (SLP_TREE_CHILDREN (l0node)[0], MULT_EXPR))
+     (l0add_p), see whether we have FMA variants.  We can only form FMAs
+     if allowed via -ffp-contract=fast.  */
+  if (flag_fp_contract_mode != FP_CONTRACT_FAST
+      && FLOAT_TYPE_P (SLP_TREE_VECTYPE (l0node)))
+    ;
+  else if (!l0add_p
+	   && vect_match_expression_p (SLP_TREE_CHILDREN (l0node)[0], MULT_EXPR))
     {
       /* (c * d) -+ a */
       if (vect_pattern_validate_optab (IFN_VEC_FMADDSUB, node))
diff --git a/gcc/tree-vect-slp.cc b/gcc/tree-vect-slp.cc
index 0d400c00df1..ec9c10a7b96 100644
--- a/gcc/tree-vect-slp.cc
+++ b/gcc/tree-vect-slp.cc
@@ -2468,7 +2468,9 @@ vect_print_slp_tree (dump_flags_t dump_kind, dump_location_t loc,
 
   dump_metadata_t metadata (dump_kind, loc.get_impl_location ());
   dump_user_location_t user_loc = loc.get_user_location ();
-  dump_printf_loc (metadata, user_loc, "node%s %p (max_nunits=%u, refcnt=%u)",
+  dump_printf_loc (metadata, user_loc,
+		   "node%s %p (max_nunits=" HOST_WIDE_INT_PRINT_UNSIGNED
+		   ", refcnt=%u)",
 		   SLP_TREE_DEF_TYPE (node) == vect_external_def
 		   ? " (external)"
 		   : (SLP_TREE_DEF_TYPE (node) == vect_constant_def
@@ -4385,6 +4387,15 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)
 	 to use walk_gimple_op.  */
       wi.is_lhs = 0;
       walk_gimple_op (stmt_info->stmt, vect_detect_hybrid_slp, &wi);
+      /* For gather/scatter make sure to walk the offset operand, that
+	 can be a scaling and conversion away.  */
+      gather_scatter_info gs_info;
+      if (STMT_VINFO_GATHER_SCATTER_P (stmt_info)
+	  && vect_check_gather_scatter (stmt_info, loop_vinfo, &gs_info))
+	{
+	  int dummy;
+	  vect_detect_hybrid_slp (&gs_info.offset, &dummy, &wi);
+	}
     }
 }
 
@@ -4493,7 +4504,23 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,
 
   /* Handle purely internal nodes.  */
   if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)
-    return vectorizable_slp_permutation (vinfo, NULL, node, cost_vec);
+    {
+      if (!vectorizable_slp_permutation (vinfo, NULL, node, cost_vec))
+	return false;
+
+      stmt_vec_info slp_stmt_info;
+      unsigned int i;
+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, slp_stmt_info)
+	{
+	  if (STMT_VINFO_LIVE_P (slp_stmt_info)
+	      && !vectorizable_live_operation (vinfo,
+					       slp_stmt_info, NULL, node,
+					       node_instance, i,
+					       false, cost_vec))
+	    return false;
+	}
+      return true;
+    }
 
   gcc_assert (STMT_SLP_TYPE (stmt_info) != loop_vect);
 
@@ -7333,8 +7360,6 @@ vect_schedule_slp_node (vec_info *vinfo,
 	}
     }
 
-  bool done_p = false;
-
   /* Handle purely internal nodes.  */
   if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)
     {
@@ -7345,9 +7370,18 @@ vect_schedule_slp_node (vec_info *vinfo,
 	 but open-code it here (partly).  */
       bool done = vectorizable_slp_permutation (vinfo, &si, node, NULL);
       gcc_assert (done);
-      done_p = true;
+      stmt_vec_info slp_stmt_info;
+      unsigned int i;
+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, slp_stmt_info)
+	if (STMT_VINFO_LIVE_P (slp_stmt_info))
+	  {
+	    done = vectorizable_live_operation (vinfo,
+						slp_stmt_info, &si, node,
+						instance, i, true, NULL);
+	    gcc_assert (done);
+	  }
     }
-  if (!done_p)
+  else
     vect_transform_stmt (vinfo, stmt_info, &si, node, instance);
 }
 
diff --git a/gcc/tree-vect-stmts.cc b/gcc/tree-vect-stmts.cc
index d8da13e312a..4c5d20a0e2c 100644
--- a/gcc/tree-vect-stmts.cc
+++ b/gcc/tree-vect-stmts.cc
@@ -3419,6 +3419,14 @@ vectorizable_call (vec_info *vinfo,
       return false;
     }
 
+  if (vect_emulated_vector_p (vectype_in) || vect_emulated_vector_p (vectype_out))
+  {
+      if (dump_enabled_p ())
+	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+			 "use emulated vector type for call\n");
+      return false;
+  }
+
   /* FORNOW */
   nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);
   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);
diff --git a/gcc/varasm.cc b/gcc/varasm.cc
index 021e912a37c..a4b1cc68680 100644
--- a/gcc/varasm.cc
+++ b/gcc/varasm.cc
@@ -2404,7 +2404,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,
   else
     {
       /* Special-case handling of vtv comdat sections.  */
-      if (sect->named.name
+      if (SECTION_STYLE (sect) == SECTION_NAMED
 	  && (strcmp (sect->named.name, ".vtable_map_vars") == 0))
 	handle_vtv_comdat_section (sect, decl);
       else
diff --git a/libatomic/ChangeLog b/libatomic/ChangeLog
index bf19a304981..96c60e2c341 100644
--- a/libatomic/ChangeLog
+++ b/libatomic/ChangeLog
@@ -1,3 +1,12 @@
+2022-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/104688
+	* config/x86/init.c (__libat_feat1_init): Don't clear
+	bit_AVX on AMD CPUs.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/libatomic/config/x86/init.c b/libatomic/config/x86/init.c
index 6f6499c58c3..10e1c5f5dbb 100644
--- a/libatomic/config/x86/init.c
+++ b/libatomic/config/x86/init.c
@@ -39,10 +39,12 @@ __libat_feat1_init (void)
       == (bit_AVX | bit_CMPXCHG16B))
     {
       /* Intel SDM guarantees that 16-byte VMOVDQA on 16-byte aligned address
-	 is atomic, but so far we don't have this guarantee from AMD.  */
+	 is atomic, and AMD is going to do something similar soon.
+	 We don't have a guarantee from vendors of other CPUs with AVX,
+	 like Zhaoxin and VIA.  */
       unsigned int ecx2 = 0;
       __get_cpuid (0, &eax, &ebx, &ecx2, &edx);
-      if (ecx2 != signature_INTEL_ecx)
+      if (ecx2 != signature_INTEL_ecx && ecx2 != signature_AMD_ecx)
 	FEAT1_REGISTER &= ~bit_AVX;
     }
 #endif
diff --git a/libcpp/po/ChangeLog b/libcpp/po/ChangeLog
index 1dff84d4094..8d5e5ce9ff4 100644
--- a/libcpp/po/ChangeLog
+++ b/libcpp/po/ChangeLog
@@ -1,3 +1,15 @@
+2023-01-16  Joseph Myers  <joseph@codesourcery.com>
+
+	* ka.po: New.
+
+2023-01-09  Joseph Myers  <joseph@codesourcery.com>
+
+	* eo.po: Update.
+
+2022-10-10  Joseph Myers  <joseph@codesourcery.com>
+
+	* ro.po: New.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/libcpp/po/eo.po b/libcpp/po/eo.po
index 30543642cc5..846fcf476df 100644
--- a/libcpp/po/eo.po
+++ b/libcpp/po/eo.po
@@ -1,14 +1,14 @@
 # Translation of cpplib to Esperanto
-# Copyright (C) 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021 Free Software Foundation, Inc.
+# Copyright (C) 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2023 Free Software Foundation, Inc.
 # This file is distributed under the same license as the gcc package.
-# Felipe Castro <fefcas@gmail.com>, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021.
+# Felipe Castro <fefcas@gmail.com>, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2023.
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: cpplib 11.1-b20210207\n"
+"Project-Id-Version: cpplib 12.1-b20220213\n"
 "Report-Msgid-Bugs-To: https://gcc.gnu.org/bugs/\n"
 "POT-Creation-Date: 2022-02-11 23:02+0000\n"
-"PO-Revision-Date: 2021-03-07 10:29-0300\n"
+"PO-Revision-Date: 2023-01-08 14:43-0300\n"
 "Last-Translator: Felipe Castro <fefcas@gmail.com>\n"
 "Language-Team: Esperanto <translation-team-eo@lists.sourceforge.net>\n"
 "Language: eo\n"
@@ -208,10 +208,9 @@ msgid "style of line directive is a GCC extension"
 msgstr "stilo de lini-direktivoj estas aldono de GCC"
 
 #: directives.cc:541
-#, fuzzy, c-format
-#| msgid "invalid preprocessing directive #%s"
+#, c-format
 msgid "invalid preprocessing directive #%s; did you mean #%s?"
-msgstr "malvalida antaŭproceza direktivo #%s"
+msgstr "malvalida antaŭproceza direktivo #%s; ĉu vi intencis #%s?"
 
 #: directives.cc:547
 #, c-format
@@ -394,28 +393,24 @@ msgid "the conditional began here"
 msgstr "la kondiĉo komencis ĉi tie"
 
 #: directives.cc:2108
-#, fuzzy, c-format
-#| msgid "#else without #if"
+#, c-format
 msgid "#%s without #if"
-msgstr "#else sen #if"
+msgstr "#%s sen #if"
 
 #: directives.cc:2113
-#, fuzzy, c-format
-#| msgid "#else after #else"
+#, c-format
 msgid "#%s after #else"
-msgstr "#else post #else"
+msgstr "#%s post #else"
 
 #: directives.cc:2136 directives.cc:2175
-#, fuzzy, c-format
-#| msgid "#%s is a GCC extension"
+#, c-format
 msgid "#%s before C++23 is a GCC extension"
-msgstr "#%s estas aldono de GCC"
+msgstr "#%s antaŭ C++23 estas aldono de GCC"
 
 #: directives.cc:2140 directives.cc:2179
-#, fuzzy, c-format
-#| msgid "#%s is a GCC extension"
+#, c-format
 msgid "#%s before C2X is a GCC extension"
-msgstr "#%s estas aldono de GCC"
+msgstr "#%s antaŭ C2X estas aldono de GCC"
 
 #: directives.cc:2215
 msgid "#endif without #if"
@@ -724,30 +719,30 @@ msgstr "trigrafikaĵo ??%c preteratentita, uzu -trigraphs por ebligi"
 
 #: lex.cc:1536
 msgid "end of bidirectional context"
-msgstr ""
+msgstr "fino de dudirekta kunteksto"
 
 #: lex.cc:1577
 msgid "unpaired UTF-8 bidirectional control characters detected"
-msgstr ""
+msgstr "neparigitaj dudirektaj regaj signoj de UTF-8 estas detektitaj"
 
 #: lex.cc:1581
 msgid "unpaired UTF-8 bidirectional control character detected"
-msgstr ""
+msgstr "neparigita dudirekta rega signo de UTF-8 estas detektita"
 
 #: lex.cc:1619
 #, c-format
 msgid "UTF-8 vs UCN mismatch when closing a context by \"%s\""
-msgstr ""
+msgstr "Malkongruo inter UTF-8 kaj UCN dum fermo de kunteksto farite de \"%s\""
 
 #: lex.cc:1628
 #, c-format
 msgid "\"%s\" is closing an unopened context"
-msgstr ""
+msgstr "\"%s\" fermas malfermitan kuntekston"
 
 #: lex.cc:1632
 #, c-format
 msgid "found problematic Unicode character \"%s\""
-msgstr ""
+msgstr "estas trovita problema unikoda signo \"%s\""
 
 #: lex.cc:1682
 msgid "\"/*\" within comment"
@@ -800,7 +795,7 @@ msgstr "la identiganto \"%s\" estas speciala operator-nomo en C++"
 
 #: lex.cc:2132
 msgid "adjacent digit separators"
-msgstr ""
+msgstr "apudaj cifero-apartigiloj"
 
 #: lex.cc:2450
 msgid "raw string delimiter longer than 16 characters"
@@ -884,20 +879,16 @@ msgid "'##' cannot appear at either end of __VA_OPT__"
 msgstr "'##' ne povas aperi ĉe iu ajn flanko de __VA_OPT__"
 
 #: macro.cc:144
-#, fuzzy
-#| msgid "'##' cannot appear at either end of __VA_OPT__"
 msgid "__VA_OPT__ may not appear in a __VA_OPT__"
-msgstr "'##' ne povas aperi ĉe iu ajn flanko de __VA_OPT__"
+msgstr "__VA_OPT__ ne povas aperi ene de __VA_OPT__"
 
 #: macro.cc:157
 msgid "__VA_OPT__ must be followed by an open parenthesis"
-msgstr ""
+msgstr "__VA_OPT__ devas esti sekvata de malferma ronda krampo"
 
 #: macro.cc:235
-#, fuzzy
-#| msgid "unterminated #%s"
 msgid "unterminated __VA_OPT__"
-msgstr "nefinigita #%s"
+msgstr "nefinigita __VA_OPT__"
 
 #: macro.cc:397
 #, c-format
@@ -951,10 +942,9 @@ msgid "invalid string literal, ignoring final '\\'"
 msgstr "malvalida ĉena literaĵo, ni preterpasas finan '\\'"
 
 #: macro.cc:980
-#, fuzzy, c-format
-#| msgid "pasting \"%s\" and \"%s\" does not give a valid preprocessing token"
+#, c-format
 msgid "pasting \"%.*s\" and \"%.*s\" does not give a valid preprocessing token"
-msgstr "algluo de \"%s\" kaj \"%s\" ne rezultas en valida antaŭproceza ĵetono"
+msgstr "algluo de \"%.*s\" kaj \"%.*s\" ne rezultas en valida antaŭproceza ĵetono"
 
 #: macro.cc:1112
 msgid "ISO C++11 requires at least one argument for the \"...\" in a variadic macro"
@@ -975,10 +965,9 @@ msgid "macro \"%s\" passed %u arguments, but takes just %u"
 msgstr "la makroo \"%s\" pasis %u argumentojn, sed ĝi prenas nur %u"
 
 #: macro.cc:1132
-#, fuzzy, c-format
-#| msgid "macro \"%s\" is not used"
+#, c-format
 msgid "macro \"%s\" defined here"
-msgstr "makroo \"%s\" ne estas uzata"
+msgstr "makroo \"%s\" difinita ĉi tie"
 
 #: macro.cc:1326 traditional.cc:822
 #, c-format
diff --git a/libcpp/po/ka.po b/libcpp/po/ka.po
new file mode 100644
index 00000000000..785e8e6250f
--- /dev/null
+++ b/libcpp/po/ka.po
@@ -0,0 +1,1110 @@
+# Georgian translation for cpplib.
+# Copyright (C) 2023 Free Software Foundation, Inc.
+# This file is distributed under the same license as the gcc package.
+# Temuri Doghonadze <temuri.doghonadze@gmail.com>, 2023.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: cpplib 12.1-b20220213\n"
+"Report-Msgid-Bugs-To: https://gcc.gnu.org/bugs/\n"
+"POT-Creation-Date: 2022-02-11 23:02+0000\n"
+"PO-Revision-Date: 2023-01-15 07:01+0100\n"
+"Last-Translator: Temuri Doghonadze <temuri.doghonadze@gmail.com>\n"
+"Language-Team: Georgian <(nothing)>\n"
+"Language: ka\n"
+"X-Bugs: Report translation errors to the Language-Team address.\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+"X-Generator: Poedit 3.2.2\n"
+
+#: charset.cc:683
+#, c-format
+msgid "conversion from %s to %s not supported by iconv"
+msgstr "%s-დან %s-ზე გადაყვანა iconv-ს მიერ მხარდაჭერილი არაა"
+
+#: charset.cc:686
+msgid "iconv_open"
+msgstr "iconv_open"
+
+#: charset.cc:696
+#, c-format
+msgid "no iconv implementation, cannot convert from %s to %s"
+msgstr "iconv-ის გარეშე. %s-დან %s-ზე გადაყვანა შეუძლებელია"
+
+#: charset.cc:794
+#, c-format
+msgid "character 0x%lx is not in the basic source character set\n"
+msgstr ""
+
+#: charset.cc:811 charset.cc:1800
+msgid "converting to execution character set"
+msgstr "გაშვების სიმბოლოების ნაკრებში გადაყვანა"
+
+#: charset.cc:817
+#, c-format
+msgid "character 0x%lx is not unibyte in execution character set"
+msgstr ""
+
+#: charset.cc:1087
+msgid "universal character names are only valid in C++ and C99"
+msgstr ""
+
+#: charset.cc:1091
+msgid "C99's universal character names are incompatible with C90"
+msgstr ""
+
+#: charset.cc:1094
+#, c-format
+msgid "the meaning of '\\%c' is different in traditional C"
+msgstr ""
+
+#: charset.cc:1103
+msgid "In _cpp_valid_ucn but not a UCN"
+msgstr "არსებობს _cpp_valid_ucn -ში, მაგრამ არა UCN"
+
+#: charset.cc:1136
+#, c-format
+msgid "incomplete universal character name %.*s"
+msgstr "დაუსრულებელი უნივერსალური სიმბოლოს სახელი %.*s"
+
+#: charset.cc:1151
+#, c-format
+msgid "%.*s is not a valid universal character"
+msgstr "%.*s სწორი უნივერსალური სიმბოლო არაა"
+
+#: charset.cc:1161 lex.cc:1876
+msgid "'$' in identifier or number"
+msgstr "\"$\" იდენტიფიკატორში ან რიცხვში"
+
+#: charset.cc:1171
+#, c-format
+msgid "universal character %.*s is not valid in an identifier"
+msgstr "უნივერსალური სიმბოლო %.*s იდენტიფიკატორში დაუშვებელია"
+
+#: charset.cc:1175
+#, c-format
+msgid "universal character %.*s is not valid at the start of an identifier"
+msgstr "უნივერსალური სიმბოლო %.*s იდენტიფიკატორის დასაწყისში დაუშვებელია"
+
+#: charset.cc:1182
+#, c-format
+msgid "%.*s is outside the UCS codespace"
+msgstr "%.*s UCS კოდის სივრცის გარეთაა"
+
+#: charset.cc:1227 charset.cc:2145
+msgid "converting UCN to source character set"
+msgstr ""
+
+#: charset.cc:1234
+msgid "converting UCN to execution character set"
+msgstr ""
+
+#: charset.cc:1298
+#, c-format
+msgid "extended character %.*s is not valid in an identifier"
+msgstr ""
+
+#: charset.cc:1315
+#, c-format
+msgid "extended character %.*s is not valid at the start of an identifier"
+msgstr ""
+
+#: charset.cc:1401
+msgid "the meaning of '\\x' is different in traditional C"
+msgstr ""
+
+#: charset.cc:1426
+msgid "\\x used with no following hex digits"
+msgstr ""
+
+#: charset.cc:1433
+msgid "hex escape sequence out of range"
+msgstr "თექვსმეტობითი სპეციალური სიმბოლო დიაპაზონს გარეთაა"
+
+#: charset.cc:1483
+msgid "octal escape sequence out of range"
+msgstr "რვაობით სპეციალური სიმბოლო დიაპაზონს გარეთაა"
+
+#: charset.cc:1564
+msgid "the meaning of '\\a' is different in traditional C"
+msgstr ""
+
+#: charset.cc:1571
+#, c-format
+msgid "non-ISO-standard escape sequence, '\\%c'"
+msgstr "არა-ISO-სტანდარტის სპეციალური მიმდევრობა, '\\%c'"
+
+#: charset.cc:1579
+#, c-format
+msgid "unknown escape sequence: '\\%c'"
+msgstr "უცნობი სპეციალური მიმდევრობა: '\\%c'"
+
+#: charset.cc:1589
+#, c-format
+msgid "unknown escape sequence: '\\%s'"
+msgstr "უცნობი სპეციალური მიმდევრობა: '\\%s'"
+
+#: charset.cc:1597
+msgid "converting escape sequence to execution character set"
+msgstr ""
+
+#: charset.cc:1737
+msgid "missing open quote"
+msgstr "გამხსნელი ბრჭყალი აღმოჩენილი არაა"
+
+#: charset.cc:1955 charset.cc:2034
+msgid "character constant too long for its type"
+msgstr "სიმბოლოების მუდმივა ძალიან გრძელია თავისი ტიპისთვის"
+
+#: charset.cc:1958
+msgid "multi-character character constant"
+msgstr "მრავალსიმბოლოიანი სიმბოლური მუდმივა"
+
+#: charset.cc:2074
+msgid "empty character constant"
+msgstr "ცარიელი სიმბოლური მუდმივა"
+
+#: charset.cc:2230
+#, c-format
+msgid "failure to convert %s to %s"
+msgstr "%s-ის %s-ში გადაყვანის შეცდომა"
+
+#: directives.cc:237 directives.cc:280
+#, c-format
+msgid "extra tokens at end of #%s directive"
+msgstr "დამატებითი კოდები #%s დირექტივის ბოლოში"
+
+#: directives.cc:387
+#, c-format
+msgid "#%s is a GCC extension"
+msgstr "#%s GCC-ის გაფართოებაა"
+
+#: directives.cc:392
+#, c-format
+msgid "#%s is a deprecated GCC extension"
+msgstr "#%s GCC-ის მოძველებული გაფართოებაა"
+
+#: directives.cc:405
+msgid "suggest not using #elif in traditional C"
+msgstr "რჩევა, ტრადიციულ C-ში არ გამოიყენოთ #elif"
+
+#: directives.cc:408
+#, c-format
+msgid "traditional C ignores #%s with the # indented"
+msgstr ""
+
+#: directives.cc:412
+#, c-format
+msgid "suggest hiding #%s from traditional C with an indented #"
+msgstr ""
+
+#: directives.cc:438
+msgid "embedding a directive within macro arguments is not portable"
+msgstr ""
+
+#: directives.cc:466
+msgid "style of line directive is a GCC extension"
+msgstr "ხაზის დირექტივების სტილი GCC-ს გაფართოებაა"
+
+#: directives.cc:541
+#, c-format
+msgid "invalid preprocessing directive #%s; did you mean #%s?"
+msgstr ""
+
+#: directives.cc:547
+#, c-format
+msgid "invalid preprocessing directive #%s"
+msgstr "არასწორი პრეპროცესორის დირექტივა #%s"
+
+#: directives.cc:617
+#, c-format
+msgid "\"%s\" cannot be used as a macro name"
+msgstr "\"%s\" -ს მაკროს სახელში ვერ გამოიყენებთ"
+
+#: directives.cc:624
+#, c-format
+msgid "\"%s\" cannot be used as a macro name as it is an operator in C++"
+msgstr ""
+
+#: directives.cc:627
+#, c-format
+msgid "no macro name given in #%s directive"
+msgstr ""
+
+#: directives.cc:630
+msgid "macro names must be identifiers"
+msgstr "მაკროს სახელები იდენტიფიკატორებს უნდა წარმოადგენდნენ"
+
+#: directives.cc:679 directives.cc:684
+#, c-format
+msgid "undefining \"%s\""
+msgstr "\"%s\"-ის აღწერის გაუქმება"
+
+#: directives.cc:741
+msgid "missing terminating > character"
+msgstr "დამაბოლოებელი > სიმბოლო აღმოჩენილი არაა"
+
+#: directives.cc:800
+#, c-format
+msgid "#%s expects \"FILENAME\" or <FILENAME>"
+msgstr "#%s მოელის \"FILENAME\"-ს ან <FILENAME>-ს"
+
+#: directives.cc:846
+#, c-format
+msgid "empty filename in #%s"
+msgstr "ფაილის ცარიელი სახელი #%s -ში"
+
+#: directives.cc:855
+#, c-format
+msgid "#include nested depth %u exceeds maximum of %u (use -fmax-include-depth=DEPTH to increase the maximum)"
+msgstr ""
+
+#: directives.cc:900
+msgid "#include_next in primary source file"
+msgstr "#include_next კოდის ძირითად ფაილში"
+
+#: directives.cc:926
+#, c-format
+msgid "invalid flag \"%s\" in line directive"
+msgstr "არასწორი ალამი \"%s' ხაზის დირექტივაში"
+
+#: directives.cc:993
+msgid "unexpected end of file after #line"
+msgstr "ფაილის მოულოდნელი დასასრული #line-ის შემდეგ"
+
+#: directives.cc:996
+#, c-format
+msgid "\"%s\" after #line is not a positive integer"
+msgstr "\"%s\" #line-ის შემდეგ დადებითი მთელი რიცხვი არაა"
+
+#: directives.cc:1002 directives.cc:1004
+msgid "line number out of range"
+msgstr "ხაზის ნომერი დიაპაზონს გარეთაა"
+
+#: directives.cc:1017 directives.cc:1098
+#, c-format
+msgid "\"%s\" is not a valid filename"
+msgstr "'%s' არასწორი ფაილის სახელია"
+
+#: directives.cc:1058
+#, c-format
+msgid "\"%s\" after # is not a positive integer"
+msgstr "\"%s\" #-ის შემდეგ დადებითი მთელი რიცხვი არაა"
+
+#: directives.cc:1125
+#, c-format
+msgid "file \"%s\" linemarker ignored due to incorrect nesting"
+msgstr ""
+
+#: directives.cc:1203 directives.cc:1205 directives.cc:1207 directives.cc:1795
+#, c-format
+msgid "%s"
+msgstr "%s"
+
+#: directives.cc:1231
+#, c-format
+msgid "invalid #%s directive"
+msgstr "#%s: არასწორი დირექტივა"
+
+#: directives.cc:1294
+#, c-format
+msgid "registering pragmas in namespace \"%s\" with mismatched name expansion"
+msgstr ""
+
+#: directives.cc:1303
+#, c-format
+msgid "registering pragma \"%s\" with name expansion and no namespace"
+msgstr ""
+
+#: directives.cc:1321
+#, c-format
+msgid "registering \"%s\" as both a pragma and a pragma namespace"
+msgstr ""
+
+#: directives.cc:1324
+#, c-format
+msgid "#pragma %s %s is already registered"
+msgstr "#pragma %s %s უკვე რეგისტრირებულია"
+
+#: directives.cc:1327
+#, c-format
+msgid "#pragma %s is already registered"
+msgstr "#pragma %s უკვე დარეგისტრირებულია"
+
+#: directives.cc:1357
+msgid "registering pragma with NULL handler"
+msgstr ""
+
+#: directives.cc:1574
+msgid "#pragma once in main file"
+msgstr "#pragma ერთხელ მთავარ ფაილში"
+
+#: directives.cc:1597
+msgid "invalid #pragma push_macro directive"
+msgstr "არასწორი #pragma push_macro დირექტივა"
+
+#: directives.cc:1654
+msgid "invalid #pragma pop_macro directive"
+msgstr "არასწორი #pragma pop_macro დირექტივა"
+
+#: directives.cc:1709
+msgid "invalid #pragma GCC poison directive"
+msgstr ""
+
+#: directives.cc:1718
+#, c-format
+msgid "poisoning existing macro \"%s\""
+msgstr ""
+
+#: directives.cc:1737
+msgid "#pragma system_header ignored outside include file"
+msgstr ""
+
+#: directives.cc:1762
+#, c-format
+msgid "cannot find source file %s"
+msgstr "წყაროს ფაილი %s ვერ ვიპოვე"
+
+#: directives.cc:1766
+#, c-format
+msgid "current file is older than %s"
+msgstr "მიმდინარე ფაილი ძველია, ვიდრე %s"
+
+#: directives.cc:1790
+#, c-format
+msgid "invalid \"#pragma GCC %s\" directive"
+msgstr "არასწორი \"#pragma GCC %s\" დირექტივა"
+
+#: directives.cc:1992
+msgid "_Pragma takes a parenthesized string literal"
+msgstr ""
+
+#: directives.cc:2075
+msgid "#else without #if"
+msgstr "#else -ს #if -ი აკლია"
+
+#: directives.cc:2080
+msgid "#else after #else"
+msgstr "#else-ი #else-ის შემდეგ"
+
+#: directives.cc:2082 directives.cc:2116
+msgid "the conditional began here"
+msgstr "პირობა აქ იწყება"
+
+#: directives.cc:2108
+#, c-format
+msgid "#%s without #if"
+msgstr "#%s -ი #if -ის გარეშე"
+
+#: directives.cc:2113
+#, c-format
+msgid "#%s after #else"
+msgstr "#%s-ი #else -ის შემდეგ"
+
+#: directives.cc:2136 directives.cc:2175
+#, c-format
+msgid "#%s before C++23 is a GCC extension"
+msgstr "#%s -ი C++23 -ის შემდეგ GCC -ის გაფართოებაა"
+
+#: directives.cc:2140 directives.cc:2179
+#, c-format
+msgid "#%s before C2X is a GCC extension"
+msgstr ""
+
+#: directives.cc:2215
+msgid "#endif without #if"
+msgstr "#endif -ი #if -ის გარეშე"
+
+#: directives.cc:2291
+msgid "missing '(' after predicate"
+msgstr ""
+
+#: directives.cc:2309
+msgid "missing ')' to complete answer"
+msgstr ""
+
+#: directives.cc:2321
+msgid "predicate's answer is empty"
+msgstr "პრედიკატის პასუხი ცარიელია"
+
+#: directives.cc:2351
+msgid "assertion without predicate"
+msgstr "დამტკიცება პრედიკატის გარეშე"
+
+#: directives.cc:2354
+msgid "predicate must be an identifier"
+msgstr "პრედიკატი იდენტიფიკატორი უნდა იყოს"
+
+#: directives.cc:2436
+#, c-format
+msgid "\"%s\" re-asserted"
+msgstr ""
+
+#: directives.cc:2754
+#, c-format
+msgid "unterminated #%s"
+msgstr "დაუსრულებელი #%s"
+
+#: errors.cc:335 errors.cc:350
+#, c-format
+msgid "%s: %s"
+msgstr "%s: %s"
+
+#: errors.cc:348
+msgid "stdout"
+msgstr "stdout"
+
+#: expr.cc:632 expr.cc:749
+msgid "fixed-point constants are a GCC extension"
+msgstr ""
+
+#: expr.cc:657
+msgid "invalid prefix \"0b\" for floating constant"
+msgstr ""
+
+#: expr.cc:670
+msgid "use of C++17 hexadecimal floating constant"
+msgstr ""
+
+#: expr.cc:673
+msgid "use of C99 hexadecimal floating constant"
+msgstr ""
+
+#: expr.cc:717
+#, c-format
+msgid "invalid suffix \"%.*s\" on floating constant"
+msgstr ""
+
+#: expr.cc:728 expr.cc:795
+#, c-format
+msgid "traditional C rejects the \"%.*s\" suffix"
+msgstr ""
+
+#: expr.cc:736
+msgid "suffix for double constant is a GCC extension"
+msgstr ""
+
+#: expr.cc:742
+#, c-format
+msgid "invalid suffix \"%.*s\" with hexadecimal floating constant"
+msgstr ""
+
+#: expr.cc:755 expr.cc:759
+msgid "decimal float constants are a C2X feature"
+msgstr ""
+
+#: expr.cc:778
+#, c-format
+msgid "invalid suffix \"%.*s\" on integer constant"
+msgstr ""
+
+#: expr.cc:803
+msgid "use of C++11 long long integer constant"
+msgstr ""
+
+#: expr.cc:804
+msgid "use of C99 long long integer constant"
+msgstr ""
+
+#: expr.cc:818
+msgid "use of C++23 %<size_t%> integer constant"
+msgstr ""
+
+#: expr.cc:819
+msgid "use of C++23 %<make_signed_t<size_t>%> integer constant"
+msgstr ""
+
+#: expr.cc:830
+msgid "imaginary constants are a GCC extension"
+msgstr ""
+
+#: expr.cc:837
+msgid "binary constants are a C++14 feature or GCC extension"
+msgstr ""
+
+#: expr.cc:839
+msgid "binary constants are a C2X feature or GCC extension"
+msgstr ""
+
+#: expr.cc:844
+msgid "binary constants are a C2X feature"
+msgstr ""
+
+#: expr.cc:940
+msgid "integer constant is too large for its type"
+msgstr ""
+
+#: expr.cc:971
+msgid "integer constant is so large that it is unsigned"
+msgstr ""
+
+#: expr.cc:1066
+msgid "missing ')' after \"defined\""
+msgstr ""
+
+#: expr.cc:1073
+msgid "operator \"defined\" requires an identifier"
+msgstr ""
+
+#: expr.cc:1081
+#, c-format
+msgid "(\"%s\" is an alternative token for \"%s\" in C++)"
+msgstr ""
+
+#: expr.cc:1094
+msgid "this use of \"defined\" may not be portable"
+msgstr ""
+
+#: expr.cc:1139
+msgid "user-defined literal in preprocessor expression"
+msgstr ""
+
+#: expr.cc:1144
+msgid "floating constant in preprocessor expression"
+msgstr ""
+
+#: expr.cc:1150
+msgid "imaginary number in preprocessor expression"
+msgstr ""
+
+#: expr.cc:1199
+#, c-format
+msgid "\"%s\" is not defined, evaluates to 0"
+msgstr ""
+
+#: expr.cc:1212
+msgid "assertions are a GCC extension"
+msgstr ""
+
+#: expr.cc:1215
+msgid "assertions are a deprecated extension"
+msgstr ""
+
+#: expr.cc:1461
+#, c-format
+msgid "unbalanced stack in %s"
+msgstr ""
+
+#: expr.cc:1481
+#, c-format
+msgid "impossible operator '%u'"
+msgstr "შეუძლებელი ოპერატორი '%u'"
+
+#: expr.cc:1582
+msgid "missing ')' in expression"
+msgstr "გამოსახულებას ')' აკლია"
+
+#: expr.cc:1611
+msgid "'?' without following ':'"
+msgstr "'?' -ი მომყოლი ':'-ის გარეშე"
+
+#: expr.cc:1621
+msgid "integer overflow in preprocessor expression"
+msgstr ""
+
+#: expr.cc:1626
+msgid "missing '(' in expression"
+msgstr ""
+
+#: expr.cc:1658
+#, c-format
+msgid "the left operand of \"%s\" changes sign when promoted"
+msgstr ""
+
+#: expr.cc:1663
+#, c-format
+msgid "the right operand of \"%s\" changes sign when promoted"
+msgstr ""
+
+#: expr.cc:1922
+msgid "traditional C rejects the unary plus operator"
+msgstr ""
+
+#: expr.cc:2020
+msgid "comma operator in operand of #if"
+msgstr ""
+
+#: expr.cc:2156
+msgid "division by zero in #if"
+msgstr "ნულზე გაყოფა #if -ში"
+
+#: files.cc:516
+msgid "NULL directory in find_file"
+msgstr ""
+
+#: files.cc:570
+msgid "one or more PCH files were found, but they were invalid"
+msgstr ""
+
+#: files.cc:574
+msgid "use -Winvalid-pch for more information"
+msgstr ""
+
+#: files.cc:688
+#, c-format
+msgid "%s is a block device"
+msgstr "%s ბლოკური მოწყობილობაა"
+
+#: files.cc:707
+#, c-format
+msgid "%s is too large"
+msgstr "%s ძალიან დიდია"
+
+#: files.cc:748
+#, c-format
+msgid "%s is shorter than expected"
+msgstr "%s მოსალოდნელზე მოკლეა"
+
+#: files.cc:1060
+#, c-format
+msgid "no include path in which to search for %s"
+msgstr ""
+
+#: files.cc:1578
+msgid "Multiple include guards may be useful for:\n"
+msgstr ""
+
+#: init.cc:618
+msgid "cppchar_t must be an unsigned type"
+msgstr ""
+
+#: init.cc:622
+#, c-format
+msgid "preprocessor arithmetic has maximum precision of %lu bits; target requires %lu bits"
+msgstr ""
+
+#: init.cc:629
+msgid "CPP arithmetic must be at least as precise as a target int"
+msgstr ""
+
+#: init.cc:632
+msgid "target char is less than 8 bits wide"
+msgstr ""
+
+#: init.cc:636
+msgid "target wchar_t is narrower than target char"
+msgstr ""
+
+#: init.cc:640
+msgid "target int is narrower than target char"
+msgstr ""
+
+#: init.cc:645
+msgid "CPP half-integer narrower than CPP character"
+msgstr ""
+
+#: init.cc:649
+#, c-format
+msgid "CPP on this host cannot handle wide character constants over %lu bits, but the target requires %lu bits"
+msgstr ""
+
+#: lex.cc:1126
+msgid "backslash and newline separated by space"
+msgstr ""
+
+#: lex.cc:1131
+msgid "backslash-newline at end of file"
+msgstr ""
+
+#: lex.cc:1147
+#, c-format
+msgid "trigraph ??%c converted to %c"
+msgstr ""
+
+#: lex.cc:1155
+#, c-format
+msgid "trigraph ??%c ignored, use -trigraphs to enable"
+msgstr ""
+
+#: lex.cc:1536
+msgid "end of bidirectional context"
+msgstr ""
+
+#: lex.cc:1577
+msgid "unpaired UTF-8 bidirectional control characters detected"
+msgstr ""
+
+#: lex.cc:1581
+msgid "unpaired UTF-8 bidirectional control character detected"
+msgstr ""
+
+#: lex.cc:1619
+#, c-format
+msgid "UTF-8 vs UCN mismatch when closing a context by \"%s\""
+msgstr ""
+
+#: lex.cc:1628
+#, c-format
+msgid "\"%s\" is closing an unopened context"
+msgstr "\"%s\" გაუხსნელ კონტექსტს ხურავს"
+
+#: lex.cc:1632
+#, c-format
+msgid "found problematic Unicode character \"%s\""
+msgstr "აღმოჩენილია პრობლემატური უნიკოდის სიმბოლო \"%s\""
+
+#: lex.cc:1682
+msgid "\"/*\" within comment"
+msgstr "\"/*\" კომენტარში"
+
+#: lex.cc:1772
+#, c-format
+msgid "%s in preprocessing directive"
+msgstr "%s პრეპროცესორის დირექტივაში"
+
+#: lex.cc:1784
+msgid "null character(s) ignored"
+msgstr "ნულოვანი შეტყობინებები გამოტოვებულია"
+
+#: lex.cc:1844
+#, c-format
+msgid "`%.*s' is not in NFKC"
+msgstr "`%.*s'-ი NFKC-ში არაა"
+
+#: lex.cc:1847 lex.cc:1850
+#, c-format
+msgid "`%.*s' is not in NFC"
+msgstr "`%.*s' -ი NFC-ში არაა"
+
+#: lex.cc:1932
+msgid "__VA_OPT__ is not available until C++20"
+msgstr "__VA_OPT__ -ი C++20-მდე ხელმიუწვდომელია"
+
+#: lex.cc:1939
+msgid "__VA_OPT__ can only appear in the expansion of a C++20 variadic macro"
+msgstr ""
+
+#: lex.cc:1970 lex.cc:2066
+#, c-format
+msgid "attempt to use poisoned \"%s\""
+msgstr "მოწამლული \"%s\"-ის გამოყენების მცდელობა"
+
+#: lex.cc:1980 lex.cc:2076
+msgid "__VA_ARGS__ can only appear in the expansion of a C++11 variadic macro"
+msgstr ""
+
+#: lex.cc:1984 lex.cc:2080
+msgid "__VA_ARGS__ can only appear in the expansion of a C99 variadic macro"
+msgstr ""
+
+#: lex.cc:1994 lex.cc:2092
+#, c-format
+msgid "identifier \"%s\" is a special operator name in C++"
+msgstr ""
+
+#: lex.cc:2132
+msgid "adjacent digit separators"
+msgstr "მოსაზღვრე ციფრის გამყოფები"
+
+#: lex.cc:2450
+msgid "raw string delimiter longer than 16 characters"
+msgstr ""
+
+#: lex.cc:2454
+msgid "invalid new-line in raw string delimiter"
+msgstr ""
+
+#: lex.cc:2458 lex.cc:5257
+#, c-format
+msgid "invalid character '%c' in raw string delimiter"
+msgstr ""
+
+#: lex.cc:2497 lex.cc:2520
+msgid "unterminated raw string"
+msgstr "დაუსრულებელი დაუმუშავებელი სტრიქონი"
+
+#: lex.cc:2552 lex.cc:2701
+msgid "invalid suffix on literal; C++11 requires a space between literal and string macro"
+msgstr ""
+
+#: lex.cc:2684
+msgid "null character(s) preserved in literal"
+msgstr ""
+
+#: lex.cc:2687
+#, c-format
+msgid "missing terminating %c character"
+msgstr "დამაბოლოებელი %c სიმბოლო აღმოჩენილი არაა"
+
+#: lex.cc:2719
+msgid "C++11 requires a space between string literal and macro"
+msgstr ""
+
+#: lex.cc:3312
+msgid "module control-line cannot be in included file"
+msgstr ""
+
+#: lex.cc:3326
+#, c-format
+msgid "module control-line \"%s\" cannot be an object-like macro"
+msgstr ""
+
+#: lex.cc:3714 lex.cc:5090 traditional.cc:174
+msgid "unterminated comment"
+msgstr "დაუსრულებელი კომენტარი"
+
+#: lex.cc:3728 lex.cc:3762
+msgid "C++ style comments are not allowed in ISO C90"
+msgstr ""
+
+#: lex.cc:3730 lex.cc:3741 lex.cc:3765
+msgid "(this will be reported only once per input file)"
+msgstr ""
+
+#: lex.cc:3739
+msgid "C++ style comments are incompatible with C90"
+msgstr ""
+
+#: lex.cc:3771
+msgid "multi-line comment"
+msgstr "მრავალხაზიანი კომენტარი"
+
+#: lex.cc:4165
+#, c-format
+msgid "unspellable token %s"
+msgstr "გაურკვეველი კოდი %s"
+
+#: lex.cc:5245
+#, c-format
+msgid "raw string delimiter longer than %d characters"
+msgstr ""
+
+#: lex.cc:5315
+msgid "unterminated literal"
+msgstr "დაუსრულებელი ლიტერალი"
+
+#: macro.cc:94
+msgid "'##' cannot appear at either end of __VA_OPT__"
+msgstr ""
+
+#: macro.cc:144
+msgid "__VA_OPT__ may not appear in a __VA_OPT__"
+msgstr ""
+
+#: macro.cc:157
+msgid "__VA_OPT__ must be followed by an open parenthesis"
+msgstr ""
+
+#: macro.cc:235
+msgid "unterminated __VA_OPT__"
+msgstr "დაუსრულებელი __VA_OPT__"
+
+#: macro.cc:397
+#, c-format
+msgid "\"%s\" used outside of preprocessing directive"
+msgstr ""
+
+#: macro.cc:407
+#, c-format
+msgid "missing '(' before \"%s\" operand"
+msgstr ""
+
+#: macro.cc:422
+#, c-format
+msgid "operator \"%s\" requires a header-name"
+msgstr ""
+
+#: macro.cc:439
+#, c-format
+msgid "missing ')' after \"%s\" operand"
+msgstr ""
+
+#: macro.cc:459
+#, c-format
+msgid "macro \"%s\" is not used"
+msgstr "მაკრო \"%s\" არ გამოიყენება"
+
+#: macro.cc:498 macro.cc:797
+#, c-format
+msgid "invalid built-in macro \"%s\""
+msgstr "არასწორი ჩაშენებული მაკრო \"%s\""
+
+#: macro.cc:505 macro.cc:613
+#, c-format
+msgid "macro \"%s\" might prevent reproducible builds"
+msgstr ""
+
+#: macro.cc:536
+msgid "could not determine file timestamp"
+msgstr "ფაილის დროის შტამპის გარკვევის შეცდომა"
+
+#: macro.cc:627
+msgid "could not determine date and time"
+msgstr "დროისა და თარიღის გარკვევა შეუძლებელია"
+
+#: macro.cc:659
+msgid "__COUNTER__ expanded inside directive with -fdirectives-only"
+msgstr ""
+
+#: macro.cc:916
+msgid "invalid string literal, ignoring final '\\'"
+msgstr "არასწორი სტრიქონი ლიტერალი. ბოლო '\\' გამოტოვებული იქნება"
+
+#: macro.cc:980
+#, c-format
+msgid "pasting \"%.*s\" and \"%.*s\" does not give a valid preprocessing token"
+msgstr ""
+
+#: macro.cc:1112
+msgid "ISO C++11 requires at least one argument for the \"...\" in a variadic macro"
+msgstr ""
+
+#: macro.cc:1116
+msgid "ISO C99 requires at least one argument for the \"...\" in a variadic macro"
+msgstr ""
+
+#: macro.cc:1123
+#, c-format
+msgid "macro \"%s\" requires %u arguments, but only %u given"
+msgstr ""
+
+#: macro.cc:1128
+#, c-format
+msgid "macro \"%s\" passed %u arguments, but takes just %u"
+msgstr ""
+
+#: macro.cc:1132
+#, c-format
+msgid "macro \"%s\" defined here"
+msgstr "მაკრო \"%s\" აქაა აღწერილი"
+
+#: macro.cc:1326 traditional.cc:822
+#, c-format
+msgid "unterminated argument list invoking macro \"%s\""
+msgstr ""
+
+#: macro.cc:1472
+#, c-format
+msgid "function-like macro \"%s\" must be used with arguments in traditional C"
+msgstr ""
+
+#: macro.cc:2307
+#, c-format
+msgid "invoking macro %s argument %d: empty macro arguments are undefined in ISO C++98"
+msgstr ""
+
+#: macro.cc:2315 macro.cc:2324
+#, c-format
+msgid "invoking macro %s argument %d: empty macro arguments are undefined in ISO C90"
+msgstr ""
+
+#: macro.cc:3375
+#, c-format
+msgid "duplicate macro parameter \"%s\""
+msgstr "დუბლირებული მაკროს პარამეტრი \"%s\""
+
+#: macro.cc:3457
+#, c-format
+msgid "expected parameter name, found \"%s\""
+msgstr "მოველოდი პარამეტრის სახელს, მივიღე \"%s\""
+
+#: macro.cc:3458
+#, c-format
+msgid "expected ',' or ')', found \"%s\""
+msgstr "მოველოდი ','-ს ან ')'-ს. აღმოჩენილია \"%s\""
+
+#: macro.cc:3459
+msgid "expected parameter name before end of line"
+msgstr "ხაზის ბოლომდე პარამეტრს მოველოდი"
+
+#: macro.cc:3460
+msgid "expected ')' before end of line"
+msgstr "ხაზის ბოლომდე ')'-ს მოველოდი"
+
+#: macro.cc:3461
+msgid "expected ')' after \"...\""
+msgstr "\"...\"-ის შემდეგ ')'-ს მოველოდი"
+
+#: macro.cc:3518
+msgid "anonymous variadic macros were introduced in C++11"
+msgstr "ანონიმური არგუმენტების ცვლადი რიცხვის მქონე მაკროები C++11-ში გამოჩნდნენ"
+
+#: macro.cc:3519 macro.cc:3523
+msgid "anonymous variadic macros were introduced in C99"
+msgstr "ანონიმური არგუმენტების ცვლადი რიცხვის მქონე მაკროები C99-ში გამოჩნდნენ"
+
+#: macro.cc:3529
+msgid "ISO C++ does not permit named variadic macros"
+msgstr "ISO C++ სახელიან არგუმენტების ცვლადი რიცხვის მქონე მაკროებს მხარს არ უჭერს"
+
+#: macro.cc:3530
+msgid "ISO C does not permit named variadic macros"
+msgstr ""
+
+#: macro.cc:3576
+msgid "'##' cannot appear at either end of a macro expansion"
+msgstr ""
+
+#: macro.cc:3614
+msgid "ISO C++11 requires whitespace after the macro name"
+msgstr ""
+
+#: macro.cc:3615
+msgid "ISO C99 requires whitespace after the macro name"
+msgstr ""
+
+#: macro.cc:3639
+msgid "missing whitespace after the macro name"
+msgstr ""
+
+#: macro.cc:3692
+msgid "'#' is not followed by a macro parameter"
+msgstr ""
+
+#: macro.cc:3848
+#, c-format
+msgid "\"%s\" redefined"
+msgstr "\"%s\" ხელახლა აღიწერა"
+
+#: macro.cc:3853
+msgid "this is the location of the previous definition"
+msgstr "ეს წინა აღწერის მდებარეობაა"
+
+#: macro.cc:3990
+#, c-format
+msgid "macro argument \"%s\" would be stringified in traditional C"
+msgstr ""
+
+#: pch.cc:90 pch.cc:342 pch.cc:356 pch.cc:374 pch.cc:380 pch.cc:389 pch.cc:396
+msgid "while writing precompiled header"
+msgstr "წინასწარ აგებული თავსართის ჩაწერისას"
+
+#: pch.cc:616
+#, c-format
+msgid "%s: not used because `%.*s' is poisoned"
+msgstr ""
+
+#: pch.cc:638
+#, c-format
+msgid "%s: not used because `%.*s' not defined"
+msgstr ""
+
+#: pch.cc:650
+#, c-format
+msgid "%s: not used because `%.*s' defined as `%s' not `%.*s'"
+msgstr ""
+
+#: pch.cc:691
+#, c-format
+msgid "%s: not used because `%s' is defined"
+msgstr ""
+
+#: pch.cc:711
+#, c-format
+msgid "%s: not used because `__COUNTER__' is invalid"
+msgstr ""
+
+#: pch.cc:720 pch.cc:876
+msgid "while reading precompiled header"
+msgstr ""
+
+#: traditional.cc:891
+#, c-format
+msgid "detected recursion whilst expanding macro \"%s\""
+msgstr ""
+
+#: traditional.cc:1114
+msgid "syntax error in macro parameter list"
+msgstr "სინტაქსის შეცდომა მაკროს პარამეტრების სიაში"
diff --git a/libcpp/po/ro.po b/libcpp/po/ro.po
new file mode 100644
index 00000000000..5084b0b25d8
--- /dev/null
+++ b/libcpp/po/ro.po
@@ -0,0 +1,1140 @@
+# Mesajele în limba română pentru pachetul cpplib.
+# Copyright © 2022 Free Software Foundation, Inc.
+# This file is distributed under the same license as the gcc package.
+#
+# Remus-Gabriel Chelu <remusgabriel.chelu@disroot.org>, 2022.
+#
+# Cronologia traducerii fișierului „cpplib”:
+# Traducerea inițială, făcută de R-GC, pentru versiunea cpplib 12.1-b20220213.
+# Actualizare a traducerii pentru versiunea Y, făcută de X.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: cpplib 12.1-b20220213\n"
+"Report-Msgid-Bugs-To: https://gcc.gnu.org/bugs/\n"
+"POT-Creation-Date: 2022-02-11 23:02+0000\n"
+"PO-Revision-Date: 2022-10-09 09:43+0200\n"
+"Last-Translator: Remus-Gabriel Chelu <remusgabriel.chelu@disroot.org>\n"
+"Language-Team: Romanian <translation-team-ro@lists.sourceforge.net>\n"
+"Language: ro\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : (n==0 || ((n%100) > 0 && (n%100) < 20)) ? 1 : 2);\n"
+"X-Bugs: Report translation errors to the Language-Team address.\n"
+"X-Generator: Poedit 3.1.1\n"
+
+#: charset.cc:683
+#, c-format
+msgid "conversion from %s to %s not supported by iconv"
+msgstr "conversia de la %s la %s nu este acceptată de iconv"
+
+#: charset.cc:686
+msgid "iconv_open"
+msgstr "iconv_open"
+
+#: charset.cc:696
+#, c-format
+msgid "no iconv implementation, cannot convert from %s to %s"
+msgstr "nicio implementare iconv, nu se poate converti de la %s la %s"
+
+#: charset.cc:794
+#, c-format
+msgid "character 0x%lx is not in the basic source character set\n"
+msgstr "caracterul 0x%lx nu se află în setul de caractere sursă de bază\n"
+
+#: charset.cc:811 charset.cc:1800
+msgid "converting to execution character set"
+msgstr "se convertește în setul de caractere de execuție"
+
+#: charset.cc:817
+#, c-format
+msgid "character 0x%lx is not unibyte in execution character set"
+msgstr "caracterul 0x%lx nu este un octet unic în setul de caractere de execuție"
+
+#: charset.cc:1087
+msgid "universal character names are only valid in C++ and C99"
+msgstr "numele de caractere universale sunt valabile numai în C++ și C99"
+
+#: charset.cc:1091
+msgid "C99's universal character names are incompatible with C90"
+msgstr "numele de caractere universale ale lui C99 sunt incompatibile cu C90"
+
+#: charset.cc:1094
+#, c-format
+msgid "the meaning of '\\%c' is different in traditional C"
+msgstr "semnificația lui „\\%c” este diferită în limbajul C tradițional"
+
+#: charset.cc:1103
+msgid "In _cpp_valid_ucn but not a UCN"
+msgstr "Este în _cpp_valid_ucn, dar nu este un UCN(NumedeCaracterUniversal)"
+
+#: charset.cc:1136
+#, c-format
+msgid "incomplete universal character name %.*s"
+msgstr "nume de caracter universal incomplet %.*s"
+
+#: charset.cc:1151
+#, c-format
+msgid "%.*s is not a valid universal character"
+msgstr "%.*s nu este un caracter universal valid"
+
+#: charset.cc:1161 lex.cc:1876
+msgid "'$' in identifier or number"
+msgstr "„$” în identificator sau în număr"
+
+#: charset.cc:1171
+#, c-format
+msgid "universal character %.*s is not valid in an identifier"
+msgstr "caracterul universal %.*s nu este valid într-un identificator"
+
+#: charset.cc:1175
+#, c-format
+msgid "universal character %.*s is not valid at the start of an identifier"
+msgstr "caracterul universal %.*s nu este valid la începutul unui identificator"
+
+#: charset.cc:1182
+#, c-format
+msgid "%.*s is outside the UCS codespace"
+msgstr "%.*s se află în afara spațiului de cod UCS"
+
+#: charset.cc:1227 charset.cc:2145
+msgid "converting UCN to source character set"
+msgstr "se convertește UCN în setul de caractere sursă"
+
+#: charset.cc:1234
+msgid "converting UCN to execution character set"
+msgstr "se convertește UCN în setul de caractere de execuție"
+
+#: charset.cc:1298
+#, c-format
+msgid "extended character %.*s is not valid in an identifier"
+msgstr "caracterul extins %.*s nu este valid într-un identificator"
+
+#: charset.cc:1315
+#, c-format
+msgid "extended character %.*s is not valid at the start of an identifier"
+msgstr "caracterul extins %.*s nu este valid la începutul unui identificator"
+
+#: charset.cc:1401
+msgid "the meaning of '\\x' is different in traditional C"
+msgstr "semnificația lui „\\x” este diferită în limbajul C tradițional"
+
+#: charset.cc:1426
+msgid "\\x used with no following hex digits"
+msgstr "„\\x” utilizat fără să fie urmat de cifre hexazecimale"
+
+#: charset.cc:1433
+msgid "hex escape sequence out of range"
+msgstr "secvență de eludare hexazecimală în afara intervalului"
+
+#: charset.cc:1483
+msgid "octal escape sequence out of range"
+msgstr "secvență de eludare octală în afara intervalului"
+
+#: charset.cc:1564
+msgid "the meaning of '\\a' is different in traditional C"
+msgstr "semnificația lui „\\a” este diferită în limbajul C tradițional"
+
+#: charset.cc:1571
+#, c-format
+msgid "non-ISO-standard escape sequence, '\\%c'"
+msgstr "secvență de eludare non-standard ISO, „\\%c”"
+
+#: charset.cc:1579
+#, c-format
+msgid "unknown escape sequence: '\\%c'"
+msgstr "secvență de eludare necunoscută: „\\%c”"
+
+#: charset.cc:1589
+#, c-format
+msgid "unknown escape sequence: '\\%s'"
+msgstr "secvență de eludare necunoscută: „\\%s”"
+
+#: charset.cc:1597
+msgid "converting escape sequence to execution character set"
+msgstr "se convertește secvența de eludare în set de caractere de execuție"
+
+#: charset.cc:1737
+msgid "missing open quote"
+msgstr "lipsește ghilimeaua de deschidere"
+
+#: charset.cc:1955 charset.cc:2034
+msgid "character constant too long for its type"
+msgstr "constantă de caractere prea lungă pentru tipul său"
+
+#: charset.cc:1958
+msgid "multi-character character constant"
+msgstr "constantă de caractere cu mai multe caractere"
+
+#: charset.cc:2074
+msgid "empty character constant"
+msgstr "constantă de caractere goală"
+
+#: charset.cc:2230
+#, c-format
+msgid "failure to convert %s to %s"
+msgstr "eșec la conversia %s în %s"
+
+#: directives.cc:237 directives.cc:280
+#, c-format
+msgid "extra tokens at end of #%s directive"
+msgstr "simboluri suplimentare la finalul directivei #%s"
+
+#: directives.cc:387
+#, c-format
+msgid "#%s is a GCC extension"
+msgstr "#%s este o extensie GCC"
+
+#: directives.cc:392
+#, c-format
+msgid "#%s is a deprecated GCC extension"
+msgstr "#%s este o extensie GCC învechită"
+
+#: directives.cc:405
+msgid "suggest not using #elif in traditional C"
+msgstr "se sugerează neutilizarea directivei #elif în limbajul C tradițional"
+
+#: directives.cc:408
+#, c-format
+msgid "traditional C ignores #%s with the # indented"
+msgstr "limbajul C tradițional ignoră #%s cu # indentat"
+
+#: directives.cc:412
+#, c-format
+msgid "suggest hiding #%s from traditional C with an indented #"
+msgstr "se sugerează ascunderea #%s din C tradițional cu un # indentat"
+
+#: directives.cc:438
+msgid "embedding a directive within macro arguments is not portable"
+msgstr "înglobarea unei directive în argumentele macro nu este portabilă"
+
+#: directives.cc:466
+msgid "style of line directive is a GCC extension"
+msgstr "directiva de stil de linie este o extensie GCC"
+
+#: directives.cc:541
+#, c-format
+msgid "invalid preprocessing directive #%s; did you mean #%s?"
+msgstr "directivă de preprocesare nevalidă #%s; ați vrut să spuneți #%s?"
+
+#: directives.cc:547
+#, c-format
+msgid "invalid preprocessing directive #%s"
+msgstr "directivă de preprocesare nevalidă #%s"
+
+#: directives.cc:617
+#, c-format
+msgid "\"%s\" cannot be used as a macro name"
+msgstr "„%s” nu poate fi utilizat ca nume de macrocomandă"
+
+#: directives.cc:624
+#, c-format
+msgid "\"%s\" cannot be used as a macro name as it is an operator in C++"
+msgstr "„%s” nu poate fi utilizat ca nume de macrocomandă, deoarece este un operator în C++"
+
+#: directives.cc:627
+#, c-format
+msgid "no macro name given in #%s directive"
+msgstr "niciun nume de macrocomandă nu este dat în directiva #%s"
+
+#: directives.cc:630
+msgid "macro names must be identifiers"
+msgstr "numele macrocomenzilor trebuie să fie identificatori"
+
+#: directives.cc:679 directives.cc:684
+#, c-format
+msgid "undefining \"%s\""
+msgstr "a fost eliminată definiția „%s”"
+
+#: directives.cc:741
+msgid "missing terminating > character"
+msgstr "lipsește caracterul de terminare „>”"
+
+#: directives.cc:800
+#, c-format
+msgid "#%s expects \"FILENAME\" or <FILENAME>"
+msgstr "#%s se așteaptă „NUME_FIȘIER” sau <NUME_FIȘIER>"
+
+#: directives.cc:846
+#, c-format
+msgid "empty filename in #%s"
+msgstr "nume de fișier gol în #%s"
+
+#: directives.cc:855
+#, c-format
+msgid "#include nested depth %u exceeds maximum of %u (use -fmax-include-depth=DEPTH to increase the maximum)"
+msgstr "adâncimea de imbricare %u din #include depășește maximul de %u (utilizați „-fmax-include-depth=ADÂNCIME” pentru a crește valoarea maximă)"
+
+#: directives.cc:900
+msgid "#include_next in primary source file"
+msgstr "#include_next în fișierul sursă principal (primar)"
+
+#: directives.cc:926
+#, c-format
+msgid "invalid flag \"%s\" in line directive"
+msgstr "opțiune nevalidă „%s” în directiva de linie"
+
+#: directives.cc:993
+msgid "unexpected end of file after #line"
+msgstr "sfârșit de fișier neașteptat, după #line"
+
+#: directives.cc:996
+#, c-format
+msgid "\"%s\" after #line is not a positive integer"
+msgstr "„%s” aflat după #line nu este un număr întreg pozitiv"
+
+#: directives.cc:1002 directives.cc:1004
+msgid "line number out of range"
+msgstr "număr de linie în afara intervalului"
+
+#: directives.cc:1017 directives.cc:1098
+#, c-format
+msgid "\"%s\" is not a valid filename"
+msgstr "„%s” nu este un nume de fișier valid"
+
+#: directives.cc:1058
+#, c-format
+msgid "\"%s\" after # is not a positive integer"
+msgstr "„%s” aflat după # nu este un număr întreg pozitiv"
+
+#: directives.cc:1125
+#, c-format
+msgid "file \"%s\" linemarker ignored due to incorrect nesting"
+msgstr "marcatorul de linie al fișierului „%s” a fost ignorat din cauza imbricației incorecte"
+
+#: directives.cc:1203 directives.cc:1205 directives.cc:1207 directives.cc:1795
+#, c-format
+msgid "%s"
+msgstr "%s"
+
+#: directives.cc:1231
+#, c-format
+msgid "invalid #%s directive"
+msgstr "directivă #%s nevalidă"
+
+#: directives.cc:1294
+#, c-format
+msgid "registering pragmas in namespace \"%s\" with mismatched name expansion"
+msgstr "se înregistrează pragmas în spațiul de nume „%s” cu o expandare a numelui ce nu coincide"
+
+#: directives.cc:1303
+#, c-format
+msgid "registering pragma \"%s\" with name expansion and no namespace"
+msgstr "se înregistrează pragma „%s” cu expandarea numelui și fără spațiu de nume"
+
+#: directives.cc:1321
+#, c-format
+msgid "registering \"%s\" as both a pragma and a pragma namespace"
+msgstr "se înregistrează „%s” atât ca pragma, cât și ca spațiu de nume pragma"
+
+#: directives.cc:1324
+#, c-format
+msgid "#pragma %s %s is already registered"
+msgstr "#pragma %s %s este deja înregistrată"
+
+#: directives.cc:1327
+#, c-format
+msgid "#pragma %s is already registered"
+msgstr "#pragma %s este deja înregistrată"
+
+#: directives.cc:1357
+msgid "registering pragma with NULL handler"
+msgstr "se înregistrează pragma cu gestionar NULL"
+
+#: directives.cc:1574
+msgid "#pragma once in main file"
+msgstr "#pragma apare o dată în fișierul principal"
+
+#: directives.cc:1597
+msgid "invalid #pragma push_macro directive"
+msgstr "directivă #pragma push_macro nevalidă"
+
+#: directives.cc:1654
+msgid "invalid #pragma pop_macro directive"
+msgstr "directivă #pragma pop_macro nevalidă"
+
+#: directives.cc:1709
+msgid "invalid #pragma GCC poison directive"
+msgstr "directivă #pragma GCC poison nevalidă"
+
+#: directives.cc:1718
+#, c-format
+msgid "poisoning existing macro \"%s\""
+msgstr "se „otrăvește” macrocomanda existentă „%s”"
+
+#: directives.cc:1737
+msgid "#pragma system_header ignored outside include file"
+msgstr "#pragma system_header ignorat în afara fișierului de includere"
+
+#: directives.cc:1762
+#, c-format
+msgid "cannot find source file %s"
+msgstr "nu se poate găsi fișierul sursă %s"
+
+#: directives.cc:1766
+#, c-format
+msgid "current file is older than %s"
+msgstr "fișierul curent este mai vechi decât %s"
+
+#: directives.cc:1790
+#, c-format
+msgid "invalid \"#pragma GCC %s\" directive"
+msgstr "directivă „#pragma GCC %s” nevalidă"
+
+#: directives.cc:1992
+msgid "_Pragma takes a parenthesized string literal"
+msgstr "_Pragma preia un șir literal între paranteze"
+
+#: directives.cc:2075
+msgid "#else without #if"
+msgstr "#else fără #if"
+
+#: directives.cc:2080
+msgid "#else after #else"
+msgstr "#else după #else"
+
+#: directives.cc:2082 directives.cc:2116
+msgid "the conditional began here"
+msgstr "condiționalul a început aici"
+
+#: directives.cc:2108
+#, c-format
+msgid "#%s without #if"
+msgstr "#%s fără #if"
+
+#: directives.cc:2113
+#, c-format
+msgid "#%s after #else"
+msgstr "#%s după #else"
+
+#: directives.cc:2136 directives.cc:2175
+#, c-format
+msgid "#%s before C++23 is a GCC extension"
+msgstr "#%s înainte de C++23 este o extensie GCC"
+
+#: directives.cc:2140 directives.cc:2179
+#, c-format
+msgid "#%s before C2X is a GCC extension"
+msgstr "#%s înainte de C2X este o extensie GCC"
+
+#: directives.cc:2215
+msgid "#endif without #if"
+msgstr "#endif fără #if"
+
+#: directives.cc:2291
+msgid "missing '(' after predicate"
+msgstr "lipsește „(” după predicat"
+
+#: directives.cc:2309
+msgid "missing ')' to complete answer"
+msgstr "lipsește „)” pentru a completa răspunsul"
+
+#: directives.cc:2321
+msgid "predicate's answer is empty"
+msgstr "răspunsul predicatului este gol"
+
+#: directives.cc:2351
+msgid "assertion without predicate"
+msgstr "afirmație fără predicat"
+
+#: directives.cc:2354
+msgid "predicate must be an identifier"
+msgstr "predicatul trebuie să fie un identificator"
+
+#: directives.cc:2436
+#, c-format
+msgid "\"%s\" re-asserted"
+msgstr "„%s” a fost reafirmat"
+
+#: directives.cc:2754
+#, c-format
+msgid "unterminated #%s"
+msgstr "neterminat #%s"
+
+#: errors.cc:335 errors.cc:350
+#, c-format
+msgid "%s: %s"
+msgstr "%s: %s"
+
+#: errors.cc:348
+msgid "stdout"
+msgstr "ieșirea standard"
+
+#: expr.cc:632 expr.cc:749
+msgid "fixed-point constants are a GCC extension"
+msgstr "constantele cu virgulă fixă sunt o extensie GCC"
+
+#: expr.cc:657
+msgid "invalid prefix \"0b\" for floating constant"
+msgstr "prefix nevalid „0b” pentru constanta cu virgulă mobilă"
+
+#: expr.cc:670
+msgid "use of C++17 hexadecimal floating constant"
+msgstr "utilizare a constantei cu virgulă mobilă hexazecimală C++17"
+
+#: expr.cc:673
+msgid "use of C99 hexadecimal floating constant"
+msgstr "utilizare a constantei cu virgulă mobilă hexazecimală C99"
+
+#: expr.cc:717
+#, c-format
+msgid "invalid suffix \"%.*s\" on floating constant"
+msgstr "sufix nevalid „%.*s” pentru o constantă cu virgulă mobilă"
+
+#: expr.cc:728 expr.cc:795
+#, c-format
+msgid "traditional C rejects the \"%.*s\" suffix"
+msgstr "limbajul C tradițional respinge sufixul „%.*s”"
+
+#: expr.cc:736
+msgid "suffix for double constant is a GCC extension"
+msgstr "sufixul pentru constantă dublă este o extensie GCC"
+
+#: expr.cc:742
+#, c-format
+msgid "invalid suffix \"%.*s\" with hexadecimal floating constant"
+msgstr "sufix nevalid „%.*s” pentru o constantă cu virgulă mobilă hexazecimală"
+
+#: expr.cc:755 expr.cc:759
+msgid "decimal float constants are a C2X feature"
+msgstr "constantele cu virgulă mobilă zecimale sunt o caracteristică C2X"
+
+#: expr.cc:778
+#, c-format
+msgid "invalid suffix \"%.*s\" on integer constant"
+msgstr "sufix nevalid „%.*s” pentru o constantă de număr întreg"
+
+#: expr.cc:803
+msgid "use of C++11 long long integer constant"
+msgstr "utilizare a constantei de număr întreg lung lung C++11"
+
+#: expr.cc:804
+msgid "use of C99 long long integer constant"
+msgstr "utilizare a constantei de număr întreg lung lung C99"
+
+#: expr.cc:818
+msgid "use of C++23 %<size_t%> integer constant"
+msgstr "utilizare a constantei de număr întreg %<size_t%> C++23"
+
+#: expr.cc:819
+msgid "use of C++23 %<make_signed_t<size_t>%> integer constant"
+msgstr "utilizare a constantei de număr întreg %<make_signed_t<size_t>%> C++23"
+
+#: expr.cc:830
+msgid "imaginary constants are a GCC extension"
+msgstr "constantele imaginare sunt o extensie GCC"
+
+#: expr.cc:837
+msgid "binary constants are a C++14 feature or GCC extension"
+msgstr "constantele binare sunt o caracteristică C++14 sau o extensie GCC"
+
+#: expr.cc:839
+msgid "binary constants are a C2X feature or GCC extension"
+msgstr "constantele binare sunt o caracteristică C2X sau o extensie GCC"
+
+#: expr.cc:844
+msgid "binary constants are a C2X feature"
+msgstr "constantele binare sunt o caracteristică C2X"
+
+#: expr.cc:940
+msgid "integer constant is too large for its type"
+msgstr "constanta de număr întreg este prea mare pentru tipul său"
+
+#: expr.cc:971
+msgid "integer constant is so large that it is unsigned"
+msgstr "constanta de număr întreg este atât de mare încât este nesemnată"
+
+#: expr.cc:1066
+msgid "missing ')' after \"defined\""
+msgstr "lipsește „)” după «defined»"
+
+#: expr.cc:1073
+msgid "operator \"defined\" requires an identifier"
+msgstr "operatorul «defined» necesită un identificator"
+
+#: expr.cc:1081
+#, c-format
+msgid "(\"%s\" is an alternative token for \"%s\" in C++)"
+msgstr "(„%s” este un element lexical alternativ pentru „%s” în C++)"
+
+#: expr.cc:1094
+msgid "this use of \"defined\" may not be portable"
+msgstr "este posibil ca această utilizare a lui «defined» să nu fie portabilă"
+
+#: expr.cc:1139
+msgid "user-defined literal in preprocessor expression"
+msgstr "literal definit de utilizator în expresia preprocesorului"
+
+#: expr.cc:1144
+msgid "floating constant in preprocessor expression"
+msgstr "constantă cu virgulă mobilă în expresia preprocesorului"
+
+#: expr.cc:1150
+msgid "imaginary number in preprocessor expression"
+msgstr "număr imaginar în expresia preprocesorului"
+
+#: expr.cc:1199
+#, c-format
+msgid "\"%s\" is not defined, evaluates to 0"
+msgstr "„%s” nu este definit, se evaluează la 0"
+
+#: expr.cc:1212
+msgid "assertions are a GCC extension"
+msgstr "aserțiunile sunt o extensie GCC"
+
+#: expr.cc:1215
+msgid "assertions are a deprecated extension"
+msgstr "aserțiunile sunt o extensie depreciată"
+
+#: expr.cc:1461
+#, c-format
+msgid "unbalanced stack in %s"
+msgstr "stivă dezechilibrată în %s"
+
+#: expr.cc:1481
+#, c-format
+msgid "impossible operator '%u'"
+msgstr "operator „%u” imposibil"
+
+#: expr.cc:1582
+msgid "missing ')' in expression"
+msgstr "lipsește „)” în expresie"
+
+#: expr.cc:1611
+msgid "'?' without following ':'"
+msgstr "„?” fără să fie urmat de „:”"
+
+#: expr.cc:1621
+msgid "integer overflow in preprocessor expression"
+msgstr "depășire de număr întreg în expresia preprocesorului"
+
+#: expr.cc:1626
+msgid "missing '(' in expression"
+msgstr "lipsește „(” în expresie"
+
+#: expr.cc:1658
+#, c-format
+msgid "the left operand of \"%s\" changes sign when promoted"
+msgstr "operandul din stânga lui „%s” își schimbă semnul atunci când este promovat"
+
+#: expr.cc:1663
+#, c-format
+msgid "the right operand of \"%s\" changes sign when promoted"
+msgstr "operandul din dreapta lui „%s” își schimbă semnul atunci când este promovat"
+
+#: expr.cc:1922
+msgid "traditional C rejects the unary plus operator"
+msgstr "limbajul C tradițional respinge operatorul unar plus"
+
+#: expr.cc:2020
+msgid "comma operator in operand of #if"
+msgstr "operator virgulă în operandul #if"
+
+#: expr.cc:2156
+msgid "division by zero in #if"
+msgstr "împărțire la zero în #if"
+
+#: files.cc:516
+msgid "NULL directory in find_file"
+msgstr "director NULL în find_file"
+
+#: files.cc:570
+msgid "one or more PCH files were found, but they were invalid"
+msgstr "au fost găsite unul sau mai multe fișiere PCH, dar acestea nu erau valide"
+
+#: files.cc:574
+msgid "use -Winvalid-pch for more information"
+msgstr "utilizați „-Winvalid-pch” pentru mai multe informații"
+
+#: files.cc:688
+#, c-format
+msgid "%s is a block device"
+msgstr "%s este un dispozitiv bloc"
+
+#: files.cc:707
+#, c-format
+msgid "%s is too large"
+msgstr "%s este prea mare"
+
+#: files.cc:748
+#, c-format
+msgid "%s is shorter than expected"
+msgstr "%s este mai scurt decât se aștepta"
+
+#: files.cc:1060
+#, c-format
+msgid "no include path in which to search for %s"
+msgstr "nicio cale de inclus pentru a căuta %s"
+
+#: files.cc:1578
+msgid "Multiple include guards may be useful for:\n"
+msgstr "Multiple „include guards” pot fi utile pentru:\n"
+
+#: init.cc:618
+msgid "cppchar_t must be an unsigned type"
+msgstr "cppchar_t trebuie să fie un tip nesemnat"
+
+#: init.cc:622
+#, c-format
+msgid "preprocessor arithmetic has maximum precision of %lu bits; target requires %lu bits"
+msgstr "aritmetica preprocesorului are o precizie maximă de %lu biți; ținta necesită %lu biți"
+
+#: init.cc:629
+msgid "CPP arithmetic must be at least as precise as a target int"
+msgstr "Aritmetica CPP trebuie să fie cel puțin la fel de precisă ca o țintă int"
+
+#: init.cc:632
+msgid "target char is less than 8 bits wide"
+msgstr "char țintă are mai puțin de 8 biți lățime"
+
+#: init.cc:636
+msgid "target wchar_t is narrower than target char"
+msgstr "wchar_t țintă este mai îngust decât char tintă"
+
+#: init.cc:640
+msgid "target int is narrower than target char"
+msgstr "int țintă este mai îngust decât char țintă"
+
+#: init.cc:645
+msgid "CPP half-integer narrower than CPP character"
+msgstr "half-integer din CPP este mai îngust decât caracterul din CPP"
+
+# R-GC, scrie:
+# după revizarea fișerului, DȘ spune:
+# „"CPP de pe această gazdă nu poate gestiona constante de caracter largi de peste %lu biți, dar ținta necesită %lu biți" (traducerea inițială)
+# → nu știu sigur despre ce este vorba dar nu cred că „wide” se traduce cu „larg”, „lat” ar fi mai potrivit.”
+# ***
+# după „despicarea firului problemei”, am creat
+# trei propuneri de substituire a acestui mesaj:
+# .
+# a) „CPP de pe această gazdă nu poate gestiona constante de caracter largi, mai
+# lungi de %lu biți, dar ținta necesită %lu biți”
+# .
+# b) „CPP de pe această gazdă nu poate gestiona constante de caracter lungi mai
+# mari de %lu biți, dar ținta necesită %lu biți”
+# .
+# c) „CPP de pe această gazdă nu poate gestiona constante de caracter mai lungi de
+# %lu biți, dar ținta necesită %lu biți”
+# ***
+# în final, a avut «cîștig de cauză», varianta C.
+#: init.cc:649
+#, c-format
+msgid "CPP on this host cannot handle wide character constants over %lu bits, but the target requires %lu bits"
+msgstr "CPP de pe această gazdă nu poate gestiona constante de caracter mai lungi de %lu biți, dar ținta necesită %lu biți"
+
+#: lex.cc:1126
+msgid "backslash and newline separated by space"
+msgstr "bară oblică inversă și linie nouă separate de spațiu «\\ n»"
+
+#: lex.cc:1131
+msgid "backslash-newline at end of file"
+msgstr "bară oblică inversă și linie nouă «\\n» la sfârșit de fișier"
+
+#: lex.cc:1147
+#, c-format
+msgid "trigraph ??%c converted to %c"
+msgstr "trigraf ??%c convertit în %c"
+
+#: lex.cc:1155
+#, c-format
+msgid "trigraph ??%c ignored, use -trigraphs to enable"
+msgstr "trigraf ??%c ignorat, utilizați „-trigraphs” pentru a activa recunoașterea sa"
+
+#: lex.cc:1536
+msgid "end of bidirectional context"
+msgstr "sfârșitul contextului bidirecţional"
+
+#: lex.cc:1577
+msgid "unpaired UTF-8 bidirectional control characters detected"
+msgstr "au fost detectate caractere de control bidirecțional UTF-8 fără pereche"
+
+#: lex.cc:1581
+msgid "unpaired UTF-8 bidirectional control character detected"
+msgstr "a fost detectat un caracter de control bidirecțional UTF-8 fără pereche"
+
+#: lex.cc:1619
+#, c-format
+msgid "UTF-8 vs UCN mismatch when closing a context by \"%s\""
+msgstr "nepotrivire între UTF-8 și UCN atunci când se încheie contextul cu „%s”"
+
+#: lex.cc:1628
+#, c-format
+msgid "\"%s\" is closing an unopened context"
+msgstr "„%s” închide un context nedeschis"
+
+#: lex.cc:1632
+#, c-format
+msgid "found problematic Unicode character \"%s\""
+msgstr "s-a găsit caracterul Unicode problematic „%s”"
+
+#: lex.cc:1682
+msgid "\"/*\" within comment"
+msgstr "„/*” în comentariu"
+
+#: lex.cc:1772
+#, c-format
+msgid "%s in preprocessing directive"
+msgstr "%s în directiva de preprocesare"
+
+#: lex.cc:1784
+msgid "null character(s) ignored"
+msgstr "caracter(e) null ignorat(e)"
+
+#: lex.cc:1844
+#, c-format
+msgid "`%.*s' is not in NFKC"
+msgstr "„%.*s” nu se este în NFKC"
+
+#: lex.cc:1847 lex.cc:1850
+#, c-format
+msgid "`%.*s' is not in NFC"
+msgstr "„%.*s” nu se este în NFC"
+
+#: lex.cc:1932
+msgid "__VA_OPT__ is not available until C++20"
+msgstr "__VA_OPT__ nu este disponibilă până la C++20"
+
+#: lex.cc:1939
+msgid "__VA_OPT__ can only appear in the expansion of a C++20 variadic macro"
+msgstr "__VA_OPT__ poate apărea doar în expansiunea unei macrocomenzi C++20 cu un număr variabil de argumente"
+
+#: lex.cc:1970 lex.cc:2066
+#, c-format
+msgid "attempt to use poisoned \"%s\""
+msgstr "încercați să utilizați „%s” «otrăvit»"
+
+#: lex.cc:1980 lex.cc:2076
+msgid "__VA_ARGS__ can only appear in the expansion of a C++11 variadic macro"
+msgstr "__VA_ARGS__ poate apărea doar în expansiunea unei macrocomenzi C++11 cu un număr variabil de argumente"
+
+#: lex.cc:1984 lex.cc:2080
+msgid "__VA_ARGS__ can only appear in the expansion of a C99 variadic macro"
+msgstr "__VA_ARGS__ poate apărea doar în expansiunea unei macrocomenzi C99 cu un număr variabil de argumente"
+
+#: lex.cc:1994 lex.cc:2092
+#, c-format
+msgid "identifier \"%s\" is a special operator name in C++"
+msgstr "identificatorul „%s” este un nume de operator special în C++"
+
+#: lex.cc:2132
+msgid "adjacent digit separators"
+msgstr "separatori de cifre adiacenți"
+
+#: lex.cc:2450
+msgid "raw string delimiter longer than 16 characters"
+msgstr "delimitator de șir brut, mai lung de 16 caractere"
+
+#: lex.cc:2454
+msgid "invalid new-line in raw string delimiter"
+msgstr "linie nouă nevalidă în delimitatorul de șir brut"
+
+#: lex.cc:2458 lex.cc:5257
+#, c-format
+msgid "invalid character '%c' in raw string delimiter"
+msgstr "caracter nevalid „%c” în delimitatorul de șir brut"
+
+#: lex.cc:2497 lex.cc:2520
+msgid "unterminated raw string"
+msgstr "șir brut neterminat"
+
+#: lex.cc:2552 lex.cc:2701
+msgid "invalid suffix on literal; C++11 requires a space between literal and string macro"
+msgstr "sufix nevalid la literal; C++11 necesită un spațiu între literal și macrocomanda șir"
+
+#: lex.cc:2684
+msgid "null character(s) preserved in literal"
+msgstr "caracter(e) null păstrat(e) în literal"
+
+#: lex.cc:2687
+#, c-format
+msgid "missing terminating %c character"
+msgstr "lipsește caracterul %c de încheiere"
+
+#: lex.cc:2719
+msgid "C++11 requires a space between string literal and macro"
+msgstr "C++11 necesită un spațiu între șir literal și macro"
+
+#: lex.cc:3312
+msgid "module control-line cannot be in included file"
+msgstr "linia de control a modulului nu poate fi în fișierul inclus"
+
+#: lex.cc:3326
+#, c-format
+msgid "module control-line \"%s\" cannot be an object-like macro"
+msgstr "linia de control al modulului „%s” nu poate fi un obiect precum o macrocomandă"
+
+#: lex.cc:3714 lex.cc:5090 traditional.cc:174
+msgid "unterminated comment"
+msgstr "comentariu neterminat"
+
+#: lex.cc:3728 lex.cc:3762
+msgid "C++ style comments are not allowed in ISO C90"
+msgstr "comentariile în stil C++ nu sunt permise în ISO C90"
+
+#: lex.cc:3730 lex.cc:3741 lex.cc:3765
+msgid "(this will be reported only once per input file)"
+msgstr "(acest lucru va fi raportat o singură dată pentru fiecare fișier de intrare)"
+
+#: lex.cc:3739
+msgid "C++ style comments are incompatible with C90"
+msgstr "comentariile în stil C++ sunt incompatibile cu C90"
+
+#: lex.cc:3771
+msgid "multi-line comment"
+msgstr "comentariu pe mai multe linii"
+
+#: lex.cc:4165
+#, c-format
+msgid "unspellable token %s"
+msgstr "element neortografiabil %s"
+
+#: lex.cc:5245
+#, c-format
+msgid "raw string delimiter longer than %d characters"
+msgstr "delimitator de șir brut mai lung de %d caractere"
+
+#: lex.cc:5315
+msgid "unterminated literal"
+msgstr "literal neterminat"
+
+#: macro.cc:94
+msgid "'##' cannot appear at either end of __VA_OPT__"
+msgstr "„##” nu poate apărea la niciunul dintre capetele lui __VA_OPT__"
+
+#: macro.cc:144
+msgid "__VA_OPT__ may not appear in a __VA_OPT__"
+msgstr "__VA_OPT__ nu poate să apară într-o __VA_OPT__"
+
+#: macro.cc:157
+msgid "__VA_OPT__ must be followed by an open parenthesis"
+msgstr "__VA_OPT__ trebuie să fie urmată de o paranteză deschisă"
+
+#: macro.cc:235
+msgid "unterminated __VA_OPT__"
+msgstr "__VA_OPT__ neterminată"
+
+#: macro.cc:397
+#, c-format
+msgid "\"%s\" used outside of preprocessing directive"
+msgstr "„%s” folosit în afara directivei de preprocesare"
+
+#: macro.cc:407
+#, c-format
+msgid "missing '(' before \"%s\" operand"
+msgstr "lipsește „(” înainte de operandul „%s”"
+
+#: macro.cc:422
+#, c-format
+msgid "operator \"%s\" requires a header-name"
+msgstr "operatorul „%s” necesită un nume de antet"
+
+#: macro.cc:439
+#, c-format
+msgid "missing ')' after \"%s\" operand"
+msgstr "lipsește „)” după operandul „%s”"
+
+#: macro.cc:459
+#, c-format
+msgid "macro \"%s\" is not used"
+msgstr "macrocomanda „%s” nu este utilizată"
+
+#: macro.cc:498 macro.cc:797
+#, c-format
+msgid "invalid built-in macro \"%s\""
+msgstr "macrocomandă încorporată „%s” nevalidă"
+
+#: macro.cc:505 macro.cc:613
+#, c-format
+msgid "macro \"%s\" might prevent reproducible builds"
+msgstr "macrocomanda „%s” ar putea împiedica compilările reproductibile"
+
+#: macro.cc:536
+msgid "could not determine file timestamp"
+msgstr "nu s-a putut determina marcajul de timp al fișierului"
+
+#: macro.cc:627
+msgid "could not determine date and time"
+msgstr "nu s-a putut determina data și ora"
+
+#: macro.cc:659
+msgid "__COUNTER__ expanded inside directive with -fdirectives-only"
+msgstr "__COUNTER__ expandat în interiorul directivei cu „-fdirectives-only”"
+
+#: macro.cc:916
+msgid "invalid string literal, ignoring final '\\'"
+msgstr "literal de șir nevalid, se ignoră „\\” final"
+
+#: macro.cc:980
+#, c-format
+msgid "pasting \"%.*s\" and \"%.*s\" does not give a valid preprocessing token"
+msgstr "lipirea lui „%.*s” și a lui„%.*s” nu oferă un element lexical de preprocesare valid"
+
+#: macro.cc:1112
+msgid "ISO C++11 requires at least one argument for the \"...\" in a variadic macro"
+msgstr "ISO C++11 necesită cel puțin un argument pentru „...” într-o macrocomandă cu un număr variabil de argumente"
+
+#: macro.cc:1116
+msgid "ISO C99 requires at least one argument for the \"...\" in a variadic macro"
+msgstr "ISO C99 necesită cel puțin un argument pentru „...” într-o macrocomandă cu un număr variabil de argumente"
+
+#: macro.cc:1123
+#, c-format
+msgid "macro \"%s\" requires %u arguments, but only %u given"
+msgstr "macrocomanda „%s” necesită %u argumente, dar numai %u sunt date"
+
+#: macro.cc:1128
+#, c-format
+msgid "macro \"%s\" passed %u arguments, but takes just %u"
+msgstr "macrocomenzii „%s” i s-au transmis %u argumente, dar are nevoie doar de %u"
+
+#: macro.cc:1132
+#, c-format
+msgid "macro \"%s\" defined here"
+msgstr "macrocomanda „%s” este definită aici"
+
+#: macro.cc:1326 traditional.cc:822
+#, c-format
+msgid "unterminated argument list invoking macro \"%s\""
+msgstr "listă neterminată de argumente care invocă macrocomanda „%s”"
+
+#: macro.cc:1472
+#, c-format
+msgid "function-like macro \"%s\" must be used with arguments in traditional C"
+msgstr "macrocomanda „%s” asemănătoare unei funcții trebuie să fie utilizată cu argumente în limbajul C tradițional"
+
+#: macro.cc:2307
+#, c-format
+msgid "invoking macro %s argument %d: empty macro arguments are undefined in ISO C++98"
+msgstr "se invocă macrocomanda %s argument %d: argumentele macro goale sunt nedefinite în ISO C++98"
+
+#: macro.cc:2315 macro.cc:2324
+#, c-format
+msgid "invoking macro %s argument %d: empty macro arguments are undefined in ISO C90"
+msgstr "se invocă macrocomanda %s argument %d: argumentele macro goale sunt nedefinite în ISO C90"
+
+#: macro.cc:3375
+#, c-format
+msgid "duplicate macro parameter \"%s\""
+msgstr "parametru de macrocomandă duplicat „%s”"
+
+#: macro.cc:3457
+#, c-format
+msgid "expected parameter name, found \"%s\""
+msgstr "se aștepta un nume parametru, s-a găsit „%s”"
+
+#: macro.cc:3458
+#, c-format
+msgid "expected ',' or ')', found \"%s\""
+msgstr "se aștepta «,» sau «)», s-a găsit „%s”"
+
+#: macro.cc:3459
+msgid "expected parameter name before end of line"
+msgstr "se aștepta un nume de parametru înainte de sfârșitul liniei"
+
+#: macro.cc:3460
+msgid "expected ')' before end of line"
+msgstr "se aștepta „)” înainte de sfârșitul liniei"
+
+#: macro.cc:3461
+msgid "expected ')' after \"...\""
+msgstr "se aștepta „)” după „...”"
+
+#: macro.cc:3518
+msgid "anonymous variadic macros were introduced in C++11"
+msgstr "macrocomenzile anonime cu un număr variabil de argumente au fost introduse în C++11"
+
+#: macro.cc:3519 macro.cc:3523
+msgid "anonymous variadic macros were introduced in C99"
+msgstr "macrocomenzile anonime cu un număr variabil de argumente au fost introduse în C99"
+
+#: macro.cc:3529
+msgid "ISO C++ does not permit named variadic macros"
+msgstr "ISO C++ nu permite macrocomenzi variadice(cu număr variabil de argumente) cu nume"
+
+#: macro.cc:3530
+msgid "ISO C does not permit named variadic macros"
+msgstr "ISO C nu permite macrocomenzi variadice(cu număr variabil de argumente) cu nume"
+
+#: macro.cc:3576
+msgid "'##' cannot appear at either end of a macro expansion"
+msgstr "„##” nu poate apărea la niciunul dintre capetele unei expandări de macrocomandă"
+
+#: macro.cc:3614
+msgid "ISO C++11 requires whitespace after the macro name"
+msgstr "ISO C++11 necesită un spațiu alb după numele macrocomenzii"
+
+#: macro.cc:3615
+msgid "ISO C99 requires whitespace after the macro name"
+msgstr "ISO C99 necesită un spațiu alb după numele macrocomenzii"
+
+#: macro.cc:3639
+msgid "missing whitespace after the macro name"
+msgstr "lipsește spațiul alb după numele macrocomenzii"
+
+#: macro.cc:3692
+msgid "'#' is not followed by a macro parameter"
+msgstr "„#” nu este urmat de un parametru macro"
+
+#: macro.cc:3848
+#, c-format
+msgid "\"%s\" redefined"
+msgstr "„%s” redefinit"
+
+#: macro.cc:3853
+msgid "this is the location of the previous definition"
+msgstr "aceasta este locația definiției precedente"
+
+#: macro.cc:3990
+#, c-format
+msgid "macro argument \"%s\" would be stringified in traditional C"
+msgstr "argumentul macrocomenzii „%s” trebuie să fie schimbat în șir în limbajul C tradițional"
+
+#: pch.cc:90 pch.cc:342 pch.cc:356 pch.cc:374 pch.cc:380 pch.cc:389 pch.cc:396
+msgid "while writing precompiled header"
+msgstr "în timpul scrierii antetului precompilat"
+
+#: pch.cc:616
+#, c-format
+msgid "%s: not used because `%.*s' is poisoned"
+msgstr "%s: nu este folosit deoarece „%.*s” este «otrăvit»"
+
+#: pch.cc:638
+#, c-format
+msgid "%s: not used because `%.*s' not defined"
+msgstr "%s: nu este folosit deoarece „%.*s” nu este definit"
+
+#: pch.cc:650
+#, c-format
+msgid "%s: not used because `%.*s' defined as `%s' not `%.*s'"
+msgstr "%s: nu este folosit deoarece „%.*s” este definit ca „%s” nu „%.*s”"
+
+#: pch.cc:691
+#, c-format
+msgid "%s: not used because `%s' is defined"
+msgstr "%s: nu este folosit deoarece „%s” este definit"
+
+#: pch.cc:711
+#, c-format
+msgid "%s: not used because `__COUNTER__' is invalid"
+msgstr "%s: nu este folosit deoarece „__COUNTER__” este nevalid"
+
+#: pch.cc:720 pch.cc:876
+msgid "while reading precompiled header"
+msgstr "în timpul citirii antetului precompilat"
+
+#: traditional.cc:891
+#, c-format
+msgid "detected recursion whilst expanding macro \"%s\""
+msgstr "s-a detectat recursivitate în timpul expandării macrocomenzii „%s”"
+
+# R-GC, scrie:
+# după revizarea fișierului, DȘ spune:
+# msgid "syntax error in macro parameter list"
+# msgstr "eroare de sintaxă în lista de parametri macro"
+# → poți spune „ai macrocomenzii” pentru a fi consistent cu restul fișierului
+# ***
+# Ok, corecție aplicată!
+#: traditional.cc:1114
+msgid "syntax error in macro parameter list"
+msgstr "eroare de sintaxă în lista de parametri ai macrocomenzii"
diff --git a/libgcc/config/avr/libf7/ChangeLog b/libgcc/config/avr/libf7/ChangeLog
index c9ad966f5e5..a56461b42e6 100644
--- a/libgcc/config/avr/libf7/ChangeLog
+++ b/libgcc/config/avr/libf7/ChangeLog
@@ -1,3 +1,12 @@
+2022-09-19  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backported from master:
+	2022-09-19  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/99184
+	* libf7-asm.sx (to_integer, to_unsigned): Don't round 16-bit
+	and 32-bit integers.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/libgcc/config/avr/libf7/libf7-asm.sx b/libgcc/config/avr/libf7/libf7-asm.sx
index cfdbecdeffe..752a939f616 100644
--- a/libgcc/config/avr/libf7/libf7-asm.sx
+++ b/libgcc/config/avr/libf7/libf7-asm.sx
@@ -601,9 +601,6 @@ DEFUN to_integer
     tst     C6
     brmi    .Lsaturate.T    ;   > INTxx_MAX  =>  saturate
 
-    rcall   .Lround
-    brmi    .Lsaturate.T    ;   > INTxx_MAX  =>  saturate
-
     brtc 9f                 ;   >= 0         =>  return
     sbrc    Mask,   5
     .global __negdi2
@@ -658,30 +655,6 @@ DEFUN to_integer
     .global __clr_8
     XJMP    __clr_8
 
-.Lround:
-    ;; C6.7 is known to be 0 here.
-    ;; Return N = 1 iff we have to saturate.
-    cpi     Mask,   0xf
-    breq .Lround16
-    cpi     Mask,   0x1f
-    breq .Lround32
-
-    ;; For now, no rounding in the 64-bit case.  This rounding
-    ;; would have to be integrated into the right-shift.
-    cln
-    ret
-
-.Lround32:
-    rol     C2
-    adc     C3,     ZERO
-    adc     C4,     ZERO
-    rjmp 2f
-
-.Lround16:
-    rol     C4
-2:  adc     C5,     ZERO
-    adc     C6,     ZERO
-    ret
 ENDF to_integer
 #endif /* F7MOD_to_integer_ */
 
@@ -725,29 +698,6 @@ DEFUN to_unsigned
     clr     CA
     F7call  lshrdi3
     POP     r16
-
-    ;; Rounding
-    ;; ??? C6.7 is known to be 0 here.
-    cpi     Mask,   0xf
-    breq .Lround16
-    cpi     Mask,   0x1f
-    breq .Lround32
-
-    ;; For now, no rounding in the 64-bit case.  This rounding
-    ;; would have to be integrated into the right-shift.
-    ret
-
-.Lround32:
-    rol     C2
-    adc     C3,     ZERO
-    adc     C4,     ZERO
-    rjmp 2f
-
-.Lround16:
-    rol     C4
-2:  adc     C5,     ZERO
-    adc     C6,     ZERO
-    brcs    .Lset_0xffff    ; Rounding overflow  =>  saturate
     ret
 
 .Lset_0xffff:
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index 5aed23549c1..feb1bf9deb3 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,23 @@
+2022-12-21  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR libfortran/108056
+	* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc,
+	gfc_desc_to_cfi_desc): Mostly revert to GCC 11 version for
+	those backward-compatiblity-only functions.
+
+2022-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-08-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/106579
+	* ieee/ieee_helper.c (IEEE_OTHER_VALUE, IEEE_SIGNALING_NAN,
+	IEEE_QUIET_NAN, IEEE_NEGATIVE_INF, IEEE_NEGATIVE_NORMAL,
+	IEEE_NEGATIVE_DENORMAL, IEEE_NEGATIVE_SUBNORMAL,
+	IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_ZERO, IEEE_POSITIVE_DENORMAL,
+	IEEE_POSITIVE_SUBNORMAL, IEEE_POSITIVE_NORMAL, IEEE_POSITIVE_INF):
+	Move to gcc/fortran/libgfortran.h.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/libgfortran/ieee/ieee_helper.c b/libgfortran/ieee/ieee_helper.c
index 7e310f2c5b0..0b87fbf7e9d 100644
--- a/libgfortran/ieee/ieee_helper.c
+++ b/libgfortran/ieee/ieee_helper.c
@@ -51,26 +51,6 @@ extern int ieee_class_helper_16 (GFC_REAL_16 *);
 internal_proto(ieee_class_helper_16);
 #endif
 
-/* Enumeration of the possible floating-point types. These values
-   correspond to the hidden arguments of the IEEE_CLASS_TYPE
-   derived-type of IEEE_ARITHMETIC.  */
-
-enum {
-  IEEE_OTHER_VALUE = 0,
-  IEEE_SIGNALING_NAN,
-  IEEE_QUIET_NAN,
-  IEEE_NEGATIVE_INF,
-  IEEE_NEGATIVE_NORMAL,
-  IEEE_NEGATIVE_DENORMAL,
-  IEEE_NEGATIVE_SUBNORMAL = IEEE_NEGATIVE_DENORMAL,
-  IEEE_NEGATIVE_ZERO,
-  IEEE_POSITIVE_ZERO,
-  IEEE_POSITIVE_DENORMAL,
-  IEEE_POSITIVE_SUBNORMAL = IEEE_POSITIVE_DENORMAL,
-  IEEE_POSITIVE_NORMAL,
-  IEEE_POSITIVE_INF
-};
-
 
 #define CLASSMACRO(TYPE) \
   int ieee_class_helper_ ## TYPE (GFC_REAL_ ## TYPE *value) \
diff --git a/libgfortran/runtime/ISO_Fortran_binding.c b/libgfortran/runtime/ISO_Fortran_binding.c
index 342df4275b9..e63a717a69b 100644
--- a/libgfortran/runtime/ISO_Fortran_binding.c
+++ b/libgfortran/runtime/ISO_Fortran_binding.c
@@ -39,60 +39,31 @@ export_proto(cfi_desc_to_gfc_desc);
 void
 cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)
 {
-  signed char type;
-  size_t size;
   int n;
+  index_type kind;
   CFI_cdesc_t *s = *s_ptr;
 
   if (!s)
     return;
 
-  /* Verify descriptor.  */
-  switch (s->attribute)
-    {
-    case CFI_attribute_pointer:
-    case CFI_attribute_allocatable:
-      break;
-    case CFI_attribute_other:
-      if (s->base_addr)
-	break;
-      runtime_error ("Nonallocatable, nonpointer actual argument to BIND(C) "
-		     "dummy argument where the effective argument is either "
-		     "not allocated or not associated");
-      break;
-    default:
-      runtime_error ("Invalid attribute type %d in CFI_cdesc_t descriptor",
-		     (int) s->attribute);
-      break;
-    }
   GFC_DESCRIPTOR_DATA (d) = s->base_addr;
+  GFC_DESCRIPTOR_TYPE (d) = (signed char)(s->type & CFI_type_mask);
+  kind = (index_type)((s->type - (s->type & CFI_type_mask)) >> CFI_type_kind_shift);
 
   /* Correct the unfortunate difference in order with types.  */
-  type = (signed char)(s->type & CFI_type_mask);
-  switch (type)
-    {
-    case CFI_type_Character:
-      type = BT_CHARACTER;
-      break;
-    case CFI_type_struct:
-      type = BT_DERIVED;
-      break;
-    case CFI_type_cptr:
-      /* FIXME: PR 100915.  GFC descriptors do not distinguish between
-	 CFI_type_cptr and CFI_type_cfunptr.  */
-      type = BT_VOID;
-      break;
-    default:
-      break;
-    }
-
-  GFC_DESCRIPTOR_TYPE (d) = type;
-  GFC_DESCRIPTOR_SIZE (d) = s->elem_len;
+  if (GFC_DESCRIPTOR_TYPE (d) == BT_CHARACTER)
+    GFC_DESCRIPTOR_TYPE (d) = BT_DERIVED;
+  else if (GFC_DESCRIPTOR_TYPE (d) == BT_DERIVED)
+    GFC_DESCRIPTOR_TYPE (d) = BT_CHARACTER;
+
+  if (!s->rank || s->dim[0].sm == (CFI_index_t)s->elem_len)
+    GFC_DESCRIPTOR_SIZE (d) = s->elem_len;
+  else if (GFC_DESCRIPTOR_TYPE (d) != BT_DERIVED)
+    GFC_DESCRIPTOR_SIZE (d) = kind;
+  else
+    GFC_DESCRIPTOR_SIZE (d) = s->elem_len;
 
   d->dtype.version = 0;
-
-  if (s->rank < 0 || s->rank > CFI_MAX_RANK)
-    internal_error (NULL, "Invalid rank in descriptor");
   GFC_DESCRIPTOR_RANK (d) = (signed char)s->rank;
 
   d->dtype.attribute = (signed short)s->attribute;
@@ -131,7 +102,6 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)
 {
   int n;
   CFI_cdesc_t *d;
-  signed char type, kind;
 
   /* Play it safe with allocation of the flexible array member 'dim'
      by setting the length to CFI_MAX_RANK. This should not be necessary
@@ -142,99 +112,22 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)
   else
     d = *d_ptr;
 
-  /* Verify descriptor.  */
-  switch (s->dtype.attribute)
-    {
-    case CFI_attribute_pointer:
-    case CFI_attribute_allocatable:
-      break;
-    case CFI_attribute_other:
-      if (s->base_addr)
-	break;
-      runtime_error ("Nonallocatable, nonpointer actual argument to BIND(C) "
-		     "dummy argument where the effective argument is either "
-		     "not allocated or not associated");
-      break;
-    default:
-      internal_error (NULL, "Invalid attribute in gfc_array descriptor");
-      break;
-    }
   d->base_addr = GFC_DESCRIPTOR_DATA (s);
   d->elem_len = GFC_DESCRIPTOR_SIZE (s);
-  if (d->elem_len <= 0)
-    internal_error (NULL, "Invalid size in descriptor");
-
   d->version = CFI_VERSION;
-
   d->rank = (CFI_rank_t)GFC_DESCRIPTOR_RANK (s);
-  if (d->rank < 0 || d->rank > CFI_MAX_RANK)
-    internal_error (NULL, "Invalid rank in descriptor");
-
   d->attribute = (CFI_attribute_t)s->dtype.attribute;
 
-  type = GFC_DESCRIPTOR_TYPE (s);
-  switch (type)
-    {
-    case BT_CHARACTER:
-      d->type = CFI_type_Character;
-      break;
-    case BT_DERIVED:
-      d->type = CFI_type_struct;
-      break;
-    case BT_VOID:
-      /* FIXME: PR 100915.  GFC descriptors do not distinguish between
-	 CFI_type_cptr and CFI_type_cfunptr.  */
-      d->type = CFI_type_cptr;
-      break;
-    default:
-      d->type = (CFI_type_t)type;
-      break;
-    }
-
-  switch (d->type)
-    {
-    case CFI_type_Integer:
-    case CFI_type_Logical:
-    case CFI_type_Real:
-      kind = (signed char)d->elem_len;
-      break;
-    case CFI_type_Complex:
-      kind = (signed char)(d->elem_len >> 1);
-      break;
-    case CFI_type_Character:
-      /* FIXME: we can't distinguish between kind/len because
-	 the GFC descriptor only encodes the elem_len..
-	 Until PR92482 is fixed, assume elem_len refers to the
-	 character size and not the string length.  */
-      kind = (signed char)d->elem_len;
-      break;
-    case CFI_type_struct:
-    case CFI_type_cptr:
-    case CFI_type_other:
-      /* FIXME: PR 100915.  GFC descriptors do not distinguish between
-	 CFI_type_cptr and CFI_type_cfunptr.  */
-      kind = 0;
-      break;
-    default:
-      internal_error (NULL, "Invalid type in descriptor");
-    }
-
-  if (kind < 0)
-    internal_error (NULL, "Invalid kind in descriptor");
-
-  /* FIXME: This is PR100917.  Because the GFC descriptor encodes only the
-     elem_len and not the kind, we get into trouble with long double kinds
-     that do not correspond directly to the elem_len, specifically the
-     kind 10 80-bit long double on x86 targets.  On x86_64, this has size
-     16 and cannot be differentiated from true _Float128.  Prefer the
-     standard long double type over the GNU extension in that case.  */
-  if (d->type == CFI_type_Real && kind == sizeof (long double))
-    d->type = CFI_type_long_double;
-  else if (d->type == CFI_type_Complex && kind == sizeof (long double))
-    d->type = CFI_type_long_double_Complex;
+  if (GFC_DESCRIPTOR_TYPE (s) == BT_CHARACTER)
+    d->type = CFI_type_Character;
+  else if (GFC_DESCRIPTOR_TYPE (s) == BT_DERIVED)
+    d->type = CFI_type_struct;
   else
+    d->type = (CFI_type_t)GFC_DESCRIPTOR_TYPE (s);
+
+  if (GFC_DESCRIPTOR_TYPE (s) != BT_DERIVED)
     d->type = (CFI_type_t)(d->type
-			   + ((CFI_type_t)kind << CFI_type_kind_shift));
+		+ ((CFI_type_t)d->elem_len << CFI_type_kind_shift));
 
   if (d->base_addr)
     /* Full pointer or allocatable arrays retain their lower_bounds.  */
diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
index ad7a09c10ee..349cc6d4769 100644
--- a/libgomp/ChangeLog
+++ b/libgomp/ChangeLog
@@ -1,3 +1,53 @@
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-10-12  Jakub Jelinek  <jakub@redhat.com>
+
+	* task.c (gomp_create_artificial_team): Fix up handling of invocations
+	from within explicit task.
+	* target.c (GOMP_target_ext): Likewise.
+	* testsuite/libgomp.c/task-7.c: New test.
+	* testsuite/libgomp.c/task-8.c: New test.
+	* testsuite/libgomp.c-c++-common/task-reduction-17.c: New test.
+	* testsuite/libgomp.c-c++-common/task-reduction-18.c: New test.
+
+2022-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/106981
+	* testsuite/libgomp.c-c++-common/pr106981.c: New test.
+
+2022-10-28  Julian Brown  <julian@codesourcery.com>
+
+	Backported from master:
+	2022-10-28  Julian Brown  <julian@codesourcery.com>
+		    Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR middle-end/90115
+	* testsuite/libgomp.oacc-fortran/declare-1.f90: Adjust scan output.
+	* testsuite/libgomp.oacc-fortran/host_data-5.F90: Likewise.
+	* testsuite/libgomp.oacc-fortran/if-1.f90: Likewise.
+	* testsuite/libgomp.oacc-fortran/print-1.f90: Likewise.
+	* testsuite/libgomp.oacc-fortran/privatized-ref-2.f90: Likewise.
+
+2022-10-21  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2022-10-20  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR target/105421
+	* testsuite/libgomp.oacc-c-c++-common/private-big-1.c: New.
+
+2022-08-23  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-08-17  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR middle-end/106548
+	* testsuite/libgomp.c/linear-2.c: New test.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/libgomp/target.c b/libgomp/target.c
index 9017458885e..fa364b9d79b 100644
--- a/libgomp/target.c
+++ b/libgomp/target.c
@@ -2639,6 +2639,7 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,
 	{
 	  struct gomp_team *team = gomp_new_team (1);
 	  struct gomp_task *task = thr->task;
+	  struct gomp_task **implicit_task = &task;
 	  struct gomp_task_icv *icv = task ? &task->icv : &gomp_global_icv;
 	  team->prev_ts = thr->ts;
 	  thr->ts.team = team;
@@ -2651,15 +2652,23 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,
 	  thr->ts.static_trip = 0;
 	  thr->task = &team->implicit_task[0];
 	  gomp_init_task (thr->task, NULL, icv);
-	  if (task)
+	  while (*implicit_task
+		 && (*implicit_task)->kind != GOMP_TASK_IMPLICIT)
+	    implicit_task = &(*implicit_task)->parent;
+	  if (*implicit_task)
 	    {
-	      thr->task = task;
+	      thr->task = *implicit_task;
 	      gomp_end_task ();
-	      free (task);
+	      free (*implicit_task);
 	      thr->task = &team->implicit_task[0];
 	    }
 	  else
 	    pthread_setspecific (gomp_thread_destructor, thr);
+	  if (implicit_task != &task)
+	    {
+	      *implicit_task = thr->task;
+	      thr->task = task;
+	    }
 	}
       if (thr->ts.team
 	  && !thr->task->final_task)
diff --git a/libgomp/task.c b/libgomp/task.c
index 828348c4cf4..cc0d38e7e57 100644
--- a/libgomp/task.c
+++ b/libgomp/task.c
@@ -2224,6 +2224,7 @@ gomp_create_artificial_team (void)
   struct gomp_task_icv *icv;
   struct gomp_team *team = gomp_new_team (1);
   struct gomp_task *task = thr->task;
+  struct gomp_task **implicit_task = &task;
   icv = task ? &task->icv : &gomp_global_icv;
   team->prev_ts = thr->ts;
   thr->ts.team = team;
@@ -2236,17 +2237,25 @@ gomp_create_artificial_team (void)
   thr->ts.static_trip = 0;
   thr->task = &team->implicit_task[0];
   gomp_init_task (thr->task, NULL, icv);
-  if (task)
+  while (*implicit_task
+	 && (*implicit_task)->kind != GOMP_TASK_IMPLICIT)
+    implicit_task = &(*implicit_task)->parent;
+  if (*implicit_task)
     {
-      thr->task = task;
+      thr->task = *implicit_task;
       gomp_end_task ();
-      free (task);
+      free (*implicit_task);
       thr->task = &team->implicit_task[0];
     }
 #ifdef LIBGOMP_USE_PTHREADS
   else
     pthread_setspecific (gomp_thread_destructor, thr);
 #endif
+  if (implicit_task != &task)
+    {
+      *implicit_task = thr->task;
+      thr->task = task;
+    }
 }
 
 /* The format of data is:
diff --git a/libgomp/testsuite/libgomp.c-c++-common/pr106981.c b/libgomp/testsuite/libgomp.c-c++-common/pr106981.c
new file mode 100644
index 00000000000..ed48d2774f2
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/pr106981.c
@@ -0,0 +1,19 @@
+/* PR c/106981 */
+
+int
+main ()
+{
+  int a[0x101];
+  unsigned int b = 0x100;
+  if ((unsigned char) b || (unsigned short) b != 0x100)
+    return 0;
+  a[0] = 0;
+  a[0x100] = 42;
+  #pragma omp atomic update
+  a[(unsigned char) b] = a[(unsigned short) b] + a[(unsigned char) b];
+  #pragma omp atomic update
+  a[(unsigned char) b] = a[(unsigned char) b] + a[(unsigned short) b];
+  if (a[0] != 84 || a[0x100] != 42)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/task-reduction-17.c b/libgomp/testsuite/libgomp.c-c++-common/task-reduction-17.c
new file mode 100644
index 00000000000..4a8d1e8bb73
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/task-reduction-17.c
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+
+#include <omp.h>
+#include <stdlib.h>
+
+int a;
+
+int
+main ()
+{
+  #pragma omp task final (1)
+  {
+    if (!omp_in_final ())
+      abort ();
+    #pragma omp task
+    {
+      if (!omp_in_final ())
+	abort ();
+      #pragma omp taskgroup task_reduction (+: a)
+      {
+	if (!omp_in_final ())
+	  abort ();
+	#pragma omp task in_reduction (+: a)
+	{
+	  ++a;
+	  if (!omp_in_final ())
+	    abort ();
+	}
+      }
+      if (!omp_in_final ())
+	abort ();
+      #pragma omp taskwait
+    }
+  }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/task-reduction-18.c b/libgomp/testsuite/libgomp.c-c++-common/task-reduction-18.c
new file mode 100644
index 00000000000..483f4406f6f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/task-reduction-18.c
@@ -0,0 +1,17 @@
+/* { dg-do run } */
+
+int a;
+
+int
+main ()
+{
+  #pragma omp task
+  {
+    #pragma omp taskgroup task_reduction (+: a)
+    {
+      #pragma omp task in_reduction (+: a)
+      ++a;
+    }
+  }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/linear-2.c b/libgomp/testsuite/libgomp.c/linear-2.c
new file mode 100644
index 00000000000..fd549a89490
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/linear-2.c
@@ -0,0 +1,254 @@
+/* PR middle-end/106548.  */
+/* { dg-additional-options "-msse2" { target sse2_runtime } } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+
+int a[256];
+
+__attribute__((noinline, noclone)) int
+f1 (int i)
+{
+  #pragma omp parallel for simd linear (i: 4)
+  for (int j = 16; j < 64; j++)
+    {
+      a[i] = j;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) short int
+f2 (short int i, char k)
+{
+  #pragma omp parallel for simd linear (i: k + 1)
+  for (long j = 16; j < 64; j++)
+    {
+      a[i] = j;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) long long int
+f3 (long long int i, long long int k)
+{
+  #pragma omp parallel for simd linear (i: k)
+  for (short j = 16; j < 64; j++)
+    {
+      a[i] = j;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) int
+f4 (int i)
+{
+  #pragma omp parallel for simd linear (i: 4) schedule(static, 3)
+  for (int j = 16; j < 64; j++)
+    {
+      a[i] = j;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) short int
+f5 (short int i, char k)
+{
+  #pragma omp parallel for simd linear (i: k + 1) schedule(static, 5)
+  for (long j = 16; j < 64; j++)
+    {
+      a[i] = j;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) long long int
+f6 (long long int i, long long int k)
+{
+  #pragma omp parallel for simd linear (i: k) schedule(static, 7)
+  for (short j = 16; j < 64; j++)
+    {
+      a[i] = j;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) int
+f7 (int i)
+{
+  #pragma omp parallel for simd linear (i: 4) schedule(dynamic, 3)
+  for (int j = 16; j < 64; j++)
+    {
+      a[i] = j;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) short int
+f8 (short int i, char k)
+{
+  #pragma omp parallel for simd linear (i: k + 1) schedule(dynamic, 5)
+  for (long j = 16; j < 64; j++)
+    {
+      a[i] = j;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) long long int
+f9 (long long int i, long long int k)
+{
+  #pragma omp parallel for simd linear (i: k) schedule(dynamic, 7)
+  for (short j = 16; j < 64; j++)
+    {
+      a[i] = j;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) int
+f10 (int i, long step)
+{
+  #pragma omp parallel for simd linear (i: 4)
+  for (int j = 16; j < 112; j += step)
+    {
+      a[i] = j / 2 + 8;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) short int
+f11 (short int i, char k, char step)
+{
+  #pragma omp parallel for simd linear (i: k + 1)
+  for (long j = 16; j < 112; j += step)
+    {
+      a[i] = j / 2 + 8;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) long long int
+f12 (long long int i, long long int k, int step)
+{
+  #pragma omp parallel for simd linear (i: k)
+  for (short j = 16; j < 112; j += step)
+    {
+      a[i] = j / 2 + 8;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) int
+f13 (int i, long long int step)
+{
+  #pragma omp parallel for simd linear (i: 4) schedule(static, 3)
+  for (int j = 16; j < 112; j += step)
+    {
+      a[i] = j / 2 + 8;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) short int
+f14 (short int i, char k, int step)
+{
+  #pragma omp parallel for simd linear (i: k + 1) schedule(static, 5)
+  for (long j = 16; j < 112; j += step)
+    {
+      a[i] = j / 2 + 8;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) long long int
+f15 (long long int i, long long int k, long int step)
+{
+  #pragma omp parallel for simd linear (i: k) schedule(static, 7)
+  for (short j = 16; j < 112; j += step)
+    {
+      a[i] = j / 2 + 8;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) int
+f16 (int i, long long int step)
+{
+  #pragma omp parallel for simd linear (i: 4) schedule(dynamic, 3)
+  for (int j = 16; j < 112; j += step)
+    {
+      a[i] = j / 2 + 8;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) short int
+f17 (short int i, char k, int step)
+{
+  #pragma omp parallel for simd linear (i: k + 1) schedule(dynamic, 5)
+  for (long j = 16; j < 112; j += step)
+    {
+      a[i] = j / 2 + 8;
+      i += 4;
+    }
+  return i;
+}
+
+__attribute__((noinline, noclone)) long long int
+f18 (long long int i, long long int k, long int step)
+{
+  #pragma omp parallel for simd linear (i: k) schedule(dynamic, 7)
+  for (short j = 16; j < 112; j += step)
+    {
+      a[i] = j / 2 + 8;
+      i += 4;
+    }
+  return i;
+}
+
+int
+main ()
+{
+#define TEST(x) \
+  if (x != 8 + 48 * 4)				\
+    __builtin_abort ();				\
+  for (int i = 0; i < 256; i++)			\
+    if (a[i] != (((i & 3) == 0 && i >= 8	\
+		  && i < 8 + 48 * 4)		\
+		 ? ((i - 8) / 4) + 16 : 0))	\
+      __builtin_abort ();			\
+  __builtin_memset (a, 0, sizeof (a))
+  TEST (f1 (8));
+  TEST (f2 (8, 3));
+  TEST (f3 (8LL, 4LL));
+  TEST (f4 (8));
+  TEST (f5 (8, 3));
+  TEST (f6 (8LL, 4LL));
+  TEST (f7 (8));
+  TEST (f8 (8, 3));
+  TEST (f9 (8LL, 4LL));
+  TEST (f10 (8, 2));
+  TEST (f11 (8, 3, 2));
+  TEST (f12 (8LL, 4LL, 2));
+  TEST (f13 (8, 2));
+  TEST (f14 (8, 3, 2));
+  TEST (f15 (8LL, 4LL, 2));
+  TEST (f16 (8, 2));
+  TEST (f17 (8, 3, 2));
+  TEST (f18 (8LL, 4LL, 2));
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/task-7.c b/libgomp/testsuite/libgomp.c/task-7.c
new file mode 100644
index 00000000000..0307575f978
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/task-7.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+
+#include <omp.h>
+#include <stdlib.h>
+
+int
+main ()
+{
+  #pragma omp task final (1)
+  {
+    if (!omp_in_final ())
+      abort ();
+    #pragma omp task
+    {
+      if (!omp_in_final ())
+	abort ();
+      #pragma omp target nowait
+      if (omp_in_final ())
+	abort ();
+      if (!omp_in_final ())
+	abort ();
+      #pragma omp taskwait
+    }
+  }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/task-8.c b/libgomp/testsuite/libgomp.c/task-8.c
new file mode 100644
index 00000000000..f03aef6a030
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/task-8.c
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+
+int
+main ()
+{
+  int i = 0;
+  #pragma omp task
+  {
+    #pragma omp target nowait private (i)
+    i = 1;
+    #pragma omp taskwait
+  }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/private-big-1.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/private-big-1.c
new file mode 100644
index 00000000000..c0e8db0c894
--- /dev/null
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/private-big-1.c
@@ -0,0 +1,100 @@
+/* Test "big" private data.  */
+
+/* { dg-additional-options -fno-inline } for stable results regarding OpenACC 'routine'.  */
+
+/* { dg-additional-options -fopt-info-all-omp }
+   { dg-additional-options --param=openacc-privatization=noisy }
+   { dg-additional-options -foffload=-fopt-info-all-omp }
+   { dg-additional-options -foffload=--param=openacc-privatization=noisy }
+   for testing/documenting aspects of that functionality.  */
+
+/* { dg-additional-options -Wopenacc-parallelism } for testing/documenting
+   aspects of that functionality.  */
+
+/* For GCN offloading compilation, we (expectedly) run into a
+   'gang-private data-share memory exhausted' error: the default
+   '-mgang-private-size' is too small.  Raise it so that 'uint32_t x[344]' plus
+   some internal-use data fits in:
+   { dg-additional-options -foffload-options=amdgcn-amdhsa=-mgang-private-size=1555 { target openacc_radeon_accel_selected } } */
+
+/* It's only with Tcl 8.5 (released in 2007) that "the variable 'varName'
+   passed to 'incr' may be unset, and in that case, it will be set to [...]",
+   so to maintain compatibility with earlier Tcl releases, we manually
+   initialize counter variables:
+   { dg-line l_dummy[variable c_compute 0 c_loop 0] }
+   { dg-message dummy {} { target iN-VAl-Id } l_dummy } to avoid
+   "WARNING: dg-line var l_dummy defined, but not used".  */
+
+#include <assert.h>
+#include <stdint.h>
+
+
+/* Based on 'private-variables.c:loop_g_5'.  */
+
+/* To demonstrate PR105421 "GCN offloading, raised '-mgang-private-size':
+   'HSA_STATUS_ERROR_MEMORY_APERTURE_VIOLATION'", a 'struct' indirection, for
+   example, has been necessary in combination with a separate routine.  */
+
+struct data
+{
+  uint32_t *x;
+  uint32_t *arr;
+  uint32_t i;
+};
+
+#pragma acc routine worker
+static void
+loop_g_5_r(struct data *data)
+{
+  uint32_t *x = data->x;
+  uint32_t *arr = data->arr;
+  uint32_t i = data->i;
+
+#pragma acc loop /* { dg-line l_loop[incr c_loop] } */
+  /* { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop$c_loop } */
+  /* { dg-optimized {assigned OpenACC worker vector loop parallelism} {} { target *-*-* } l_loop$c_loop } */
+  for (int j = 0; j < 320; j++)
+    arr[i * 320 + j] += x[(i * 320 + j) % 344];
+}
+
+void loop_g_5()
+{
+  uint32_t x[344], i, arr[320 * 320];
+
+  for (i = 0; i < 320 * 320; i++)
+    arr[i] = i;
+
+  #pragma acc parallel copy(arr)
+  {
+    #pragma acc loop gang private(x) /* { dg-line l_loop[incr c_loop] } */
+    /* { dg-note {variable 'x' in 'private' clause is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop$c_loop }
+       { dg-note {variable 'x' ought to be adjusted for OpenACC privatization level: 'gang'} {} { target *-*-* } l_loop$c_loop }
+       { dg-note {variable 'x' adjusted for OpenACC privatization level: 'gang'} {} { target { ! openacc_host_selected } } l_loop$c_loop } */
+    /* { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop$c_loop } */
+    /* { dg-note {variable 'data' declared in block is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_loop$c_loop }
+       { dg-note {variable 'data' ought to be adjusted for OpenACC privatization level: 'gang'} {} { target *-*-* } l_loop$c_loop }
+       { dg-note {variable 'data' adjusted for OpenACC privatization level: 'gang'} {} { target { ! openacc_host_selected } } l_loop$c_loop } */
+    /* { dg-note {variable 'j' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} {} { target *-*-* } l_loop$c_loop } */
+    /* { dg-optimized {assigned OpenACC gang loop parallelism} {} { target *-*-* } l_loop$c_loop } */
+    for (i = 0; i < 320; i++)
+      {
+        for (int j = 0; j < 344; j++)
+	  x[j] = j * (2 + i);
+
+	struct data data = { x, arr, i };
+	loop_g_5_r(&data); /* { dg-line l_compute[incr c_compute] } */
+	/* { dg-optimized {assigned OpenACC worker vector loop parallelism} {} { target *-*-* } l_compute$c_compute } */
+      }
+  }
+
+  for (i = 0; i < 320 * 320; i++)
+    assert(arr[i] == i + (i % 344) * (2 + (i / 320)));
+}
+
+
+int main ()
+{
+  loop_g_5();
+
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/declare-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/declare-1.f90
index 51776a1d260..89bd4a2d094 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/declare-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/declare-1.f90
@@ -215,7 +215,7 @@ program main
   ! { dg-note {variable 'C\.[0-9]+' declared in block potentially has improper OpenACC privatization level: 'const_decl'} "TODO" { target *-*-* } .-1 }
   ! { dg-note {variable 'D\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-2 }
   ! { dg-note {variable 'S\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-3 }
-  ! { dg-note {variable 'desc\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-4 }
+  ! { dg-note {variable 'desc\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-4 }
   use vars
   use openacc
   implicit none
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/host_data-5.F90 b/libgomp/testsuite/libgomp.oacc-fortran/host_data-5.F90
index 93e9ee09818..c3453a579ae 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/host_data-5.F90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/host_data-5.F90
@@ -43,7 +43,7 @@ subroutine foo (p2, parr, host_p, host_parr, cond)
   ! { dg-note {variable 'D\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target { ! openacc_host_selected } } .-2 }
   ! { dg-note {variable 'p\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-3 }
   ! { dg-note {variable 'parr\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-4 }
-  ! { dg-note {variable 'parm\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target { ! openacc_host_selected } } .-5 }
+  ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target { ! openacc_host_selected } } .-5 }
 #if !ACC_MEM_SHARED
     if (acc_is_present(p, c_sizeof(p))) stop 5
     if (acc_is_present(parr, 1)) stop 6
@@ -54,8 +54,8 @@ subroutine foo (p2, parr, host_p, host_parr, cond)
     ! { dg-note {variable 'host_p\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-3 }
     ! { dg-note {variable 'parr\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-4 }
     ! { dg-note {variable 'host_parr\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-5 }
-    ! { dg-note {variable 'D\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-6 }
-    ! { dg-note {variable 'transfer\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-7 }
+    ! { dg-note {variable 'D\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-6 }
+    ! { dg-note {variable 'transfer\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-7 }
     ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-8 }
       ! not mapped yet, so it will be equal to the host pointer.
       if (transfer(c_loc(p), host_p) /= host_p) stop 7
@@ -74,9 +74,9 @@ subroutine foo (p2, parr, host_p, host_parr, cond)
     ! { dg-note {variable 'host_p\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-5 }
     ! { dg-note {variable 'host_parr\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-6 }
     ! { dg-note {variable 'C\.[0-9]+' declared in block potentially has improper OpenACC privatization level: 'const_decl'} "TODO" { target *-*-* } .-7 }
-    ! { dg-note {variable 'parm\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-8 }
-    ! { dg-note {variable 'D\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-9 }
-    ! { dg-note {variable 'transfer\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-10 }
+    ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-8 }
+    ! { dg-note {variable 'D\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-9 }
+    ! { dg-note {variable 'transfer\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-10 }
     ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-11 }
       if (.not. acc_is_present(p, c_sizeof(p))) stop 11
       if (.not. acc_is_present(parr, 1)) stop 12
@@ -90,8 +90,8 @@ subroutine foo (p2, parr, host_p, host_parr, cond)
       ! { dg-note {variable 'host_p\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-3 }
       ! { dg-note {variable 'parr\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-4 }
       ! { dg-note {variable 'host_parr\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-5 }
-      ! { dg-note {variable 'D\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-6 }
-      ! { dg-note {variable 'transfer\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-7 }
+      ! { dg-note {variable 'D\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-6 }
+      ! { dg-note {variable 'transfer\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-7 }
       ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-8 }
 #if ACC_MEM_SHARED
         if (transfer(c_loc(p), host_p) /= host_p) stop 15
@@ -110,8 +110,8 @@ subroutine foo (p2, parr, host_p, host_parr, cond)
         ! { dg-note {variable 'parr\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-4 }
         ! { dg-note {variable 'host_parr\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-5 }
         ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-6 }
-        ! { dg-note {variable 'D\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-7 }
-        ! { dg-note {variable 'transfer\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-8 }
+        ! { dg-note {variable 'D\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-7 }
+        ! { dg-note {variable 'transfer\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-8 }
 #if ACC_MEM_SHARED
         if (transfer(c_loc(p), host_p) /= host_p) stop 19
         if (transfer(c_loc(parr), host_parr) /= host_parr) stop 20
@@ -129,8 +129,8 @@ subroutine foo (p2, parr, host_p, host_parr, cond)
         ! { dg-note {variable 'parr\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-4 }
         ! { dg-note {variable 'host_parr\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-5 }
         ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-6 }
-        ! { dg-note {variable 'D\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-7 }
-        ! { dg-note {variable 'transfer\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "TODO" { target *-*-* } .-8 }
+        ! { dg-note {variable 'D\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-7 }
+        ! { dg-note {variable 'transfer\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } .-8 }
 #if ACC_MEM_SHARED
         if (transfer(c_loc(p), host_p) /= host_p) stop 23
         if (transfer(c_loc(parr), host_parr) /= host_parr) stop 24
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/if-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/if-1.f90
index c6d67647d4a..e0cfd912d0f 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/if-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/if-1.f90
@@ -382,7 +382,7 @@ program main
   b(:) = 1.0
 
   !$acc data copyin (a(1:N)) copyout (b(1:N)) if (0 == 1)
-  ! { dg-note {variable 'parm\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "" { target { ! openacc_host_selected } } .-1 }
+  ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target { ! openacc_host_selected } } .-1 }
 
 #if !ACC_MEM_SHARED
   if (acc_is_present (a) .eqv. .TRUE.) STOP 21
@@ -396,7 +396,7 @@ program main
 
   !$acc data copyin (a(1:N)) if (1 == 1)
   ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-1 }
-  ! { dg-note {variable 'parm\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "" { target { ! openacc_host_selected } } .-2 }
+  ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target { ! openacc_host_selected } } .-2 }
 
 #if !ACC_MEM_SHARED
     if (acc_is_present (a) .eqv. .FALSE.) STOP 23
@@ -404,7 +404,7 @@ program main
 
     !$acc data copyout (b(1:N)) if (0 == 1)
     ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-1 }
-    ! { dg-note {variable 'parm\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "" { target { ! openacc_host_selected } } .-2 }
+    ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target { ! openacc_host_selected } } .-2 }
 #if !ACC_MEM_SHARED
       if (acc_is_present (b) .eqv. .TRUE.) STOP 24
 #endif
@@ -877,7 +877,7 @@ program main
   b(:) = 1.0
 
   !$acc data copyin (a(1:N)) copyout (b(1:N)) if (0 == 1)
-  ! { dg-note {variable 'parm\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "" { target { ! openacc_host_selected } } .-1 }
+  ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target { ! openacc_host_selected } } .-1 }
 
 #if !ACC_MEM_SHARED
   if (acc_is_present (a) .eqv. .TRUE.) STOP 56
@@ -891,7 +891,7 @@ program main
 
   !$acc data copyin (a(1:N)) if (1 == 1)
   ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-1 }
-  ! { dg-note {variable 'parm\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "" { target { ! openacc_host_selected } } .-2 }
+  ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target { ! openacc_host_selected } } .-2 }
 
 #if !ACC_MEM_SHARED
     if (acc_is_present (a) .eqv. .FALSE.) STOP 58
@@ -899,7 +899,7 @@ program main
 
     !$acc data copyout (b(1:N)) if (0 == 1)
     ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} "" { target *-*-* } .-1 }
-    ! { dg-note {variable 'parm\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "" { target { ! openacc_host_selected } } .-2 }
+    ! { dg-note {variable 'parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target { ! openacc_host_selected } } .-2 }
 #if !ACC_MEM_SHARED
       if (acc_is_present (b) .eqv. .TRUE.) STOP 59
 #endif
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/print-1.f90 b/libgomp/testsuite/libgomp.oacc-fortran/print-1.f90
index 42a8538e1fb..d2f89d915f8 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/print-1.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/print-1.f90
@@ -6,15 +6,6 @@
 ! Separate file 'print-1-nvptx.f90' for nvptx offloading.
 ! { dg-skip-if "separate file" { offload_target_nvptx } }
 
-! For GCN offloading compilation, when gang-privatizing 'dt_parm.N'
-! (see below), we run into an 'gang-private data-share memory exhausted'
-! error: the default '-mgang-private-size' is too small.  Per
-! 'gcc/fortran/trans-io.cc'/'libgfortran/io/io.h', that one is
-! 'struct st_parameter_dt', which indeed is rather big.  Instead of
-! working out its exact size (which may vary per GCC configuration),
-! raise '-mgang-private-size' to an arbitrary high value.
-! { dg-additional-options "-foffload-options=amdgcn-amdhsa=-mgang-private-size=13579" { target openacc_radeon_accel_selected } }
-
 ! { dg-additional-options "-fopt-info-note-omp" }
 ! { dg-additional-options "-foffload=-fopt-info-note-omp" }
 
@@ -36,9 +27,7 @@ program main
   integer :: var = 42
 
 !$acc parallel ! { dg-line l_compute[incr c_compute] }
-  ! { dg-note {variable 'dt_parm\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} {} { target *-*-* } l_compute$c_compute }
-  !   { dg-note {variable 'dt_parm\.[0-9]+' ought to be adjusted for OpenACC privatization level: 'gang'} {} { target *-*-* } l_compute$c_compute }
-  !   { dg-note {variable 'dt_parm\.[0-9]+' adjusted for OpenACC privatization level: 'gang'} {} { target { ! openacc_host_selected } } l_compute$c_compute }
+  ! { dg-note {variable 'dt_parm\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} {} { target *-*-* } l_compute$c_compute }
   write (0, '("The answer is ", I2)') var
 !$acc end parallel
 
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/privatized-ref-2.f90 b/libgomp/testsuite/libgomp.oacc-fortran/privatized-ref-2.f90
index b31f4066152..498ef70b63a 100644
--- a/libgomp/testsuite/libgomp.oacc-fortran/privatized-ref-2.f90
+++ b/libgomp/testsuite/libgomp.oacc-fortran/privatized-ref-2.f90
@@ -122,9 +122,7 @@ contains
     ! { dg-note {variable 'str' in 'private' clause is candidate for adjusting OpenACC privatization level} "" { target *-*-* } l_loop$c_loop }
     ! { dg-note {variable 'str' ought to be adjusted for OpenACC privatization level: 'gang'} "" { target *-*-* } l_loop$c_loop }
     ! { dg-note {variable 'str' adjusted for OpenACC privatization level: 'gang'} "" { target { ! { openacc_host_selected || { openacc_nvidia_accel_selected && __OPTIMIZE__ } } } } l_loop$c_loop }
-    ! { dg-note {variable 'char\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "" { target *-*-* } l_loop$c_loop }
-    ! { dg-note {variable 'char\.[0-9]+' ought to be adjusted for OpenACC privatization level: 'gang'} "" { target *-*-* } l_loop$c_loop }
-    ! { dg-note {variable 'char\.[0-9]+' adjusted for OpenACC privatization level: 'gang'} "" { target { ! { openacc_host_selected || { openacc_nvidia_accel_selected && __OPTIMIZE__ } } } } l_loop$c_loop }
+    ! { dg-note {variable 'char\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } l_loop$c_loop }
     ! { dg-message {sorry, unimplemented: target cannot support alloca} PR65181 { target openacc_nvidia_accel_selected } l_loop$c_loop }
     do i = 1, 10
       str(i:i) = achar(ichar('A') + i)
@@ -167,9 +165,7 @@ contains
     ! { dg-note {variable 'scalar' in 'private' clause is candidate for adjusting OpenACC privatization level} "" { target *-*-* } l_loop$c_loop }
     ! { dg-note {variable 'scalar' ought to be adjusted for OpenACC privatization level: 'gang'} "" { target *-*-* } l_loop$c_loop }
     ! { dg-note {variable 'scalar' adjusted for OpenACC privatization level: 'gang'} "" { target { ! { openacc_host_selected || { openacc_nvidia_accel_selected && __OPTIMIZE__ } } } } l_loop$c_loop }
-    ! { dg-note {variable 'char\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} "" { target *-*-* } l_loop$c_loop }
-    ! { dg-note {variable 'char\.[0-9]+' ought to be adjusted for OpenACC privatization level: 'gang'} "" { target *-*-* } l_loop$c_loop }
-    ! { dg-note {variable 'char\.[0-9]+' adjusted for OpenACC privatization level: 'gang'} "" { target { ! { openacc_host_selected || { openacc_nvidia_accel_selected && __OPTIMIZE__ } } } } l_loop$c_loop }
+    ! { dg-note {variable 'char\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: artificial} "" { target *-*-* } l_loop$c_loop }
     do i = 1, 15
       scalar(i:i) = achar(ichar('A') + i)
     end do
diff --git a/libiberty/ChangeLog b/libiberty/ChangeLog
index 3bfb448a1fe..86254dcc8bd 100644
--- a/libiberty/ChangeLog
+++ b/libiberty/ChangeLog
@@ -1,3 +1,17 @@
+2023-01-04  Florian Weimer  <fweimer@redhat.com>
+
+	Backported from master:
+	2022-10-18  Florian Weimer  <fweimer@redhat.com>
+
+	* acinclude.m4 (ac_cv_func_strncmp_works): Add missing
+	int return type and parameter list to the definition of main.
+	Include <stdlib.h> and <string.h> for prototypes.
+	(ac_cv_c_stack_direction): Add missing
+	int return type and parameter list to the definitions of
+	main, find_stack_direction.  Include <stdlib.h> for exit
+	prototype.
+	* configure: Regenerate.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/libiberty/acinclude.m4 b/libiberty/acinclude.m4
index 6bd127e9826..6bb690597bf 100644
--- a/libiberty/acinclude.m4
+++ b/libiberty/acinclude.m4
@@ -24,6 +24,8 @@ AC_CACHE_CHECK([for working strncmp], ac_cv_func_strncmp_works,
 [AC_TRY_RUN([
 /* Test by Jim Wilson and Kaveh Ghazi.
    Check whether strncmp reads past the end of its string parameters. */
+#include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 
 #ifdef HAVE_FCNTL_H
@@ -51,7 +53,8 @@ AC_CACHE_CHECK([for working strncmp], ac_cv_func_strncmp_works,
 
 #define MAP_LEN 0x10000
 
-main ()
+int
+main (void)
 {
 #if defined(HAVE_MMAP) || defined(HAVE_MMAP_ANYWHERE)
   char *p;
@@ -157,7 +160,10 @@ if test $ac_cv_os_cray = yes; then
 fi
 
 AC_CACHE_CHECK(stack direction for C alloca, ac_cv_c_stack_direction,
-[AC_TRY_RUN([find_stack_direction ()
+[AC_TRY_RUN([#include <stdlib.h>
+
+int
+find_stack_direction (void)
 {
   static char *addr = 0;
   auto char dummy;
@@ -169,7 +175,9 @@ AC_CACHE_CHECK(stack direction for C alloca, ac_cv_c_stack_direction,
   else
     return (&dummy > addr) ? 1 : -1;
 }
-main ()
+
+int
+main (void)
 {
   exit (find_stack_direction() < 0);
 }],
diff --git a/libiberty/configure b/libiberty/configure
index 0a797255c70..ca83f89da6d 100755
--- a/libiberty/configure
+++ b/libiberty/configure
@@ -6780,7 +6780,10 @@ else
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-find_stack_direction ()
+#include <stdlib.h>
+
+int
+find_stack_direction (void)
 {
   static char *addr = 0;
   auto char dummy;
@@ -6792,7 +6795,9 @@ find_stack_direction ()
   else
     return (&dummy > addr) ? 1 : -1;
 }
-main ()
+
+int
+main (void)
 {
   exit (find_stack_direction() < 0);
 }
@@ -7617,6 +7622,8 @@ else
 
 /* Test by Jim Wilson and Kaveh Ghazi.
    Check whether strncmp reads past the end of its string parameters. */
+#include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 
 #ifdef HAVE_FCNTL_H
@@ -7644,7 +7651,8 @@ else
 
 #define MAP_LEN 0x10000
 
-main ()
+int
+main (void)
 {
 #if defined(HAVE_MMAP) || defined(HAVE_MMAP_ANYWHERE)
   char *p;
diff --git a/libphobos/ChangeLog b/libphobos/ChangeLog
index 09991973dba..7327053c48b 100644
--- a/libphobos/ChangeLog
+++ b/libphobos/ChangeLog
@@ -1,3 +1,17 @@
+2022-12-13  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/core/stdc/fenv.d: Compile in MIPS uClibc bindings on
+	MIPS_Any targets.
+	* libdruntime/core/stdc/math.d: Likewise.
+	* libdruntime/core/sys/posix/dlfcn.d: Likewise.
+	* libdruntime/core/sys/posix/setjmp.d: Add MIPS64 definitions for
+	CRuntime_UClibc.
+	* libdruntime/core/sys/posix/sys/types.d: Likewise.
+	* src/std/path.d (expandTilde): Handle more errno codes that could be
+	left set by getpwnam_r.
+	* src/std/random.d: Use D_LP64 in unittests.
+	* src/std/stdio.d: Set CRuntime_UClibc as GENERIC_IO target.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/libphobos/libdruntime/core/stdc/fenv.d b/libphobos/libdruntime/core/stdc/fenv.d
index 88123fb16a6..5242ba9d4e2 100644
--- a/libphobos/libdruntime/core/stdc/fenv.d
+++ b/libphobos/libdruntime/core/stdc/fenv.d
@@ -483,7 +483,7 @@ else version (CRuntime_UClibc)
 
         alias fexcept_t = ushort;
     }
-    else version (MIPS32)
+    else version (MIPS_Any)
     {
         struct fenv_t
         {
diff --git a/libphobos/libdruntime/core/stdc/math.d b/libphobos/libdruntime/core/stdc/math.d
index 0393ea52c07..51fd68f9fc3 100644
--- a/libphobos/libdruntime/core/stdc/math.d
+++ b/libphobos/libdruntime/core/stdc/math.d
@@ -120,7 +120,7 @@ else version (CRuntime_UClibc)
         ///
         enum int FP_ILOGBNAN      = int.min;
     }
-    else version (MIPS32)
+    else version (MIPS_Any)
     {
         ///
         enum int FP_ILOGB0        = -int.max;
diff --git a/libphobos/libdruntime/core/sys/posix/dlfcn.d b/libphobos/libdruntime/core/sys/posix/dlfcn.d
index a9519ca234a..24fa3787ec4 100644
--- a/libphobos/libdruntime/core/sys/posix/dlfcn.d
+++ b/libphobos/libdruntime/core/sys/posix/dlfcn.d
@@ -387,7 +387,7 @@ else version (CRuntime_UClibc)
         enum RTLD_LOCAL             = 0;
         enum RTLD_NODELETE          = 0x01000;
     }
-    else version (MIPS32)
+    else version (MIPS_Any)
     {
         enum RTLD_LAZY              = 0x0001;
         enum RTLD_NOW               = 0x0002;
diff --git a/libphobos/libdruntime/core/sys/posix/setjmp.d b/libphobos/libdruntime/core/sys/posix/setjmp.d
index 91e3a19d081..5a15d82d2ee 100644
--- a/libphobos/libdruntime/core/sys/posix/setjmp.d
+++ b/libphobos/libdruntime/core/sys/posix/setjmp.d
@@ -370,6 +370,22 @@ else version (CRuntime_UClibc)
                 double[6] __fpregs;
         }
     }
+    else version (MIPS64)
+    {
+        struct __jmp_buf
+        {
+            long __pc;
+            long __sp;
+            long[8] __regs;
+            long __fp;
+            long __gp;
+            int __fpc_csr;
+            version (MIPS_N64)
+                double[8] __fpregs;
+            else
+                double[6] __fpregs;
+        }
+    }
     else
         static assert(0, "unimplemented");
 
diff --git a/libphobos/libdruntime/core/sys/posix/sys/types.d b/libphobos/libdruntime/core/sys/posix/sys/types.d
index ec229dd3b2b..3e515c4c68e 100644
--- a/libphobos/libdruntime/core/sys/posix/sys/types.d
+++ b/libphobos/libdruntime/core/sys/posix/sys/types.d
@@ -1140,6 +1140,18 @@ else version (CRuntime_UClibc)
         enum __SIZEOF_PTHREAD_BARRIER_T     = 20;
         enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
      }
+     else version (MIPS64)
+     {
+        enum __SIZEOF_PTHREAD_ATTR_T        = 56;
+        enum __SIZEOF_PTHREAD_MUTEX_T       = 40;
+        enum __SIZEOF_PTHREAD_MUTEXATTR_T   = 4;
+        enum __SIZEOF_PTHREAD_COND_T        = 48;
+        enum __SIZEOF_PTHREAD_CONDATTR_T    = 4;
+        enum __SIZEOF_PTHREAD_RWLOCK_T      = 56;
+        enum __SIZEOF_PTHREAD_RWLOCKATTR_T  = 8;
+        enum __SIZEOF_PTHREAD_BARRIER_T     = 32;
+        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
+     }
      else version (ARM)
      {
         enum __SIZEOF_PTHREAD_ATTR_T = 36;
diff --git a/libphobos/src/std/path.d b/libphobos/src/std/path.d
index de180fcc548..777d8b924dd 100644
--- a/libphobos/src/std/path.d
+++ b/libphobos/src/std/path.d
@@ -3959,7 +3959,7 @@ string expandTilde(string inputPath) @safe nothrow
     version (Posix)
     {
         import core.exception : onOutOfMemoryError;
-        import core.stdc.errno : errno, ERANGE;
+        import core.stdc.errno : errno, EBADF, ENOENT, EPERM, ERANGE, ESRCH;
         import core.stdc.stdlib : malloc, free, realloc;
 
         /*  Joins a path from a C string to the remainder of path.
@@ -4065,7 +4065,7 @@ string expandTilde(string inputPath) @safe nothrow
                 char[] extra_memory;
 
                 passwd result;
-                while (1)
+                loop: while (1)
                 {
                     extra_memory.length += extra_memory_size;
 
@@ -4088,10 +4088,23 @@ string expandTilde(string inputPath) @safe nothrow
                         break;
                     }
 
-                    if (errno != ERANGE &&
+                    switch (errno)
+                    {
+                        case ERANGE:
                         // On BSD and OSX, errno can be left at 0 instead of set to ERANGE
-                        errno != 0)
-                        onOutOfMemoryError();
+                        case 0:
+                            break;
+
+                        case ENOENT:
+                        case ESRCH:
+                        case EBADF:
+                        case EPERM:
+                            // The given name or uid was not found.
+                            break loop;
+
+                        default:
+                            onOutOfMemoryError();
+                    }
 
                     // extra_memory isn't large enough
                     import core.checkedint : mulu;
diff --git a/libphobos/src/std/random.d b/libphobos/src/std/random.d
index 106e51ceedb..c23eac9843e 100644
--- a/libphobos/src/std/random.d
+++ b/libphobos/src/std/random.d
@@ -2516,7 +2516,7 @@ if (!is(T == enum) && (isIntegral!T || isSomeChar!T))
     assert(rnd.uniform!ulong == 4838462006927449017);
 
     enum Fruit { apple, mango, pear }
-    version (X86_64) // https://issues.dlang.org/show_bug.cgi?id=15147
+    version (D_LP64) // https://issues.dlang.org/show_bug.cgi?id=15147
     assert(rnd.uniform!Fruit == Fruit.mango);
 }
 
@@ -2783,7 +2783,7 @@ auto ref choice(Range)(auto ref Range range)
     auto rnd = MinstdRand0(42);
 
     auto elem  = [1, 2, 3, 4, 5].choice(rnd);
-    version (X86_64) // https://issues.dlang.org/show_bug.cgi?id=15147
+    version (D_LP64) // https://issues.dlang.org/show_bug.cgi?id=15147
     assert(elem == 3);
 }
 
@@ -2865,7 +2865,7 @@ if (isRandomAccessRange!Range)
     auto rnd = MinstdRand0(42);
 
     auto arr = [1, 2, 3, 4, 5].randomShuffle(rnd);
-    version (X86_64) // https://issues.dlang.org/show_bug.cgi?id=15147
+    version (D_LP64) // https://issues.dlang.org/show_bug.cgi?id=15147
     assert(arr == [3, 5, 2, 4, 1]);
 }
 
@@ -2955,15 +2955,15 @@ if (isRandomAccessRange!Range)
     auto arr = [1, 2, 3, 4, 5, 6];
     arr = arr.dup.partialShuffle(1, rnd);
 
-    version (X86_64) // https://issues.dlang.org/show_bug.cgi?id=15147
+    version (D_LP64) // https://issues.dlang.org/show_bug.cgi?id=15147
     assert(arr == [2, 1, 3, 4, 5, 6]); // 1<->2
 
     arr = arr.dup.partialShuffle(2, rnd);
-    version (X86_64) // https://issues.dlang.org/show_bug.cgi?id=15147
+    version (D_LP64) // https://issues.dlang.org/show_bug.cgi?id=15147
     assert(arr == [1, 4, 3, 2, 5, 6]); // 1<->2, 2<->4
 
     arr = arr.dup.partialShuffle(3, rnd);
-    version (X86_64) // https://issues.dlang.org/show_bug.cgi?id=15147
+    version (D_LP64) // https://issues.dlang.org/show_bug.cgi?id=15147
     assert(arr == [5, 4, 6, 2, 1, 3]); // 1<->5, 2<->4, 3<->6
 }
 
@@ -3369,7 +3369,7 @@ if (isRandomAccessRange!Range)
     import std.range : iota;
     auto rnd = MinstdRand0(42);
 
-    version (X86_64) // https://issues.dlang.org/show_bug.cgi?id=15147
+    version (D_LP64) // https://issues.dlang.org/show_bug.cgi?id=15147
     assert(10.iota.randomCover(rnd).equal([7, 4, 2, 0, 1, 6, 8, 3, 9, 5]));
 }
 
diff --git a/libphobos/src/std/stdio.d b/libphobos/src/std/stdio.d
index 1bde73d628d..ca6f48c7c13 100644
--- a/libphobos/src/std/stdio.d
+++ b/libphobos/src/std/stdio.d
@@ -85,8 +85,7 @@ else version (CRuntime_Musl)
 }
 else version (CRuntime_UClibc)
 {
-    // uClibc supports GCC IO
-    version = GCC_IO;
+    version = GENERIC_IO;
 }
 else version (OSX)
 {
diff --git a/libsanitizer/ChangeLog b/libsanitizer/ChangeLog
index 3a9a5ce6b03..b86d1cdf58e 100644
--- a/libsanitizer/ChangeLog
+++ b/libsanitizer/ChangeLog
@@ -1,3 +1,12 @@
+2023-01-04  Florian Weimer  <fweimer@redhat.com>
+
+	Backported from master:
+	2022-10-18  Florian Weimer  <fweimer@redhat.com>
+
+	* configure.ac (sanitizer_supported): Include <unistd.h> for
+	syscall prototype.
+	* configure: Regenerate.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/libsanitizer/configure b/libsanitizer/configure
index 771b135573a..ae8c1bd7e83 100755
--- a/libsanitizer/configure
+++ b/libsanitizer/configure
@@ -16028,6 +16028,7 @@ case "$target" in
     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sys/syscall.h>
+#include <unistd.h>
 int
 main ()
 {
diff --git a/libsanitizer/configure.ac b/libsanitizer/configure.ac
index 7f1ef3979c4..ad49f29db7e 100644
--- a/libsanitizer/configure.ac
+++ b/libsanitizer/configure.ac
@@ -161,7 +161,8 @@ case "$target" in
   *-*-linux*)
     # Some old Linux distributions miss required syscalls.
     sanitizer_supported=no
-    AC_TRY_COMPILE([#include <sys/syscall.h>],[
+    AC_TRY_COMPILE([#include <sys/syscall.h>
+#include <unistd.h>],[
       syscall (__NR_gettid);
       syscall (__NR_futex);
       syscall (__NR_exit_group);
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 933d1b0809c..8399993fd50 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,324 @@
+2023-01-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-12-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105730
+	* src/c++11/compatibility-condvar.cc (__nothrow_wait_cv::wait):
+	Access private data member of base class and call its wait
+	member.
+
+2023-01-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106183
+	* include/bits/atomic_wait.h (__waiter_pool_base::_M_notify):
+	Move increment of _M_ver here.
+	[!_GLIBCXX_HAVE_PLATFORM_WAIT]: Lock mutex around increment.
+	Use relaxed memory order and always notify all waiters.
+	(__waiter_base::_M_do_wait) [!_GLIBCXX_HAVE_PLATFORM_WAIT]:
+	Check value again after locking mutex.
+	(__waiter_base::_M_notify): Remove increment of _M_ver.
+
+2023-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/108265
+	* include/std/chrono (hh_mm_ss): Do not use chrono::abs if
+	duration rep is unsigned. Remove incorrect noexcept-specifier.
+	* testsuite/std/time/hh_mm_ss/1.cc: Check unsigned rep. Check
+	floating-point representations. Check default construction.
+
+2022-12-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/107814
+	* testsuite/experimental/filesystem/iterators/error_reporting.cc:
+	Use a static buffer with space after it.
+
+2022-12-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-12-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/expected (expected::_M_swap_val_unex): Guard the
+	correct object.
+	(expected::swap): Move is_swappable
+	requirement from static_assert to constraint.
+	(swap): Likewise.
+	(operator==): Remove noexcept-specifier.
+	* testsuite/20_util/expected/swap.cc: Check swapping of
+	types without non-throwing move constructor. Check constraints
+	on swap.
+	* testsuite/20_util/expected/unexpected.cc: Check constraints on
+	swap.
+	* testsuite/20_util/expected/equality.cc: New test.
+
+2022-12-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-12-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/108097
+	* include/std/stacktrace (basic_stracktrace::_Impl): Do not
+	multiply N by sizeof(value_type) when allocating.
+
+2022-11-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-09-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/memory: Do not include <bits/stl_algobase.h>.
+
+2022-11-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/tuple/swap.cc (MoveOnly::operator==): Add
+	const qualifier.
+	* testsuite/26_numerics/valarray/87641.cc (X::operator==):
+	Likewise.
+
+2022-11-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/expected (expected::_M_invalid): Remove.
+
+2022-11-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/chrono.h (duration): Check preconditions on
+	template arguments before using them.
+
+2022-11-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-10-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_path.h (path::filename()): Fix dangling
+	reference.
+
+2022-11-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-09-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Document LWG 1203.
+	* doc/html/*: Regenerate.
+
+2022-11-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/barrier: Add missing runtime exception.
+
+2022-11-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_dir.h (directory_iterator): Add comparison
+	with std::default_sentinel_t. Remove redundant operator!= for
+	C++20.
+	* (recursive_directory_iterator): Likewise.
+	* include/bits/iterator_concepts.h [!__cpp_lib_concepts]
+	(default_sentinel_t, default_sentinel): Define even if concepts
+	are not supported.
+	* include/bits/regex.h (regex_iterator): Add comparison with
+	std::default_sentinel_t. Remove redundant operator!= for C++20.
+	(regex_token_iterator): Likewise.
+	(regex_token_iterator::_M_end_of_seq()): Add noexcept.
+	* testsuite/27_io/filesystem/iterators/lwg3719.cc: New test.
+	* testsuite/28_regex/iterators/regex_iterator/lwg3719.cc:
+	New test.
+	* testsuite/28_regex/iterators/regex_token_iterator/lwg3719.cc:
+	New test.
+
+2022-11-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-09-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91456
+	* include/std/type_traits (__is_nothrow_invocable): Remove.
+	(__is_invocable_impl::__nothrow_type): New member type which
+	checks if the conversion can throw.
+	(__is_nt_invocable_impl): Replace class template with alias
+	template to __is_nt_invocable_impl::__nothrow_type.
+	* testsuite/20_util/is_nothrow_invocable/91456.cc: New test.
+	* testsuite/20_util/is_nothrow_convertible/value.cc: Remove
+	macro used by value_ext.cc test.
+	* testsuite/20_util/is_nothrow_convertible/value_ext.cc: Remove
+	test for non-standard __is_nothrow_invocable trait.
+
+2022-11-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106201
+	* include/bits/fs_path.h (filesystem::swap(path&, path&)):
+	Replace with abbreviated function template.
+	* include/experimental/bits/fs_path.h (filesystem::swap):
+	Likewise.
+	* testsuite/27_io/filesystem/iterators/106201.cc: New test.
+	* testsuite/experimental/filesystem/iterators/106201.cc: New test.
+
+2022-11-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/107801
+	* src/c++17/memory_resource.cc (pool_sizes): Disable large pools
+	for targets with 16-bit int.
+
+2022-11-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/mofunc_impl.h (move_only_function::__param_t):
+	Use __is_scalar instead of is_trivially_copyable.
+	* testsuite/20_util/move_only_function/call.cc: Check parameters
+	involving incomplete types.
+
+2022-11-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/95048
+	* include/bits/fs_path.h (path::_Codecvt): New class template
+	that selects the kind of code conversion done.
+	(path::_Codecvt<wchar_t>): Select based on sizeof(wchar_t).
+	(_GLIBCXX_CONV_FROM_UTF8): New macro to allow the same code to
+	be used for Windows and POSIX.
+	(path::_S_convert(const EcharT*, const EcharT*)): Simplify by
+	using _Codecvt and _GLIBCXX_CONV_FROM_UTF8 abstractions.
+	(path::_S_str_convert(basic_string_view<value_type>, const A&)):
+	Simplify nested conditions.
+	* include/experimental/bits/fs_path.h (path::_Cvt): Define
+	nested typedef controlling type of code conversion done.
+	(path::_Cvt::_S_wconvert): Use new typedef.
+	(path::string(const A&)): Likewise.
+	* testsuite/27_io/filesystem/path/construct/95048.cc: New test.
+	* testsuite/experimental/filesystem/path/construct/95048.cc: New
+	test.
+
+2022-11-14  Nathaniel Shead  <nathanieloshead@gmail.com>
+
+	Backported from master:
+	2022-11-11  Nathaniel Shead  <nathanieloshead@gmail.com>
+
+	PR libstdc++/103295
+	* include/bits/basic_string.h (_M_use_local_data): Set active
+	member to _M_local_buf.
+
+2022-11-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/authors.xml: Remove empty author element.
+	* doc/xml/manual/spine.xml: Likewise.
+	* doc/html/manual/index.html: Regenerate.
+
+2022-10-19  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-06-22  Alexandre Oliva  <oliva@adacore.com>
+
+	* libsupc++/eh_globals.cc [!_GLIBCXX_HAVE_TLS]
+	(__eh_globals_init::~__eh_globals_init): Clear _S_init first.
+
+2022-09-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-09-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/evolution.xml: Document std::bind API
+	changes.
+	* doc/xml/manual/intro.xml: Document LWG 2487 status.
+	* doc/xml/manual/using.xml: Clarify default value of
+	_GLIBCXX_USE_DEPRECATED.
+	* doc/html/*: Regenerate.
+	* include/std/functional (_Bind::operator()(Args&&...) volatile)
+	(_Bind::operator()(Args&&...) const volatile)
+	(_Bind_result::operator()(Args&&...) volatile)
+	(_Bind_result::operator()(Args&&...) const volatile): Replace
+	with deleted overload for C++20 and later.
+	* testsuite/20_util/bind/cv_quals.cc: Check for deprecated
+	warnings in C++17.
+	* testsuite/20_util/bind/cv_quals_2.cc: Likewise, and check for
+	ill-formed in C++20.
+
+2022-09-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/abi.xml: Document GLIBCXX_3.4.30 version.
+	* doc/html/manual/abi.html: Regenerate.
+
+2022-09-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-09-12  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/106320
+	* testsuite/std/ranges/adaptors/join.cc (test13): New test.
+
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106695
+	* include/bits/std_thread.h (thread::_State_impl): Forward
+	individual arguments to _Invoker constructor.
+	(thread::_Invoker): Add constructor. Delete copies.
+	* include/std/future (__future_base::_Deferred_state): Forward
+	individual arguments to _Invoker constructor.
+	(__future_base::_Async_state_impl): Likewise.
+	* testsuite/30_threads/async/106695.cc: New test.
+	* testsuite/30_threads/thread/106695.cc: New test.
+
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106607
+	* include/bits/regex_compiler.tcc (_Compiler::_M_cur_int_value):
+	Use built-ins to check for integer overflow in back-reference
+	number.
+	* testsuite/28_regex/basic_regex/106607.cc: New test.
+
+2022-08-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106589
+	* include/std/variant (__do_visit): Handle is_void<R> for zero
+	argument case.
+	* testsuite/20_util/variant/visit_r.cc: Check std::visit<void>(v).
+
+2022-08-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105678
+	* doc/xml/manual/using.xml: Document -lstdc++_libbacktrace
+	requirement for using std::stacktrace. Also adjust -frtti and
+	-fexceptions to document non-default (i.e. negative) forms.
+	* doc/html/*: Regenerate.
+
 2022-08-19  Release Manager
 
 	* GCC 12.2.0 released.
diff --git a/libstdc++-v3/doc/html/bk02.html b/libstdc++-v3/doc/html/bk02.html
index 7c47759f223..182c94b59a6 100644
--- a/libstdc++-v3/doc/html/bk02.html
+++ b/libstdc++-v3/doc/html/bk02.html
@@ -1,2 +1,2 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library" /><link rel="prev" href="manual/backwards.html" title="Backwards Compatibility" /><link rel="next" href="api.html" title="The GNU C++ Library API Reference" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="manual/backwards.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="api.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="article"><a href="api.html">The GNU C++ Library API Reference</a></span></dt></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="manual/backwards.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="api.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Backwards Compatibility </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> The GNU C++ Library API Reference</td></tr></table></div></body></html>
\ No newline at end of file
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library" /><link rel="prev" href="manual/appendix_gfdl.html" title="Appendix E. GNU Free Documentation License" /><link rel="next" href="api.html" title="The GNU C++ Library API Reference" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="manual/appendix_gfdl.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="api.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="article"><a href="api.html">The GNU C++ Library API Reference</a></span></dt></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="manual/appendix_gfdl.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="api.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Appendix E. GNU Free Documentation License </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> The GNU C++ Library API Reference</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/index.html b/libstdc++-v3/doc/html/index.html
index 5cc9226f4a1..1e0cecbcc4f 100644
--- a/libstdc++-v3/doc/html/index.html
+++ b/libstdc++-v3/doc/html/index.html
@@ -142,7 +142,7 @@
     Existing tests
 </a></span></dt><dt><span class="section"><a href="manual/test.html#test.exception.safety.containers">
 C++11 Requirements Test Sequence Descriptions
-</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="manual/abi.html">ABI Policy and Guidelines</a></span></dt><dd><dl><dt><span class="section"><a href="manual/abi.html#abi.cxx_interface">The C++ Interface</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.versioning">Versioning</a></span></dt><dd><dl><dt><span class="section"><a href="manual/abi.html#abi.versioning.goals">Goals</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.versioning.history">History</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.versioning.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.versioning.config">Configuring</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.versioning.active">Checking Active</a></span></dt></dl></dd><dt><span class="section"><a href="manual/abi.html#abi.changes_allowed">Allowed Changes</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.changes_no">Prohibited Changes</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.impl">Implementation</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.testing">Testing</a></span></dt><dd><dl><dt><span class="section"><a href="manual/abi.html#abi.testing.single">Single ABI Testing</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.testing.multi">Multiple ABI Testing</a></span></dt></dl></dd><dt><span class="section"><a href="manual/abi.html#abi.issues">Outstanding Issues</a></span></dt></dl></dd><dt><span class="section"><a href="manual/api.html">API Evolution and Deprecation History</a></span></dt><dd><dl><dt><span class="section"><a href="manual/api.html#api.rel_300"><code class="constant">3.0</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_310"><code class="constant">3.1</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_320"><code class="constant">3.2</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_330"><code class="constant">3.3</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_340"><code class="constant">3.4</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_400"><code class="constant">4.0</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_410"><code class="constant">4.1</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_420"><code class="constant">4.2</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_430"><code class="constant">4.3</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_440"><code class="constant">4.4</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_450"><code class="constant">4.5</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_460"><code class="constant">4.6</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_470"><code class="constant">4.7</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_480"><code class="constant">4.8</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_490"><code class="constant">4.9</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_51"><code class="constant">5</code></a></span></dt><dd><dl><dt><span class="section"><a href="manual/api.html#api.rel_53"><code class="constant">5.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="manual/api.html#api.rel_61"><code class="constant">6</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_71"><code class="constant">7</code></a></span></dt><dd><dl><dt><span class="section"><a href="manual/api.html#api.rel_72"><code class="constant">7.2</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_73"><code class="constant">7.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="manual/api.html#api.rel_81"><code class="constant">8</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_91"><code class="constant">9</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_101"><code class="constant">10</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_111"><code class="constant">11</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_121"><code class="constant">12</code></a></span></dt></dl></dd><dt><span class="section"><a href="manual/backwards.html">Backwards Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/backwards.html#backwards.first">First</a></span></dt><dt><span class="section"><a href="manual/backwards.html#backwards.second">Second</a></span></dt><dt><span class="section"><a href="manual/backwards.html#backwards.third">Third</a></span></dt><dd><dl><dt><span class="section"><a href="manual/backwards.html#backwards.third.headers">Pre-ISO headers removed</a></span></dt><dt><span class="section"><a href="manual/backwards.html#backwards.third.hash">Extension headers hash_map, hash_set moved to ext or backwards</a></span></dt><dt><span class="section"><a href="manual/backwards.html#backwards.third.nocreate_noreplace">No <code class="code">ios::nocreate/ios::noreplace</code>.
+</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="manual/abi.html">ABI Policy and Guidelines</a></span></dt><dd><dl><dt><span class="section"><a href="manual/abi.html#abi.cxx_interface">The C++ Interface</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.versioning">Versioning</a></span></dt><dd><dl><dt><span class="section"><a href="manual/abi.html#abi.versioning.goals">Goals</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.versioning.history">History</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.versioning.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.versioning.config">Configuring</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.versioning.active">Checking Active</a></span></dt></dl></dd><dt><span class="section"><a href="manual/abi.html#abi.changes_allowed">Allowed Changes</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.changes_no">Prohibited Changes</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.impl">Implementation</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.testing">Testing</a></span></dt><dd><dl><dt><span class="section"><a href="manual/abi.html#abi.testing.single">Single ABI Testing</a></span></dt><dt><span class="section"><a href="manual/abi.html#abi.testing.multi">Multiple ABI Testing</a></span></dt></dl></dd><dt><span class="section"><a href="manual/abi.html#abi.issues">Outstanding Issues</a></span></dt></dl></dd><dt><span class="section"><a href="manual/api.html">API Evolution and Deprecation History</a></span></dt><dd><dl><dt><span class="section"><a href="manual/api.html#api.rel_300"><code class="constant">3.0</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_310"><code class="constant">3.1</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_320"><code class="constant">3.2</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_330"><code class="constant">3.3</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_340"><code class="constant">3.4</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_400"><code class="constant">4.0</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_410"><code class="constant">4.1</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_420"><code class="constant">4.2</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_430"><code class="constant">4.3</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_440"><code class="constant">4.4</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_450"><code class="constant">4.5</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_460"><code class="constant">4.6</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_470"><code class="constant">4.7</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_480"><code class="constant">4.8</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_490"><code class="constant">4.9</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_51"><code class="constant">5</code></a></span></dt><dd><dl><dt><span class="section"><a href="manual/api.html#api.rel_53"><code class="constant">5.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="manual/api.html#api.rel_61"><code class="constant">6</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_71"><code class="constant">7</code></a></span></dt><dd><dl><dt><span class="section"><a href="manual/api.html#api.rel_72"><code class="constant">7.2</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_73"><code class="constant">7.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="manual/api.html#api.rel_81"><code class="constant">8</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_91"><code class="constant">9</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_101"><code class="constant">10</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_111"><code class="constant">11</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_121"><code class="constant">12</code></a></span></dt><dt><span class="section"><a href="manual/api.html#api.rel_123"><code class="constant">12.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="manual/backwards.html">Backwards Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/backwards.html#backwards.first">First</a></span></dt><dt><span class="section"><a href="manual/backwards.html#backwards.second">Second</a></span></dt><dt><span class="section"><a href="manual/backwards.html#backwards.third">Third</a></span></dt><dd><dl><dt><span class="section"><a href="manual/backwards.html#backwards.third.headers">Pre-ISO headers removed</a></span></dt><dt><span class="section"><a href="manual/backwards.html#backwards.third.hash">Extension headers hash_map, hash_set moved to ext or backwards</a></span></dt><dt><span class="section"><a href="manual/backwards.html#backwards.third.nocreate_noreplace">No <code class="code">ios::nocreate/ios::noreplace</code>.
 </a></span></dt><dt><span class="section"><a href="manual/backwards.html#backwards.third.streamattach">
 No <code class="code">stream::attach(int fd)</code>
 </a></span></dt><dt><span class="section"><a href="manual/backwards.html#backwards.third.support_cxx98">
diff --git a/libstdc++-v3/doc/html/manual/abi.html b/libstdc++-v3/doc/html/manual/abi.html
index 82b03fd4fbb..c5ca94ac9f5 100644
--- a/libstdc++-v3/doc/html/manual/abi.html
+++ b/libstdc++-v3/doc/html/manual/abi.html
@@ -128,7 +128,7 @@ compatible.
    GLIBCPP_3.2 for symbols that were introduced in the GCC 3.2.0
    release.) If a particular release is not listed, it has the same
    version labels as the preceding release.
-   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GCC 3.0.0: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.1: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.2: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.3: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.4: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.1.0: GLIBCPP_3.1, CXXABI_1</p></li><li class="listitem"><p>GCC 3.1.1: GLIBCPP_3.1, CXXABI_1</p></li><li class="listitem"><p>GCC 3.2.0: GLIBCPP_3.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.1: GLIBCPP_3.2.1, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.2: GLIBCPP_3.2.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.3: GLIBCPP_3.2.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.3.0: GLIBCPP_3.2.2, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.1: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.2: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.3: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.4.0: GLIBCXX_3.4, CXXABI_1.3</p></li><li class="listitem"><p>GCC 3.4.1: GLIBCXX_3.4.1, CXXABI_1.3</p></li><li class="listitem"><p>GCC 3.4.2: GLIBCXX_3.4.2</p></li><li class="listitem"><p>GCC 3.4.3: GLIBCXX_3.4.3</p></li><li class="listitem"><p>GCC 4.0.0: GLIBCXX_3.4.4, CXXABI_1.3.1</p></li><li class="listitem"><p>GCC 4.0.1: GLIBCXX_3.4.5</p></li><li class="listitem"><p>GCC 4.0.2: GLIBCXX_3.4.6</p></li><li class="listitem"><p>GCC 4.0.3: GLIBCXX_3.4.7</p></li><li class="listitem"><p>GCC 4.1.1: GLIBCXX_3.4.8</p></li><li class="listitem"><p>GCC 4.2.0: GLIBCXX_3.4.9</p></li><li class="listitem"><p>GCC 4.3.0: GLIBCXX_3.4.10, CXXABI_1.3.2</p></li><li class="listitem"><p>GCC 4.4.0: GLIBCXX_3.4.11, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.4.1: GLIBCXX_3.4.12, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.4.2: GLIBCXX_3.4.13, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.5.0: GLIBCXX_3.4.14, CXXABI_1.3.4</p></li><li class="listitem"><p>GCC 4.6.0: GLIBCXX_3.4.15, CXXABI_1.3.5</p></li><li class="listitem"><p>GCC 4.6.1: GLIBCXX_3.4.16, CXXABI_1.3.5</p></li><li class="listitem"><p>GCC 4.7.0: GLIBCXX_3.4.17, CXXABI_1.3.6</p></li><li class="listitem"><p>GCC 4.8.0: GLIBCXX_3.4.18, CXXABI_1.3.7</p></li><li class="listitem"><p>GCC 4.8.3: GLIBCXX_3.4.19, CXXABI_1.3.7</p></li><li class="listitem"><p>GCC 4.9.0: GLIBCXX_3.4.20, CXXABI_1.3.8</p></li><li class="listitem"><p>GCC 5.1.0: GLIBCXX_3.4.21, CXXABI_1.3.9</p></li><li class="listitem"><p>GCC 6.1.0: GLIBCXX_3.4.22, CXXABI_1.3.10</p></li><li class="listitem"><p>GCC 7.1.0: GLIBCXX_3.4.23, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 7.2.0: GLIBCXX_3.4.24, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 8.1.0: GLIBCXX_3.4.25, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 9.1.0: GLIBCXX_3.4.26, CXXABI_1.3.12</p></li><li class="listitem"><p>GCC 9.2.0: GLIBCXX_3.4.27, CXXABI_1.3.12</p></li><li class="listitem"><p>GCC 9.3.0: GLIBCXX_3.4.28, CXXABI_1.3.12</p></li><li class="listitem"><p>GCC 10.1.0: GLIBCXX_3.4.28, CXXABI_1.3.12</p></li><li class="listitem"><p>GCC 11.1.0: GLIBCXX_3.4.29, CXXABI_1.3.13</p></li></ul></div></li><li class="listitem"><p>Incremental bumping of a compiler pre-defined macro,
+   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GCC 3.0.0: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.1: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.2: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.3: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.0.4: (Error, not versioned)</p></li><li class="listitem"><p>GCC 3.1.0: GLIBCPP_3.1, CXXABI_1</p></li><li class="listitem"><p>GCC 3.1.1: GLIBCPP_3.1, CXXABI_1</p></li><li class="listitem"><p>GCC 3.2.0: GLIBCPP_3.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.1: GLIBCPP_3.2.1, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.2: GLIBCPP_3.2.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.2.3: GLIBCPP_3.2.2, CXXABI_1.2</p></li><li class="listitem"><p>GCC 3.3.0: GLIBCPP_3.2.2, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.1: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.2: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.3.3: GLIBCPP_3.2.3, CXXABI_1.2.1</p></li><li class="listitem"><p>GCC 3.4.0: GLIBCXX_3.4, CXXABI_1.3</p></li><li class="listitem"><p>GCC 3.4.1: GLIBCXX_3.4.1, CXXABI_1.3</p></li><li class="listitem"><p>GCC 3.4.2: GLIBCXX_3.4.2</p></li><li class="listitem"><p>GCC 3.4.3: GLIBCXX_3.4.3</p></li><li class="listitem"><p>GCC 4.0.0: GLIBCXX_3.4.4, CXXABI_1.3.1</p></li><li class="listitem"><p>GCC 4.0.1: GLIBCXX_3.4.5</p></li><li class="listitem"><p>GCC 4.0.2: GLIBCXX_3.4.6</p></li><li class="listitem"><p>GCC 4.0.3: GLIBCXX_3.4.7</p></li><li class="listitem"><p>GCC 4.1.1: GLIBCXX_3.4.8</p></li><li class="listitem"><p>GCC 4.2.0: GLIBCXX_3.4.9</p></li><li class="listitem"><p>GCC 4.3.0: GLIBCXX_3.4.10, CXXABI_1.3.2</p></li><li class="listitem"><p>GCC 4.4.0: GLIBCXX_3.4.11, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.4.1: GLIBCXX_3.4.12, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.4.2: GLIBCXX_3.4.13, CXXABI_1.3.3</p></li><li class="listitem"><p>GCC 4.5.0: GLIBCXX_3.4.14, CXXABI_1.3.4</p></li><li class="listitem"><p>GCC 4.6.0: GLIBCXX_3.4.15, CXXABI_1.3.5</p></li><li class="listitem"><p>GCC 4.6.1: GLIBCXX_3.4.16, CXXABI_1.3.5</p></li><li class="listitem"><p>GCC 4.7.0: GLIBCXX_3.4.17, CXXABI_1.3.6</p></li><li class="listitem"><p>GCC 4.8.0: GLIBCXX_3.4.18, CXXABI_1.3.7</p></li><li class="listitem"><p>GCC 4.8.3: GLIBCXX_3.4.19, CXXABI_1.3.7</p></li><li class="listitem"><p>GCC 4.9.0: GLIBCXX_3.4.20, CXXABI_1.3.8</p></li><li class="listitem"><p>GCC 5.1.0: GLIBCXX_3.4.21, CXXABI_1.3.9</p></li><li class="listitem"><p>GCC 6.1.0: GLIBCXX_3.4.22, CXXABI_1.3.10</p></li><li class="listitem"><p>GCC 7.1.0: GLIBCXX_3.4.23, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 7.2.0: GLIBCXX_3.4.24, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 8.1.0: GLIBCXX_3.4.25, CXXABI_1.3.11</p></li><li class="listitem"><p>GCC 9.1.0: GLIBCXX_3.4.26, CXXABI_1.3.12</p></li><li class="listitem"><p>GCC 9.2.0: GLIBCXX_3.4.27, CXXABI_1.3.12</p></li><li class="listitem"><p>GCC 9.3.0: GLIBCXX_3.4.28, CXXABI_1.3.12</p></li><li class="listitem"><p>GCC 10.1.0: GLIBCXX_3.4.28, CXXABI_1.3.12</p></li><li class="listitem"><p>GCC 11.1.0: GLIBCXX_3.4.29, CXXABI_1.3.13</p></li><li class="listitem"><p>GCC 12.1.0: GLIBCXX_3.4.30, CXXABI_1.3.13</p></li></ul></div></li><li class="listitem"><p>Incremental bumping of a compiler pre-defined macro,
     __GXX_ABI_VERSION. This macro is defined as the version of the
     compiler v3 ABI, with g++ 3.0 being version 100. This macro will
     be automatically defined whenever g++ is used (the curious can
diff --git a/libstdc++-v3/doc/html/manual/api.html b/libstdc++-v3/doc/html/manual/api.html
index bbda6f5acf3..604380e0136 100644
--- a/libstdc++-v3/doc/html/manual/api.html
+++ b/libstdc++-v3/doc/html/manual/api.html
@@ -316,6 +316,8 @@ now defaults to zero.
   <code class="classname">has_trivial_default_constructor</code>,
   <code class="classname">has_trivial_copy_constructor</code> and
   <code class="classname">has_trivial_copy_assign</code> removed.
+</p><p>
+Calling a <code class="code">std::bind</code> result as volatile was deprecated for C++17.
 </p><p> Profile Mode was deprecated. </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="api.rel_72"></a><code class="constant">7.2</code></h4></div></div></div><p>
   Library Fundamentals TS header
   <code class="filename">&lt;experimental/source_location&gt;</code>
@@ -468,4 +470,7 @@ they both derive from <code class="classname">std::__new_allocator</code> instea
 <code class="code">noexcept(false)</code> to allow thread cancellation exceptions to
 be thrown from <code class="function">pthread_cond_wait</code> without aborting
 the process.
+</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="api.rel_123"></a><code class="constant">12.3</code></h3></div></div></div><p>
+Calling a <code class="code">std::bind</code> result as volatile is ill-formed for C++20
+and later.
 </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="abi.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="appendix_porting.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="backwards.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">ABI Policy and Guidelines </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Backwards Compatibility</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/appendix.html b/libstdc++-v3/doc/html/manual/appendix.html
index bd462e9dddd..c563372e441 100644
--- a/libstdc++-v3/doc/html/manual/appendix.html
+++ b/libstdc++-v3/doc/html/manual/appendix.html
@@ -16,7 +16,7 @@
     Existing tests
 </a></span></dt><dt><span class="section"><a href="test.html#test.exception.safety.containers">
 C++11 Requirements Test Sequence Descriptions
-</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="abi.html">ABI Policy and Guidelines</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.cxx_interface">The C++ Interface</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning">Versioning</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.versioning.goals">Goals</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.history">History</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.config">Configuring</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.active">Checking Active</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.changes_allowed">Allowed Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.changes_no">Prohibited Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.impl">Implementation</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing">Testing</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.testing.single">Single ABI Testing</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing.multi">Multiple ABI Testing</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.issues">Outstanding Issues</a></span></dt></dl></dd><dt><span class="section"><a href="api.html">API Evolution and Deprecation History</a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_300"><code class="constant">3.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_310"><code class="constant">3.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_320"><code class="constant">3.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_330"><code class="constant">3.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_340"><code class="constant">3.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_400"><code class="constant">4.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_410"><code class="constant">4.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_420"><code class="constant">4.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_430"><code class="constant">4.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_440"><code class="constant">4.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_450"><code class="constant">4.5</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_460"><code class="constant">4.6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_470"><code class="constant">4.7</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_480"><code class="constant">4.8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_490"><code class="constant">4.9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_51"><code class="constant">5</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_53"><code class="constant">5.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_61"><code class="constant">6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_71"><code class="constant">7</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_72"><code class="constant">7.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_73"><code class="constant">7.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_81"><code class="constant">8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_91"><code class="constant">9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_101"><code class="constant">10</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_111"><code class="constant">11</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_121"><code class="constant">12</code></a></span></dt></dl></dd><dt><span class="section"><a href="backwards.html">Backwards Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.first">First</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.second">Second</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third">Third</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.third.headers">Pre-ISO headers removed</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.hash">Extension headers hash_map, hash_set moved to ext or backwards</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.nocreate_noreplace">No <code class="code">ios::nocreate/ios::noreplace</code>.
+</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="abi.html">ABI Policy and Guidelines</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.cxx_interface">The C++ Interface</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning">Versioning</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.versioning.goals">Goals</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.history">History</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.config">Configuring</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.active">Checking Active</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.changes_allowed">Allowed Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.changes_no">Prohibited Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.impl">Implementation</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing">Testing</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.testing.single">Single ABI Testing</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing.multi">Multiple ABI Testing</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.issues">Outstanding Issues</a></span></dt></dl></dd><dt><span class="section"><a href="api.html">API Evolution and Deprecation History</a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_300"><code class="constant">3.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_310"><code class="constant">3.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_320"><code class="constant">3.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_330"><code class="constant">3.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_340"><code class="constant">3.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_400"><code class="constant">4.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_410"><code class="constant">4.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_420"><code class="constant">4.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_430"><code class="constant">4.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_440"><code class="constant">4.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_450"><code class="constant">4.5</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_460"><code class="constant">4.6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_470"><code class="constant">4.7</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_480"><code class="constant">4.8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_490"><code class="constant">4.9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_51"><code class="constant">5</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_53"><code class="constant">5.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_61"><code class="constant">6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_71"><code class="constant">7</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_72"><code class="constant">7.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_73"><code class="constant">7.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_81"><code class="constant">8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_91"><code class="constant">9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_101"><code class="constant">10</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_111"><code class="constant">11</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_121"><code class="constant">12</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_123"><code class="constant">12.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="backwards.html">Backwards Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.first">First</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.second">Second</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third">Third</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.third.headers">Pre-ISO headers removed</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.hash">Extension headers hash_map, hash_set moved to ext or backwards</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.nocreate_noreplace">No <code class="code">ios::nocreate/ios::noreplace</code>.
 </a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.streamattach">
 No <code class="code">stream::attach(int fd)</code>
 </a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.support_cxx98">
diff --git a/libstdc++-v3/doc/html/manual/appendix_porting.html b/libstdc++-v3/doc/html/manual/appendix_porting.html
index 3d7fb564f4b..55d3f2318dd 100644
--- a/libstdc++-v3/doc/html/manual/appendix_porting.html
+++ b/libstdc++-v3/doc/html/manual/appendix_porting.html
@@ -14,7 +14,7 @@
     Existing tests
 </a></span></dt><dt><span class="section"><a href="test.html#test.exception.safety.containers">
 C++11 Requirements Test Sequence Descriptions
-</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="abi.html">ABI Policy and Guidelines</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.cxx_interface">The C++ Interface</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning">Versioning</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.versioning.goals">Goals</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.history">History</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.config">Configuring</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.active">Checking Active</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.changes_allowed">Allowed Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.changes_no">Prohibited Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.impl">Implementation</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing">Testing</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.testing.single">Single ABI Testing</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing.multi">Multiple ABI Testing</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.issues">Outstanding Issues</a></span></dt></dl></dd><dt><span class="section"><a href="api.html">API Evolution and Deprecation History</a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_300"><code class="constant">3.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_310"><code class="constant">3.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_320"><code class="constant">3.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_330"><code class="constant">3.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_340"><code class="constant">3.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_400"><code class="constant">4.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_410"><code class="constant">4.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_420"><code class="constant">4.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_430"><code class="constant">4.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_440"><code class="constant">4.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_450"><code class="constant">4.5</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_460"><code class="constant">4.6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_470"><code class="constant">4.7</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_480"><code class="constant">4.8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_490"><code class="constant">4.9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_51"><code class="constant">5</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_53"><code class="constant">5.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_61"><code class="constant">6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_71"><code class="constant">7</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_72"><code class="constant">7.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_73"><code class="constant">7.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_81"><code class="constant">8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_91"><code class="constant">9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_101"><code class="constant">10</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_111"><code class="constant">11</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_121"><code class="constant">12</code></a></span></dt></dl></dd><dt><span class="section"><a href="backwards.html">Backwards Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.first">First</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.second">Second</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third">Third</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.third.headers">Pre-ISO headers removed</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.hash">Extension headers hash_map, hash_set moved to ext or backwards</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.nocreate_noreplace">No <code class="code">ios::nocreate/ios::noreplace</code>.
+</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="abi.html">ABI Policy and Guidelines</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.cxx_interface">The C++ Interface</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning">Versioning</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.versioning.goals">Goals</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.history">History</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.config">Configuring</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.active">Checking Active</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.changes_allowed">Allowed Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.changes_no">Prohibited Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.impl">Implementation</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing">Testing</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.testing.single">Single ABI Testing</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing.multi">Multiple ABI Testing</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.issues">Outstanding Issues</a></span></dt></dl></dd><dt><span class="section"><a href="api.html">API Evolution and Deprecation History</a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_300"><code class="constant">3.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_310"><code class="constant">3.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_320"><code class="constant">3.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_330"><code class="constant">3.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_340"><code class="constant">3.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_400"><code class="constant">4.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_410"><code class="constant">4.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_420"><code class="constant">4.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_430"><code class="constant">4.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_440"><code class="constant">4.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_450"><code class="constant">4.5</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_460"><code class="constant">4.6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_470"><code class="constant">4.7</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_480"><code class="constant">4.8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_490"><code class="constant">4.9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_51"><code class="constant">5</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_53"><code class="constant">5.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_61"><code class="constant">6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_71"><code class="constant">7</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_72"><code class="constant">7.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_73"><code class="constant">7.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_81"><code class="constant">8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_91"><code class="constant">9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_101"><code class="constant">10</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_111"><code class="constant">11</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_121"><code class="constant">12</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_123"><code class="constant">12.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="backwards.html">Backwards Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.first">First</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.second">Second</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third">Third</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.third.headers">Pre-ISO headers removed</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.hash">Extension headers hash_map, hash_set moved to ext or backwards</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.nocreate_noreplace">No <code class="code">ios::nocreate/ios::noreplace</code>.
 </a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.streamattach">
 No <code class="code">stream::attach(int fd)</code>
 </a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.support_cxx98">
diff --git a/libstdc++-v3/doc/html/manual/bugs.html b/libstdc++-v3/doc/html/manual/bugs.html
index 38594a9b75a..8e0bc1f9801 100644
--- a/libstdc++-v3/doc/html/manual/bugs.html
+++ b/libstdc++-v3/doc/html/manual/bugs.html
@@ -357,6 +357,9 @@
 	<span class="emphasis"><em>More algorithms that throw away information</em></span>
     </span></dt><dd><p>The traditional HP / SGI return type and value is blessed
 		    by the resolution of the DR.
+    </p></dd><dt><a id="manual.bugs.dr1203"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1203" target="_top">1203</a>:
+       <span class="emphasis"><em>More useful rvalue stream insertion</em></span>
+    </span></dt><dd><p>Return the stream as its original type, not the base class.
     </p></dd><dt><a id="manual.bugs.dr1339"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1339" target="_top">1339</a>:
        <span class="emphasis"><em>uninitialized_fill_n should return the end of its range</em></span>
     </span></dt><dd><p>Return the end of the filled range.
@@ -521,6 +524,12 @@
        </em></span>
     </span></dt><dd><p>Avoid using <code class="code">dynamic_cast</code> when it would be
     ill-formed.
+    </p></dd><dt><a id="manual.bugs.dr2487"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2487" target="_top">2487</a>:
+       <span class="emphasis"><em><code class="code">bind()</code> should be <code class="code">const</code>-overloaded
+      not cv-overloaded
+       </em></span>
+    </span></dt><dd><p>Deprecate volatile-qualified <code class="code">operator()</code>
+    for C++17, make it ill-formed for C++20.
     </p></dd><dt><a id="manual.bugs.dr2499"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2499" target="_top">2499</a>:
        <span class="emphasis"><em><code class="code">operator&gt;&gt;(basic_istream&amp;, CharT*)</code> makes it hard to avoid buffer overflows
        </em></span>
diff --git a/libstdc++-v3/doc/html/manual/extensions.html b/libstdc++-v3/doc/html/manual/extensions.html
index 82bf42e54b0..1b13d711714 100644
--- a/libstdc++-v3/doc/html/manual/extensions.html
+++ b/libstdc++-v3/doc/html/manual/extensions.html
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Part III.  Extensions</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library Manual" /><link rel="prev" href="io_and_c.html" title="Interacting with C" /><link rel="next" href="ext_preface.html" title="" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Part III. 
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Part III.  Extensions</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library Manual" /><link rel="prev" href="concurrency.html" title="Chapter 15.  Concurrency" /><link rel="next" href="ext_preface.html" title="" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Part III. 
   Extensions
   
-</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="io_and_c.html">Prev</a> </td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"> <a accesskey="n" href="ext_preface.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.ext"></a>Part III. 
+</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="concurrency.html">Prev</a> </td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"> <a accesskey="n" href="ext_preface.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.ext"></a>Part III. 
   Extensions
   <a id="id-1.3.5.1.1.1" class="indexterm"></a>
 </h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="preface"><a href="ext_preface.html"></a></span></dt><dt><span class="chapter"><a href="ext_compile_checks.html">16. Compile Time Checks</a></span></dt><dt><span class="chapter"><a href="debug_mode.html">17. Debug Mode</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode.html#manual.ext.debug_mode.intro">Intro</a></span></dt><dt><span class="section"><a href="debug_mode_semantics.html">Semantics</a></span></dt><dt><span class="section"><a href="debug_mode_using.html">Using</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_using.html#debug_mode.using.mode">Using the Debug Mode</a></span></dt><dt><span class="section"><a href="debug_mode_using.html#debug_mode.using.specific">Using a Specific Debug Container</a></span></dt></dl></dd><dt><span class="section"><a href="debug_mode_design.html">Design</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.goals">Goals</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods">Methods</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.wrappers">The Wrapper Model</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.safe_iter">Safe Iterators</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.safe_seq">Safe Sequences (Containers)</a></span></dt></dl></dd><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.precond">Precondition Checking</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.coexistence">Release- and debug-mode coexistence</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#methods.coexistence.compile">Compile-time coexistence of release- and debug-mode components</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#methods.coexistence.link">Link- and run-time coexistence of release- and
@@ -68,4 +68,7 @@
 	  Text <code class="function">modify</code> Up
 	</a></span></dt><dt><span class="section"><a href="policy_based_data_structures_test.html#performance.priority_queue.text_modify_down">
 	  Text <code class="function">modify</code> Down
-	</a></span></dt></dl></dd><dt><span class="section"><a href="policy_based_data_structures_test.html#pbds.test.performance.observations">Observations</a></span></dt><dd><dl><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.associative">Associative</a></span></dt><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.priority_queue">Priority_Queue</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="policy_data_structures_ack.html">Acknowledgments</a></span></dt><dt><span class="bibliography"><a href="policy_data_structures.html#pbds.biblio">Bibliography</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_containers.html">22. HP/SGI Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="ext_containers.html#manual.ext.containers.sgi">Backwards Compatibility</a></span></dt><dt><span class="section"><a href="ext_sgi.html">Deprecated</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_utilities.html">23. Utilities</a></span></dt><dt><span class="chapter"><a href="ext_algorithms.html">24. Algorithms</a></span></dt><dt><span class="chapter"><a href="ext_numerics.html">25. Numerics</a></span></dt><dt><span class="chapter"><a href="ext_iterators.html">26. Iterators</a></span></dt><dt><span class="chapter"><a href="ext_io.html">27. Input and Output</a></span></dt><dd><dl><dt><span class="section"><a href="ext_io.html#manual.ext.io.filebuf_derived">Derived filebufs</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_demangling.html">28. Demangling</a></span></dt><dt><span class="chapter"><a href="ext_concurrency.html">29. Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design">Design</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.threads">Interface to Locks and Mutexes</a></span></dt><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.atomics">Interface to Atomic Functions</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_impl.html">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.atomic_fallbacks">Using Built-in Atomic Functions</a></span></dt><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.thread">Thread Abstraction</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_use.html">Use</a></span></dt></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="io_and_c.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ext_preface.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Interacting with C </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
\ No newline at end of file
+	</a></span></dt></dl></dd><dt><span class="section"><a href="policy_based_data_structures_test.html#pbds.test.performance.observations">Observations</a></span></dt><dd><dl><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.associative">Associative</a></span></dt><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.priority_queue">Priority_Queue</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="policy_data_structures_ack.html">Acknowledgments</a></span></dt><dt><span class="bibliography"><a href="policy_data_structures.html#pbds.biblio">Bibliography</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_containers.html">22. HP/SGI Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="ext_containers.html#manual.ext.containers.sgi">Backwards Compatibility</a></span></dt><dt><span class="section"><a href="ext_sgi.html">Deprecated</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_utilities.html">23. Utilities</a></span></dt><dt><span class="chapter"><a href="ext_algorithms.html">24. Algorithms</a></span></dt><dt><span class="chapter"><a href="ext_numerics.html">25. Numerics</a></span></dt><dt><span class="chapter"><a href="ext_iterators.html">26. Iterators</a></span></dt><dt><span class="chapter"><a href="ext_io.html">27. Input and Output</a></span></dt><dd><dl><dt><span class="section"><a href="ext_io.html#manual.ext.io.filebuf_derived">Derived filebufs</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_demangling.html">28. Demangling</a></span></dt><dt><span class="chapter"><a href="ext_concurrency.html">29. Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design">Design</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.threads">Interface to Locks and Mutexes</a></span></dt><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.atomics">Interface to Atomic Functions</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_impl.html">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.atomic_fallbacks">Using Built-in Atomic Functions</a></span></dt><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.thread">Thread Abstraction</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_use.html">Use</a></span></dt></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="concurrency.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ext_preface.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 15. 
+  Concurrency
+  
+ </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/index.html b/libstdc++-v3/doc/html/manual/index.html
index 7122ddeaabd..0a5a58352ce 100644
--- a/libstdc++-v3/doc/html/manual/index.html
+++ b/libstdc++-v3/doc/html/manual/index.html
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The GNU C++ Library Manual</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="../index.html" title="The GNU C++ Library" /><link rel="prev" href="../index.html" title="The GNU C++ Library" /><link rel="next" href="intro.html" title="Part I.  Introduction" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The GNU C++ Library Manual</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../index.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="intro.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="manual"></a>The GNU C++ Library Manual</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname"></span> <span class="surname"></span></h3></div><div class="author"><h3 class="author"><span class="firstname">Paolo</span> <span class="surname">Carlini</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Phil</span> <span class="surname">Edwards</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Doug</span> <span class="surname">Gregor</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Benjamin</span> <span class="surname">Kosnik</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Dhruv</span> <span class="surname">Matani</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jason</span> <span class="surname">Merrill</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Mitchell</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Nathan</span> <span class="surname">Myers</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Felix</span> <span class="surname">Natter</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Stefan</span> <span class="surname">Olsson</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Johannes</span> <span class="surname">Singler</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Ami</span> <span class="surname">Tavory</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jonathan</span> <span class="surname">Wakely</span></h3></div></div></div><div><p class="copyright">Copyright © 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The GNU C++ Library Manual</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="../index.html" title="The GNU C++ Library" /><link rel="prev" href="../index.html" title="The GNU C++ Library" /><link rel="next" href="intro.html" title="Part I.  Introduction" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The GNU C++ Library Manual</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../index.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="intro.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="manual"></a>The GNU C++ Library Manual</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Paolo</span> <span class="surname">Carlini</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Phil</span> <span class="surname">Edwards</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Doug</span> <span class="surname">Gregor</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Benjamin</span> <span class="surname">Kosnik</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Dhruv</span> <span class="surname">Matani</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jason</span> <span class="surname">Merrill</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Mitchell</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Nathan</span> <span class="surname">Myers</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Felix</span> <span class="surname">Natter</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Stefan</span> <span class="surname">Olsson</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Johannes</span> <span class="surname">Singler</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Ami</span> <span class="surname">Tavory</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jonathan</span> <span class="surname">Wakely</span></h3></div></div></div><div><p class="copyright">Copyright © 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 
       <a class="link" href="https://www.fsf.org" target="_top">FSF</a>
     </p></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="part"><a href="intro.html">I. 
   Introduction
@@ -123,7 +123,7 @@
     Existing tests
 </a></span></dt><dt><span class="section"><a href="test.html#test.exception.safety.containers">
 C++11 Requirements Test Sequence Descriptions
-</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="abi.html">ABI Policy and Guidelines</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.cxx_interface">The C++ Interface</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning">Versioning</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.versioning.goals">Goals</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.history">History</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.config">Configuring</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.active">Checking Active</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.changes_allowed">Allowed Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.changes_no">Prohibited Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.impl">Implementation</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing">Testing</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.testing.single">Single ABI Testing</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing.multi">Multiple ABI Testing</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.issues">Outstanding Issues</a></span></dt></dl></dd><dt><span class="section"><a href="api.html">API Evolution and Deprecation History</a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_300"><code class="constant">3.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_310"><code class="constant">3.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_320"><code class="constant">3.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_330"><code class="constant">3.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_340"><code class="constant">3.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_400"><code class="constant">4.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_410"><code class="constant">4.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_420"><code class="constant">4.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_430"><code class="constant">4.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_440"><code class="constant">4.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_450"><code class="constant">4.5</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_460"><code class="constant">4.6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_470"><code class="constant">4.7</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_480"><code class="constant">4.8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_490"><code class="constant">4.9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_51"><code class="constant">5</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_53"><code class="constant">5.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_61"><code class="constant">6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_71"><code class="constant">7</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_72"><code class="constant">7.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_73"><code class="constant">7.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_81"><code class="constant">8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_91"><code class="constant">9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_101"><code class="constant">10</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_111"><code class="constant">11</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_121"><code class="constant">12</code></a></span></dt></dl></dd><dt><span class="section"><a href="backwards.html">Backwards Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.first">First</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.second">Second</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third">Third</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.third.headers">Pre-ISO headers removed</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.hash">Extension headers hash_map, hash_set moved to ext or backwards</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.nocreate_noreplace">No <code class="code">ios::nocreate/ios::noreplace</code>.
+</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="abi.html">ABI Policy and Guidelines</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.cxx_interface">The C++ Interface</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning">Versioning</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.versioning.goals">Goals</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.history">History</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.config">Configuring</a></span></dt><dt><span class="section"><a href="abi.html#abi.versioning.active">Checking Active</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.changes_allowed">Allowed Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.changes_no">Prohibited Changes</a></span></dt><dt><span class="section"><a href="abi.html#abi.impl">Implementation</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing">Testing</a></span></dt><dd><dl><dt><span class="section"><a href="abi.html#abi.testing.single">Single ABI Testing</a></span></dt><dt><span class="section"><a href="abi.html#abi.testing.multi">Multiple ABI Testing</a></span></dt></dl></dd><dt><span class="section"><a href="abi.html#abi.issues">Outstanding Issues</a></span></dt></dl></dd><dt><span class="section"><a href="api.html">API Evolution and Deprecation History</a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_300"><code class="constant">3.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_310"><code class="constant">3.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_320"><code class="constant">3.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_330"><code class="constant">3.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_340"><code class="constant">3.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_400"><code class="constant">4.0</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_410"><code class="constant">4.1</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_420"><code class="constant">4.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_430"><code class="constant">4.3</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_440"><code class="constant">4.4</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_450"><code class="constant">4.5</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_460"><code class="constant">4.6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_470"><code class="constant">4.7</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_480"><code class="constant">4.8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_490"><code class="constant">4.9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_51"><code class="constant">5</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_53"><code class="constant">5.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_61"><code class="constant">6</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_71"><code class="constant">7</code></a></span></dt><dd><dl><dt><span class="section"><a href="api.html#api.rel_72"><code class="constant">7.2</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_73"><code class="constant">7.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="api.html#api.rel_81"><code class="constant">8</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_91"><code class="constant">9</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_101"><code class="constant">10</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_111"><code class="constant">11</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_121"><code class="constant">12</code></a></span></dt><dt><span class="section"><a href="api.html#api.rel_123"><code class="constant">12.3</code></a></span></dt></dl></dd><dt><span class="section"><a href="backwards.html">Backwards Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.first">First</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.second">Second</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third">Third</a></span></dt><dd><dl><dt><span class="section"><a href="backwards.html#backwards.third.headers">Pre-ISO headers removed</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.hash">Extension headers hash_map, hash_set moved to ext or backwards</a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.nocreate_noreplace">No <code class="code">ios::nocreate/ios::noreplace</code>.
 </a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.streamattach">
 No <code class="code">stream::attach(int fd)</code>
 </a></span></dt><dt><span class="section"><a href="backwards.html#backwards.third.support_cxx98">
diff --git a/libstdc++-v3/doc/html/manual/using.html b/libstdc++-v3/doc/html/manual/using.html
index 641a08c688b..08facffa445 100644
--- a/libstdc++-v3/doc/html/manual/using.html
+++ b/libstdc++-v3/doc/html/manual/using.html
@@ -16,7 +16,11 @@
       <span class="command"><strong>g++ -std=gnu++98</strong></span> for older releases.
     </p><div class="table"><a id="table.cmd_options"></a><p class="title"><strong>Table 3.1. C++ Command Options</strong></p><div class="table-contents"><table class="table" summary="C++ Command Options" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Option Flags</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code class="literal">-std=c++98</code> or <code class="literal">-std=c++03</code>
       </td><td align="left">Use the 1998 ISO C++ standard plus amendments.</td></tr><tr><td align="left"><code class="literal">-std=gnu++98</code> or <code class="literal">-std=gnu++03</code>
-      </td><td align="left">As directly above, with GNU extensions.</td></tr><tr><td align="left"><code class="literal">-std=c++11</code></td><td align="left">Use the 2011 ISO C++ standard.</td></tr><tr><td align="left"><code class="literal">-std=gnu++11</code></td><td align="left">As directly above, with GNU extensions.</td></tr><tr><td align="left"><code class="literal">-std=c++14</code></td><td align="left">Use the 2014 ISO C++ standard.</td></tr><tr><td align="left"><code class="literal">-std=gnu++14</code></td><td align="left">As directly above, with GNU extensions.</td></tr><tr><td align="left"><code class="literal">-fexceptions</code></td><td align="left">See <a class="link" href="using_exceptions.html#intro.using.exception.no" title="Doing without">exception-free dialect</a></td></tr><tr><td align="left"><code class="literal">-frtti</code></td><td align="left">As above, but RTTI-free dialect.</td></tr><tr><td align="left"><code class="literal">-pthread</code></td><td align="left">For ISO C++11
+      </td><td align="left">As directly above, with GNU extensions.</td></tr><tr><td align="left"><code class="literal">-std=c++11</code></td><td align="left">Use the 2011 ISO C++ standard.</td></tr><tr><td align="left"><code class="literal">-std=gnu++11</code></td><td align="left">As directly above, with GNU extensions.</td></tr><tr><td align="left"><code class="literal">-std=c++14</code></td><td align="left">Use the 2014 ISO C++ standard.</td></tr><tr><td align="left"><code class="literal">-std=gnu++14</code></td><td align="left">As directly above, with GNU extensions.</td></tr><tr><td align="left">
+	<code class="literal">-fno-exceptions</code>
+      </td><td align="left">See <a class="link" href="using_exceptions.html#intro.using.exception.no" title="Doing without">exception-free dialect</a></td></tr><tr><td align="left">
+	<code class="literal">-fno-rtti</code>
+      </td><td align="left">As above, but RTTI-free dialect.</td></tr><tr><td align="left"><code class="literal">-pthread</code></td><td align="left">For ISO C++11
         <code class="filename">&lt;thread&gt;</code>,
         <code class="filename">&lt;future&gt;</code>,
         <code class="filename">&lt;mutex&gt;</code>,
@@ -27,6 +31,12 @@
       </td></tr><tr><td align="left"><code class="literal">-lstdc++fs</code></td><td align="left">Linking to <code class="filename">libstdc++fs</code>
         is required for use of the Filesystem library extensions in
         <code class="filename">&lt;experimental/filesystem&gt;</code>.
+      </td></tr><tr><td align="left"><code class="literal">-lstdc++_libbacktrace</code></td><td align="left">Until C++23 support is non-experimental, linking to
+	<code class="filename">libstdc++_libbacktrace.a</code>
+	is required for use of the C++23 type
+	<code class="classname">std::stacktrace</code>
+	and related types in
+	<code class="filename">&lt;stacktrace&gt;</code>.
       </td></tr><tr><td align="left"><code class="literal">-fopenmp</code></td><td align="left">For <a class="link" href="parallel_mode.html" title="Chapter 18. Parallel Mode">parallel</a> mode.</td></tr><tr><td align="left"><code class="literal">-ltbb</code></td><td align="left">Linking to tbb (Thread Building Blocks) is required for use of the
         Parallel Standard Algorithms and execution policies in
         <code class="filename">&lt;execution&gt;</code>.
diff --git a/libstdc++-v3/doc/html/manual/using_macros.html b/libstdc++-v3/doc/html/manual/using_macros.html
index edbbd03c336..a449b27b163 100644
--- a/libstdc++-v3/doc/html/manual/using_macros.html
+++ b/libstdc++-v3/doc/html/manual/using_macros.html
@@ -43,7 +43,7 @@
       <a class="link" href="configure.html" title="Configure">Configure</a>),
       with the various --enable/--disable choices being translated to
       #define/#undef).
-   </p><p> <acronym class="acronym">ABI</acronym> means that changing from the default value may
+   </p><p> <acronym class="acronym">ABI</acronym>-changing means that changing from the default value may
   mean changing the <acronym class="acronym">ABI</acronym> of compiled code. In other words,
   these choices control code which has already been compiled (i.e., in a
   binary such as libstdc++.a/.so).  If you explicitly #define or
@@ -53,7 +53,8 @@
   consistent linkage requires changing the config headers before
   building/installing the library.
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="code">_GLIBCXX_USE_DEPRECATED</code></span></dt><dd><p>
-	Defined by default. Not configurable. ABI-changing. Turning this off
+	Defined to the value <code class="literal">1</code> by default.
+	Not configurable. ABI-changing. Turning this off
 	removes older ARM-style iostreams code, and other anachronisms
 	from the API.  This macro is dependent on the version of the
 	standard being tracked, and as a result may give different results for
diff --git a/libstdc++-v3/doc/xml/authors.xml b/libstdc++-v3/doc/xml/authors.xml
index 0a120b508e9..95626d46cba 100644
--- a/libstdc++-v3/doc/xml/authors.xml
+++ b/libstdc++-v3/doc/xml/authors.xml
@@ -13,18 +13,13 @@
       </address>
     </affiliation>
 
-    <authorblurb>
+    <personblurb>
       <para>
       </para>
-    </authorblurb>
+    </personblurb>
   </author>
 -->
 
-  <author><personname><firstname/><surname/></personname><personblurb>
-      <para>
-      </para>
-    </personblurb></author>
-
   <author><personname><firstname>Paolo</firstname><surname>Carlini</surname></personname><personblurb>
       <para>
 	TR1, LWG Active, Closed, Defects lists.
diff --git a/libstdc++-v3/doc/xml/manual/abi.xml b/libstdc++-v3/doc/xml/manual/abi.xml
index c2c0c028a8b..10bef12c768 100644
--- a/libstdc++-v3/doc/xml/manual/abi.xml
+++ b/libstdc++-v3/doc/xml/manual/abi.xml
@@ -348,6 +348,7 @@ compatible.
     <listitem><para>GCC 9.3.0: GLIBCXX_3.4.28, CXXABI_1.3.12</para></listitem>
     <listitem><para>GCC 10.1.0: GLIBCXX_3.4.28, CXXABI_1.3.12</para></listitem>
     <listitem><para>GCC 11.1.0: GLIBCXX_3.4.29, CXXABI_1.3.13</para></listitem>
+    <listitem><para>GCC 12.1.0: GLIBCXX_3.4.30, CXXABI_1.3.13</para></listitem>
 
     </itemizedlist>
     </listitem>
diff --git a/libstdc++-v3/doc/xml/manual/evolution.xml b/libstdc++-v3/doc/xml/manual/evolution.xml
index 4923e8c4783..82936189179 100644
--- a/libstdc++-v3/doc/xml/manual/evolution.xml
+++ b/libstdc++-v3/doc/xml/manual/evolution.xml
@@ -817,6 +817,10 @@ now defaults to zero.
   <classname>has_trivial_copy_assign</classname> removed.
 </para>
 
+<para>
+Calling a <code>std::bind</code> result as volatile was deprecated for C++17.
+</para>
+
 <para> Profile Mode was deprecated. </para>
 
 <section xml:id="api.rel_72"><info><title><constant>7.2</constant></title></info>
@@ -1067,4 +1071,13 @@ the process.
 
 </section>
 
+
+<section xml:id="api.rel_123"><info><title><constant>12.3</constant></title></info>
+<para>
+Calling a <code>std::bind</code> result as volatile is ill-formed for C++20
+and later.
+</para>
+
+</section>
+
 </section>
diff --git a/libstdc++-v3/doc/xml/manual/intro.xml b/libstdc++-v3/doc/xml/manual/intro.xml
index 290e5d3a74e..e3a03cf9d59 100644
--- a/libstdc++-v3/doc/xml/manual/intro.xml
+++ b/libstdc++-v3/doc/xml/manual/intro.xml
@@ -852,6 +852,12 @@ requirements of the license of GCC.
 		    by the resolution of the DR.
     </para></listitem></varlistentry>
 
+    <varlistentry xml:id="manual.bugs.dr1203"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#1203">1203</link>:
+       <emphasis>More useful rvalue stream insertion</emphasis>
+    </term>
+    <listitem><para>Return the stream as its original type, not the base class.
+    </para></listitem></varlistentry>
+
     <varlistentry xml:id="manual.bugs.dr1339"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#1339">1339</link>:
        <emphasis>uninitialized_fill_n should return the end of its range</emphasis>
     </term>
@@ -1157,6 +1163,15 @@ requirements of the license of GCC.
     ill-formed.
     </para></listitem></varlistentry>
 
+    <varlistentry xml:id="manual.bugs.dr2487"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#2487">2487</link>:
+       <emphasis><code>bind()</code> should be <code>const</code>-overloaded
+      not cv-overloaded
+       </emphasis>
+    </term>
+    <listitem><para>Deprecate volatile-qualified <code>operator()</code>
+    for C++17, make it ill-formed for C++20.
+    </para></listitem></varlistentry>
+
     <varlistentry xml:id="manual.bugs.dr2499"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#2499">2499</link>:
        <emphasis><code>operator>>(basic_istream&amp;, CharT*)</code> makes it hard to avoid buffer overflows
        </emphasis>
diff --git a/libstdc++-v3/doc/xml/manual/spine.xml b/libstdc++-v3/doc/xml/manual/spine.xml
index 34daa33344c..eff72bc13d7 100644
--- a/libstdc++-v3/doc/xml/manual/spine.xml
+++ b/libstdc++-v3/doc/xml/manual/spine.xml
@@ -48,18 +48,13 @@
       </address>
     </affiliation>
 
-    <authorblurb>
+    <personblurb>
       <para>
       </para>
-    </authorblurb>
+    </personblurb>
   </author>
 -->
 
-  <author><personname><firstname/><surname/></personname><personblurb>
-      <para>
-      </para>
-    </personblurb></author>
-
   <author><personname><firstname>Paolo</firstname><surname>Carlini</surname></personname><personblurb>
       <para>
 	TR1, LWG Active, Closed, Defects lists.
diff --git a/libstdc++-v3/doc/xml/manual/using.xml b/libstdc++-v3/doc/xml/manual/using.xml
index 36b86702d22..a8a549eebcd 100644
--- a/libstdc++-v3/doc/xml/manual/using.xml
+++ b/libstdc++-v3/doc/xml/manual/using.xml
@@ -69,12 +69,16 @@
     </row>
 
     <row>
-      <entry><literal>-fexceptions</literal></entry>
+      <entry>
+	<literal>-fno-exceptions</literal>
+      </entry>
       <entry>See <link linkend="intro.using.exception.no">exception-free dialect</link></entry>
     </row>
 
     <row>
-      <entry><literal>-frtti</literal></entry>
+      <entry>
+	<literal>-fno-rtti</literal>
+      </entry>
       <entry>As above, but RTTI-free dialect.</entry>
     </row>
 
@@ -104,6 +108,17 @@
       </entry>
     </row>
 
+    <row>
+      <entry><literal>-lstdc++_libbacktrace</literal></entry>
+      <entry>Until C++23 support is non-experimental, linking to
+	<filename class="libraryfile">libstdc++_libbacktrace.a</filename>
+	is required for use of the C++23 type
+	<classname>std::stacktrace</classname>
+	and related types in
+	<filename class="headerfile">&lt;stacktrace&gt;</filename>.
+      </entry>
+    </row>
+
     <row>
       <entry><literal>-fopenmp</literal></entry>
       <entry>For <link linkend="manual.ext.parallel_mode">parallel</link> mode.</entry>
@@ -1047,7 +1062,7 @@ g++ -Winvalid-pch -I. -include stdc++.h -H -g -O2 hello.cc -o test.exe
       #define/#undef).
    </para>
 
-   <para> <acronym>ABI</acronym> means that changing from the default value may
+   <para> <acronym>ABI</acronym>-changing means that changing from the default value may
   mean changing the <acronym>ABI</acronym> of compiled code. In other words,
   these choices control code which has already been compiled (i.e., in a
   binary such as libstdc++.a/.so).  If you explicitly #define or
@@ -1062,7 +1077,8 @@ g++ -Winvalid-pch -I. -include stdc++.h -H -g -O2 hello.cc -o test.exe
     <varlistentry><term><code>_GLIBCXX_USE_DEPRECATED</code></term>
     <listitem>
       <para>
-	Defined by default. Not configurable. ABI-changing. Turning this off
+	Defined to the value <literal>1</literal> by default.
+	Not configurable. ABI-changing. Turning this off
 	removes older ARM-style iostreams code, and other anachronisms
 	from the API.  This macro is dependent on the version of the
 	standard being tracked, and as a result may give different results for
diff --git a/libstdc++-v3/include/bits/atomic_wait.h b/libstdc++-v3/include/bits/atomic_wait.h
index a6d55d3af8a..76ed7409937 100644
--- a/libstdc++-v3/include/bits/atomic_wait.h
+++ b/libstdc++-v3/include/bits/atomic_wait.h
@@ -221,18 +221,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
 
       void
-      _M_notify(const __platform_wait_t* __addr, bool __all, bool __bare) noexcept
+      _M_notify(__platform_wait_t* __addr, [[maybe_unused]] bool __all,
+		bool __bare) noexcept
       {
-	if (!(__bare || _M_waiting()))
-	  return;
-
 #ifdef _GLIBCXX_HAVE_PLATFORM_WAIT
-	__platform_notify(__addr, __all);
+	if (__addr == &_M_ver)
+	  {
+	    __atomic_fetch_add(__addr, 1, __ATOMIC_SEQ_CST);
+	    __all = true;
+	  }
+
+	if (__bare || _M_waiting())
+	  __platform_notify(__addr, __all);
 #else
-	if (__all)
+	{
+	  lock_guard<mutex> __l(_M_mtx);
+	  __atomic_fetch_add(__addr, 1, __ATOMIC_RELAXED);
+	}
+	if (__bare || _M_waiting())
 	  _M_cv.notify_all();
-	else
-	  _M_cv.notify_one();
 #endif
       }
 
@@ -259,7 +266,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	if (__val == __old)
 	  {
 	    lock_guard<mutex> __l(_M_mtx);
-	    _M_cv.wait(_M_mtx);
+	    __atomic_load(__addr, &__val, __ATOMIC_RELAXED);
+	    if (__val == __old)
+	      _M_cv.wait(_M_mtx);
 	  }
 #endif // __GLIBCXX_HAVE_PLATFORM_WAIT
       }
@@ -297,20 +306,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    , _M_addr(_S_wait_addr(__addr, &_M_w._M_ver))
 	  { }
 
-	bool
-	_M_laundered() const
-	{ return _M_addr == &_M_w._M_ver; }
-
 	void
-	_M_notify(bool __all, bool __bare = false)
-	{
-	  if (_M_laundered())
-	    {
-	      __atomic_fetch_add(_M_addr, 1, __ATOMIC_SEQ_CST);
-	      __all = true;
-	    }
-	  _M_w._M_notify(_M_addr, __all, __bare);
-	}
+	_M_notify(bool __all, bool __bare = false) noexcept
+	{ _M_w._M_notify(_M_addr, __all, __bare); }
 
 	template<typename _Up, typename _ValFn,
 		 typename _Spin = __default_spin_policy>
diff --git a/libstdc++-v3/include/bits/basic_string.h b/libstdc++-v3/include/bits/basic_string.h
index 9777deaf2e9..f1a0e6984a1 100644
--- a/libstdc++-v3/include/bits/basic_string.h
+++ b/libstdc++-v3/include/bits/basic_string.h
@@ -352,8 +352,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       {
 #if __cpp_lib_is_constant_evaluated
 	if (std::is_constant_evaluated())
-	  for (_CharT& __c : _M_local_buf)
-	    __c = _CharT();
+	  for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
+	    _M_local_buf[__i] = _CharT();
 #endif
 	return _M_local_data();
       }
diff --git a/libstdc++-v3/include/bits/chrono.h b/libstdc++-v3/include/bits/chrono.h
index 421898516ae..65e3e3183f7 100644
--- a/libstdc++-v3/include/bits/chrono.h
+++ b/libstdc++-v3/include/bits/chrono.h
@@ -442,6 +442,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     template<typename _Rep, typename _Period>
       struct duration
       {
+	static_assert(!__is_duration<_Rep>::value, "rep cannot be a duration");
+	static_assert(__is_ratio<_Period>::value,
+		      "period must be a specialization of ratio");
+	static_assert(_Period::num > 0, "period must be positive");
+
       private:
 	template<typename _Rep2>
 	  using __is_float = treat_as_floating_point<_Rep2>;
@@ -487,11 +492,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	using rep = _Rep;
 	using period = typename _Period::type;
 
-	static_assert(!__is_duration<_Rep>::value, "rep cannot be a duration");
-	static_assert(__is_ratio<_Period>::value,
-		      "period must be a specialization of ratio");
-	static_assert(_Period::num > 0, "period must be positive");
-
 	// 20.11.5.1 construction / copy / destroy
 	constexpr duration() = default;
 
diff --git a/libstdc++-v3/include/bits/fs_dir.h b/libstdc++-v3/include/bits/fs_dir.h
index ca37952ec17..bec2b7674ef 100644
--- a/libstdc++-v3/include/bits/fs_dir.h
+++ b/libstdc++-v3/include/bits/fs_dir.h
@@ -36,8 +36,9 @@
 # include <bits/unique_ptr.h>
 # include <bits/shared_ptr.h>
 
-#if __cplusplus > 201703L
+#if __cplusplus >= 202002L
 # include <compare>	// std::strong_ordering
+# include <bits/iterator_concepts.h>	// std::default_sentinel_t
 #endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -420,9 +421,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       return __pr;
     }
 
-  private:
-    directory_iterator(const path&, directory_options, error_code*);
-
     friend bool
     operator==(const directory_iterator& __lhs,
                const directory_iterator& __rhs) noexcept
@@ -431,10 +429,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	&& !__lhs._M_dir.owner_before(__rhs._M_dir);
     }
 
+#if __cplusplus >= 202002L
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 3719. Directory iterators should be usable with default sentinel
+      bool operator==(default_sentinel_t) const noexcept
+      { return !_M_dir; }
+#endif
+
+#if __cpp_impl_three_way_comparison < 201907L
     friend bool
     operator!=(const directory_iterator& __lhs,
 	       const directory_iterator& __rhs) noexcept
     { return !(__lhs == __rhs); }
+#endif
+
+  private:
+    directory_iterator(const path&, directory_options, error_code*);
 
     friend class recursive_directory_iterator;
 
@@ -519,9 +529,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
     void disable_recursion_pending() noexcept;
 
-  private:
-    recursive_directory_iterator(const path&, directory_options, error_code*);
-
     friend bool
     operator==(const recursive_directory_iterator& __lhs,
                const recursive_directory_iterator& __rhs) noexcept
@@ -530,10 +537,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	&& !__lhs._M_dirs.owner_before(__rhs._M_dirs);
     }
 
+#if __cplusplus >= 202002L
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 3719. Directory iterators should be usable with default sentinel
+      bool operator==(default_sentinel_t) const noexcept
+      { return !_M_dirs; }
+#endif
+
+#if __cpp_impl_three_way_comparison < 201907L
     friend bool
     operator!=(const recursive_directory_iterator& __lhs,
                const recursive_directory_iterator& __rhs) noexcept
     { return !(__lhs == __rhs); }
+#endif
+
+  private:
+    recursive_directory_iterator(const path&, directory_options, error_code*);
 
     struct _Dir_stack;
     std::__shared_ptr<_Dir_stack> _M_dirs;
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
index d6202fd275a..7a3d0513134 100644
--- a/libstdc++-v3/include/bits/fs_path.h
+++ b/libstdc++-v3/include/bits/fs_path.h
@@ -730,12 +730,21 @@ namespace __detail
     _List _M_cmpts;
 
     struct _Parser;
+
+    template<typename _EcharT> struct _Codecvt;
   };
 
   /// @{
   /// @relates std::filesystem::path
 
+#if __cpp_concepts >= 201907L
+  // Workaround for PR libstdc++/106201
+  inline void
+  swap(same_as<path> auto& __lhs, same_as<path> auto& __rhs) noexcept
+  { __lhs.swap(__rhs); }
+#else
   inline void swap(path& __lhs, path& __rhs) noexcept { __lhs.swap(__rhs); }
+#endif
 
   size_t hash_value(const path& __p) noexcept;
 
@@ -858,55 +867,72 @@ namespace __detail
     size_t _M_pos;
   };
 
+  // path::_Codecvt<C> Performs conversions between C and path::string_type.
+  // The native encoding of char strings is the OS-dependent current
+  // encoding for pathnames. FIXME: We assume this is UTF-8 everywhere,
+  // but should use a Windows API to query it.
+
+  // Converts between native pathname encoding and char16_t or char32_t.
+  template<typename _EcharT>
+    struct path::_Codecvt
+    // Need derived class here because std::codecvt has protected destructor.
+    : std::codecvt<_EcharT, char, mbstate_t>
+    { };
+
+  // Converts between native pathname encoding and native wide encoding.
+  // The native encoding for wide strings is the execution wide-character
+  // set encoding. FIXME: We assume that this is either UTF-32 or UTF-16
+  // (depending on the width of wchar_t). That matches GCC's default,
+  // but can be changed with -fwide-exec-charset.
+  // We need a custom codecvt converting the native pathname encoding
+  // to/from the native wide encoding.
+  template<>
+    struct path::_Codecvt<wchar_t>
+    : __conditional_t<sizeof(wchar_t) == sizeof(char32_t),
+		      std::codecvt_utf8<wchar_t>,       // UTF-8 <-> UTF-32
+		      std::codecvt_utf8_utf16<wchar_t>> // UTF-8 <-> UTF-16
+    { };
+
   template<typename _EcharT>
     auto
     path::_S_convert(const _EcharT* __f, const _EcharT* __l)
     {
       static_assert(__detail::__is_encoded_char<_EcharT>);
 
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+# define _GLIBCXX_CONV_FROM_UTF8(S) __detail::__wstr_from_utf8(S)
+#else
+# define _GLIBCXX_CONV_FROM_UTF8(S) S
+#endif
+
       if constexpr (is_same_v<_EcharT, value_type>)
 	return basic_string_view<value_type>(__f, __l - __f);
-#if !defined _GLIBCXX_FILESYSTEM_IS_WINDOWS && defined _GLIBCXX_USE_CHAR8_T
+#ifdef _GLIBCXX_USE_CHAR8_T
       else if constexpr (is_same_v<_EcharT, char8_t>)
-	// For POSIX converting from char8_t to char is also 'noconv'
-	return string_view(reinterpret_cast<const char*>(__f), __l - __f);
-#endif
-      else
 	{
+	  string_view __str(reinterpret_cast<const char*>(__f), __l - __f);
+	  return _GLIBCXX_CONV_FROM_UTF8(__str);
+	}
+#endif
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      else if constexpr (is_same_v<_EcharT, char>)
+	{
 	  std::wstring __wstr;
-	  if constexpr (is_same_v<_EcharT, char>)
-	    {
-	      struct _UCvt : std::codecvt<wchar_t, char, std::mbstate_t>
-	      { } __cvt;
-	      if (__str_codecvt_in_all(__f, __l, __wstr, __cvt))
-		return __wstr;
-	    }
-#ifdef _GLIBCXX_USE_CHAR8_T
-	  else if constexpr (is_same_v<_EcharT, char8_t>)
-	    {
-	      const auto __f2 = reinterpret_cast<const char*>(__f);
-	      return __detail::__wstr_from_utf8(string_view(__f2, __l - __f));
-	    }
+	  path::_Codecvt<wchar_t> __cvt;
+	  if (__str_codecvt_in_all(__f, __l, __wstr, __cvt))
+	    return __wstr;
+	}
 #endif
-	  else // char16_t or char32_t
-	    {
-	      struct _UCvt : std::codecvt<_EcharT, char, std::mbstate_t>
-	      { } __cvt;
-	      std::string __str;
-	      if (__str_codecvt_out_all(__f, __l, __str, __cvt))
-		return __detail::__wstr_from_utf8(__str);
-	    }
-#else // ! windows
-	  struct _UCvt : std::codecvt<_EcharT, char, std::mbstate_t>
-	  { } __cvt;
+      else
+	{
+	  path::_Codecvt<_EcharT> __cvt;
 	  std::string __str;
 	  if (__str_codecvt_out_all(__f, __l, __str, __cvt))
-	    return __str;
-#endif
-	  __detail::__throw_conversion_error();
+	    return _GLIBCXX_CONV_FROM_UTF8(__str);
 	}
+      __detail::__throw_conversion_error();
     }
+#undef _GLIBCXX_CONV_FROM_UTF8
 
   /// @endcond
 
@@ -1088,7 +1114,9 @@ namespace __detail
       if (__str.size() == 0)
 	return _WString(__a);
 
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+#ifndef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      string_view __u8str = __str;
+#else
       // First convert native string from UTF-16 to to UTF-8.
       // XXX This assumes that the execution wide-character set is UTF-16.
       std::codecvt_utf8_utf16<value_type> __cvt;
@@ -1098,35 +1126,30 @@ namespace __detail
       _String __u8str{_CharAlloc{__a}};
       const value_type* __wfirst = __str.data();
       const value_type* __wlast = __wfirst + __str.size();
-      if (__str_codecvt_out_all(__wfirst, __wlast, __u8str, __cvt)) {
+      if (!__str_codecvt_out_all(__wfirst, __wlast, __u8str, __cvt))
+	__detail::__throw_conversion_error();
       if constexpr (is_same_v<_CharT, char>)
 	return __u8str; // XXX assumes native ordinary encoding is UTF-8.
-      else {
-
-      const char* __first = __u8str.data();
-      const char* __last = __first + __u8str.size();
-#else
-      const value_type* __first = __str.data();
-      const value_type* __last = __first + __str.size();
-#endif
-
-      // Convert UTF-8 string to requested format.
-#ifdef _GLIBCXX_USE_CHAR8_T
-      if constexpr (is_same_v<_CharT, char8_t>)
-	return _WString(__first, __last, __a);
       else
 #endif
 	{
-	  // Convert UTF-8 to wide string.
-	  _WString __wstr(__a);
-	  struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t> { } __cvt;
-	  if (__str_codecvt_in_all(__first, __last, __wstr, __cvt))
-	    return __wstr;
-	}
+	  const char* __first = __u8str.data();
+	  const char* __last = __first + __u8str.size();
 
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-      } }
+	  // Convert UTF-8 string to requested format.
+#ifdef _GLIBCXX_USE_CHAR8_T
+	  if constexpr (is_same_v<_CharT, char8_t>)
+	    return _WString(__first, __last, __a);
+	  else
 #endif
+	    {
+	      // Convert UTF-8 to wide string.
+	      _WString __wstr(__a);
+	      path::_Codecvt<_CharT> __cvt;
+	      if (__str_codecvt_in_all(__first, __last, __wstr, __cvt))
+		return __wstr;
+	    }
+	}
       __detail::__throw_conversion_error();
     }
   /// @endcond
@@ -1265,9 +1288,9 @@ namespace __detail
       {
 	if (_M_pathname.back() == preferred_separator)
 	  return {};
-	auto& __last = *--end();
-	if (__last._M_type() == _Type::_Filename)
-	  return __last;
+	auto __last = --end();
+	if (__last->_M_type() == _Type::_Filename)
+	  return *__last;
       }
     return {};
   }
diff --git a/libstdc++-v3/include/bits/iterator_concepts.h b/libstdc++-v3/include/bits/iterator_concepts.h
index a04c970b03b..cf66c63f395 100644
--- a/libstdc++-v3/include/bits/iterator_concepts.h
+++ b/libstdc++-v3/include/bits/iterator_concepts.h
@@ -32,15 +32,35 @@
 
 #pragma GCC system_header
 
+#if __cplusplus >= 202002L
 #include <concepts>
 #include <bits/ptr_traits.h>	// to_address
 #include <bits/ranges_cmp.h>	// identity, ranges::less
 
-#if __cpp_lib_concepts
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+  /** A sentinel type that can be used to check for the end of a range.
+   *
+   * For some iterator types the past-the-end sentinel value is independent
+   * of the underlying sequence, and a default sentinel can be used with them.
+   * For example, a `std::counted_iterator` keeps a count of how many elements
+   * remain, and so checking for the past-the-end value only requires checking
+   * if that count has reached zero. A past-the-end `std::istream_iterator` is
+   * equal to the default-constructed value, which can be easily checked.
+   *
+   * Comparing iterators of these types to `std::default_sentinel` is a
+   * convenient way to check if the end has been reached.
+   *
+   * @since C++20
+   */
+  struct default_sentinel_t { };
+
+  /// A default sentinel value.
+  inline constexpr default_sentinel_t default_sentinel{};
+
+#if __cpp_lib_concepts
   struct input_iterator_tag;
   struct output_iterator_tag;
   struct forward_iterator_tag;
@@ -924,9 +944,6 @@ namespace ranges
 
   inline constexpr unreachable_sentinel_t unreachable_sentinel{};
 
-  struct default_sentinel_t { };
-  inline constexpr default_sentinel_t default_sentinel{};
-
   // This is the namespace for [range.access] CPOs.
   namespace ranges::__cust_access
   {
@@ -983,7 +1000,8 @@ namespace ranges
 
   } // namespace __detail
 
+#endif // C++20 library concepts
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
-#endif // C++20 library concepts
+#endif // C++20
 #endif // _ITERATOR_CONCEPTS_H
diff --git a/libstdc++-v3/include/bits/mofunc_impl.h b/libstdc++-v3/include/bits/mofunc_impl.h
index 405c4054642..47e1e506306 100644
--- a/libstdc++-v3/include/bits/mofunc_impl.h
+++ b/libstdc++-v3/include/bits/mofunc_impl.h
@@ -205,10 +205,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
     private:
       template<typename _Tp>
-	using __param_t
-	  = __conditional_t<is_trivially_copyable_v<_Tp>
-			      && sizeof(_Tp) <= sizeof(long),
-			    _Tp, _Tp&&>;
+	using __param_t = __conditional_t<is_scalar_v<_Tp>, _Tp, _Tp&&>;
 
       using _Invoker = _Res (*)(_Mofunc_base _GLIBCXX_MOF_CV*,
 				__param_t<_ArgTypes>...) noexcept(_Noex);
diff --git a/libstdc++-v3/include/bits/regex.h b/libstdc++-v3/include/bits/regex.h
index 46c168010bf..a94ef190012 100644
--- a/libstdc++-v3/include/bits/regex.h
+++ b/libstdc++-v3/include/bits/regex.h
@@ -28,6 +28,10 @@
  *  Do not attempt to use it directly. @headername{regex}
  */
 
+#if __cplusplus >= 202002L
+# include <bits/iterator_concepts.h>	// std::default_sentinel_t
+#endif
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -2719,12 +2723,21 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       bool
       operator==(const regex_iterator&) const noexcept;
 
+#if __cplusplus >= 202002L
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 3719. Directory iterators should be usable with default sentinel
+      bool operator==(default_sentinel_t) const noexcept
+      { return _M_pregex == nullptr; }
+#endif
+
+#if __cpp_impl_three_way_comparison < 201907L
       /**
        * @brief Tests the inequivalence of two regex iterators.
        */
       bool
       operator!=(const regex_iterator& __rhs) const noexcept
       { return !(*this == __rhs); }
+#endif
 
       /**
        * @brief Dereferences a %regex_iterator.
@@ -2924,12 +2937,21 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       bool
       operator==(const regex_token_iterator& __rhs) const;
 
+#if __cplusplus >= 202002L
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 3719. Directory iterators should be usable with default sentinel
+      bool operator==(default_sentinel_t) const noexcept
+      { return _M_end_of_seq(); }
+#endif
+
+#if __cpp_impl_three_way_comparison < 201907L
       /**
        * @brief Compares a %regex_token_iterator to another for inequality.
        */
       bool
       operator!=(const regex_token_iterator& __rhs) const
       { return !(*this == __rhs); }
+#endif
 
       /**
        * @brief Dereferences a %regex_token_iterator.
@@ -2978,7 +3000,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       }
 
       constexpr bool
-      _M_end_of_seq() const
+      _M_end_of_seq() const noexcept
       { return _M_result == nullptr; }
 
       // [28.12.2.2.4]
diff --git a/libstdc++-v3/include/bits/regex_compiler.tcc b/libstdc++-v3/include/bits/regex_compiler.tcc
index c12f7502538..9f3ca63af51 100644
--- a/libstdc++-v3/include/bits/regex_compiler.tcc
+++ b/libstdc++-v3/include/bits/regex_compiler.tcc
@@ -583,10 +583,12 @@ namespace __detail
     _Compiler<_TraitsT>::
     _M_cur_int_value(int __radix)
     {
-      long __v = 0;
-      for (typename _StringT::size_type __i = 0;
-	   __i < _M_value.length(); ++__i)
-	__v =__v * __radix + _M_traits.value(_M_value[__i], __radix);
+      int __v = 0;
+      for (_CharT __c : _M_value)
+	if (__builtin_mul_overflow(__v, __radix, &__v)
+	    || __builtin_add_overflow(__v, _M_traits.value(__c, __radix), &__v))
+	    std::__throw_regex_error(regex_constants::error_backref,
+				     "invalid back reference");
       return __v;
     }
 
diff --git a/libstdc++-v3/include/bits/std_thread.h b/libstdc++-v3/include/bits/std_thread.h
index dd625de3bc3..6adf5e6b467 100644
--- a/libstdc++-v3/include/bits/std_thread.h
+++ b/libstdc++-v3/include/bits/std_thread.h
@@ -203,7 +203,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 	template<typename... _Args>
 	  _State_impl(_Args&&... __args)
-	  : _M_func{{std::forward<_Args>(__args)...}}
+	  : _M_func(std::forward<_Args>(__args)...)
 	  { }
 
 	void
@@ -237,6 +237,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     template<typename _Tuple>
       struct _Invoker
       {
+	template<typename... _Args>
+	  explicit
+	  _Invoker(_Args&&... __args)
+	  : _M_t(std::forward<_Args>(__args)...)
+	  { }
+
 	_Tuple _M_t;
 
 	template<typename>
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
index 19d246100cb..ba6acb2158d 100644
--- a/libstdc++-v3/include/experimental/bits/fs_path.h
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h
@@ -537,7 +537,14 @@ namespace __detail
   /// @relates std::experimental::filesystem::path @{
 
   /// Swap overload for paths
-  inline void swap(path& __lhs, path& __rhs) noexcept { __lhs.swap(__rhs); }
+#if __cpp_concepts >= 201907L
+  // Workaround for PR libstdc++/106201
+  inline void
+  swap(same_as<path> auto& __lhs, same_as<path> auto& __rhs) noexcept
+  { __lhs.swap(__rhs); }
+#else
+   inline void swap(path& __lhs, path& __rhs) noexcept { __lhs.swap(__rhs); }
+#endif
 
   /// Compute a hash value for a path
   size_t hash_value(const path& __p) noexcept;
@@ -734,15 +741,47 @@ namespace __detail
   template<>
     struct path::_Cvt<path::value_type>
     {
+      // We need this type to be defined because we don't have `if constexpr`
+      // in C++11 and so path::string<C,T,A>(const A&) needs to be able to
+      // declare a variable of this type and pass it to __str_codecvt_in_all.
+      using __codecvt_utf8_to_wide = _Cvt;
+      // Dummy overload used for unreachable calls in path::string<C,T,A>.
+      template<typename _WStr>
+	friend bool
+	__str_codecvt_in_all(const char*, const char*,
+			     _WStr&, __codecvt_utf8_to_wide&) noexcept
+	{ return true; }
+
       template<typename _Iter>
 	static string_type
 	_S_convert(_Iter __first, _Iter __last)
 	{ return string_type{__first, __last}; }
     };
 
+  // Performs conversions from _CharT to path::string_type.
   template<typename _CharT>
     struct path::_Cvt
     {
+      // FIXME: We currently assume that the native wide encoding for wchar_t
+      // is either UTF-32 or UTF-16 (depending on the width of wchar_t).
+      // See comments in <bits/fs_path.h> for further details.
+      using __codecvt_utf8_to_wchar
+	= __conditional_t<sizeof(wchar_t) == sizeof(char32_t),
+			  std::codecvt_utf8<wchar_t>,        // from UTF-32
+			  std::codecvt_utf8_utf16<wchar_t>>; // from UTF-16
+
+      // Converts from char16_t or char32_t using std::codecvt<charNN_t, char>.
+      // Need derived class here because std::codecvt has protected destructor.
+      struct __codecvt_utf8_to_utfNN : std::codecvt<_CharT, char, mbstate_t>
+      { };
+
+      // Convert from native pathname format (assumed to be UTF-8 everywhere)
+      // to the encoding implied by the wide character type _CharT.
+      using __codecvt_utf8_to_wide
+	= __conditional_t<is_same<_CharT, wchar_t>::value,
+			  __codecvt_utf8_to_wchar,
+			  __codecvt_utf8_to_utfNN>;
+
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
 #ifdef _GLIBCXX_USE_CHAR8_T
       static string_type
@@ -760,8 +799,7 @@ namespace __detail
       static string_type
       _S_wconvert(const char* __f, const char* __l, const char*)
       {
-	using _Cvt = std::codecvt<wchar_t, char, mbstate_t>;
-	const auto& __cvt = std::use_facet<_Cvt>(std::locale{});
+	std::codecvt_utf8_utf16<wchar_t> __cvt;
 	std::wstring __wstr;
 	if (__str_codecvt_in_all(__f, __l, __wstr, __cvt))
 	    return __wstr;
@@ -773,8 +811,7 @@ namespace __detail
       static string_type
       _S_wconvert(const _CharT* __f, const _CharT* __l, const void*)
       {
-	struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>
-	{ } __cvt;
+	__codecvt_utf8_to_wide __cvt;
 	std::string __str;
 	if (__str_codecvt_out_all(__f, __l, __str, __cvt))
 	  {
@@ -805,8 +842,7 @@ namespace __detail
 	else
 #endif
 	  {
-	    struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>
-	    { } __cvt;
+	    __codecvt_utf8_to_wide __cvt;
 	    std::string __str;
 	    if (__str_codecvt_out_all(__f, __l, __str, __cvt))
 	      return __str;
@@ -1013,7 +1049,7 @@ namespace __detail
     inline std::basic_string<_CharT, _Traits, _Allocator>
     path::string(const _Allocator& __a) const
     {
-      if (is_same<_CharT, value_type>::value)
+      if _GLIBCXX_CONSTEXPR (is_same<_CharT, value_type>::value)
 	return { _M_pathname.begin(), _M_pathname.end(), __a };
 
       using _WString = basic_string<_CharT, _Traits, _Allocator>;
@@ -1049,9 +1085,8 @@ namespace __detail
 	      else
 #endif
 	        {
-	          // Convert UTF-8 to wide string.
-	          struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>
-		  { } __cvt;
+		  // Convert UTF-8 to char16_t or char32_t string.
+		  typename path::_Cvt<_CharT>::__codecvt_utf8_to_wide __cvt;
 	          const char* __f = __from.data();
 	          const char* __l = __f + __from.size();
 	          if (__str_codecvt_in_all(__f, __l, __to, __cvt))
@@ -1064,14 +1099,14 @@ namespace __detail
 	  if (auto* __p = __dispatch(__u8str, __wstr, is_same<_CharT, char>{}))
 	    return *__p;
 	}
-#else
+#else // ! Windows
 #ifdef _GLIBCXX_USE_CHAR8_T
       if constexpr (is_same<_CharT, char8_t>::value)
           return _WString(__first, __last, __a);
       else
 #endif
         {
-          struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t> { } __cvt;
+	  typename path::_Cvt<_CharT>::__codecvt_utf8_to_wide __cvt;
           _WString __wstr(__a);
           if (__str_codecvt_in_all(__first, __last, __wstr, __cvt))
 	    return __wstr;
diff --git a/libstdc++-v3/include/std/barrier b/libstdc++-v3/include/std/barrier
index 2a2650546ad..997e0a8f7ab 100644
--- a/libstdc++-v3/include/std/barrier
+++ b/libstdc++-v3/include/std/barrier
@@ -13,8 +13,13 @@
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 // GNU General Public License for more details.
 
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.
 
 // This implementation is based on libcxx/include/barrier
diff --git a/libstdc++-v3/include/std/chrono b/libstdc++-v3/include/std/chrono
index 3732a40962a..83e0e5b8bd0 100644
--- a/libstdc++-v3/include/std/chrono
+++ b/libstdc++-v3/include/std/chrono
@@ -1945,6 +1945,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return __width;
 	}
 
+	constexpr
+	hh_mm_ss(_Duration __d, bool __is_neg)
+	: _M_is_neg(__is_neg),
+	  _M_h (duration_cast<chrono::hours>(__d)),
+	  _M_m (duration_cast<chrono::minutes>(__d - hours())),
+	  _M_s (duration_cast<chrono::seconds>(__d - hours() - minutes()))
+	{
+	  auto __ss = __d - hours() - minutes() - seconds();
+	  if constexpr (treat_as_floating_point_v<typename precision::rep>)
+	    _M_ss = __ss;
+	  else
+	    _M_ss = duration_cast<precision>(__ss);
+	}
+
+	static constexpr _Duration
+	_S_abs(_Duration __d)
+	{
+	  if constexpr (numeric_limits<typename _Duration::rep>::is_signed)
+	    return chrono::abs(__d);
+	  else
+	    return __d;
+	}
+
       public:
 	static constexpr unsigned fractional_width = {_S_fractional_width()};
 
@@ -1959,18 +1982,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{ }
 
 	constexpr explicit
-	hh_mm_ss(_Duration __d) noexcept
-	: _M_is_neg (__d < _Duration::zero()),
-	  _M_h (duration_cast<chrono::hours>(abs(__d))),
-	  _M_m (duration_cast<chrono::minutes>(abs(__d) - hours())),
-	  _M_s (duration_cast<chrono::seconds>(abs(__d) - hours() - minutes()))
-	{
-	  if constexpr (treat_as_floating_point_v<typename precision::rep>)
-	    _M_ss = abs(__d) - hours() - minutes() - seconds();
-	  else
-	    _M_ss = duration_cast<precision>(abs(__d) - hours()
-					     - minutes() - seconds());
-	}
+	hh_mm_ss(_Duration __d)
+	: hh_mm_ss(_S_abs(__d), __d < _Duration::zero())
+	{ }
 
 	constexpr bool
 	is_negative() const noexcept
diff --git a/libstdc++-v3/include/std/expected b/libstdc++-v3/include/std/expected
index 3ee13aa95f6..2fe25a90d2d 100644
--- a/libstdc++-v3/include/std/expected
+++ b/libstdc++-v3/include/std/expected
@@ -217,8 +217,8 @@ namespace __expected
 
       constexpr void
       swap(unexpected& __other) noexcept(is_nothrow_swappable_v<_Er>)
+      requires is_swappable_v<_Er>
       {
-	static_assert( is_swappable_v<_Er> );
 	using std::swap;
 	swap(_M_unex, __other._M_unex);
       }
@@ -230,9 +230,8 @@ namespace __expected
 	{ return __x._M_unex == __y.error(); }
 
       friend constexpr void
-      swap(unexpected& __x, unexpected& __y)
-      noexcept(noexcept(__x.swap(__y)))
-      requires requires {__x.swap(__y);}
+      swap(unexpected& __x, unexpected& __y) noexcept(noexcept(__x.swap(__y)))
+      requires is_swappable_v<_Er>
       { __x.swap(__y); }
 
     private:
@@ -359,7 +358,7 @@ namespace __expected
       requires is_copy_constructible_v<_Tp> && is_copy_constructible_v<_Er>
       && (!is_trivially_copy_constructible_v<_Tp>
 	  || !is_trivially_copy_constructible_v<_Er>)
-      : _M_invalid(), _M_has_value(__x._M_has_value)
+      : _M_has_value(__x._M_has_value)
       {
 	if (_M_has_value)
 	  std::construct_at(__builtin_addressof(_M_val), __x._M_val);
@@ -376,7 +375,7 @@ namespace __expected
       requires is_move_constructible_v<_Tp> && is_move_constructible_v<_Er>
       && (!is_trivially_move_constructible_v<_Tp>
 	  || !is_trivially_move_constructible_v<_Er>)
-      : _M_invalid(), _M_has_value(__x._M_has_value)
+      : _M_has_value(__x._M_has_value)
       {
 	if (_M_has_value)
 	  std::construct_at(__builtin_addressof(_M_val),
@@ -394,7 +393,7 @@ namespace __expected
 	expected(const expected<_Up, _Gr>& __x)
 	noexcept(__and_v<is_nothrow_constructible<_Tp, const _Up&>,
 			 is_nothrow_constructible<_Er, const _Gr&>>)
-	: _M_invalid(), _M_has_value(__x._M_has_value)
+	: _M_has_value(__x._M_has_value)
 	{
 	  if (_M_has_value)
 	    std::construct_at(__builtin_addressof(_M_val), __x._M_val);
@@ -410,7 +409,7 @@ namespace __expected
 	expected(expected<_Up, _Gr>&& __x)
 	noexcept(__and_v<is_nothrow_constructible<_Tp, _Up>,
 			 is_nothrow_constructible<_Er, _Gr>>)
-	: _M_invalid(), _M_has_value(__x._M_has_value)
+	: _M_has_value(__x._M_has_value)
 	{
 	  if (_M_has_value)
 	    std::construct_at(__builtin_addressof(_M_val),
@@ -798,8 +797,8 @@ namespace __expected
 	requires (!is_void_v<_Up>)
 	friend constexpr bool
 	operator==(const expected& __x, const expected<_Up, _Er2>& __y)
-	noexcept(noexcept(bool(*__x == *__y))
-		  && noexcept(bool(__x.error() == __y.error())))
+	// FIXME: noexcept(noexcept(bool(*__x == *__y))
+		  // && noexcept(bool(__x.error() == __y.error())))
 	{
 	  if (__x.has_value())
 	    return __y.has_value() && bool(*__x == *__y);
@@ -810,13 +809,13 @@ namespace __expected
       template<typename _Up>
 	friend constexpr bool
 	operator==(const expected& __x, const _Up& __v)
-	noexcept(noexcept(bool(*__x == __v)))
+	// FIXME: noexcept(noexcept(bool(*__x == __v)))
 	{ return __x.has_value() && bool(*__x == __v); }
 
       template<typename _Er2>
 	friend constexpr bool
 	operator==(const expected& __x, const unexpected<_Er2>& __e)
-	noexcept(noexcept(bool(__x.error() == __e.error())))
+	// FIXME: noexcept(noexcept(bool(__x.error() == __e.error())))
 	{ return !__x.has_value() && bool(__x.error() == __e.error()); }
 
       friend constexpr void
@@ -878,7 +877,7 @@ namespace __expected
 	  }
 	else
 	  {
-	    __expected::_Guard<_Tp> __guard(__rhs._M_val);
+	    __expected::_Guard<_Tp> __guard(_M_val);
 	    std::construct_at(__builtin_addressof(_M_unex),
 			      std::move(__rhs._M_unex)); // might throw
 	    _M_has_value = false;
@@ -890,7 +889,6 @@ namespace __expected
       }
 
       union {
-	struct { } _M_invalid;
 	_Tp _M_val;
 	_Er _M_unex;
       };
@@ -1188,7 +1186,7 @@ namespace __expected
 	requires is_void_v<_Up>
 	friend constexpr bool
 	operator==(const expected& __x, const expected<_Up, _Er2>& __y)
-	noexcept(noexcept(bool(__x.error() == __y.error())))
+	// FIXME: noexcept(noexcept(bool(__x.error() == __y.error())))
 	{
 	  if (__x.has_value())
 	    return __y.has_value();
@@ -1199,7 +1197,7 @@ namespace __expected
       template<typename _Er2>
 	friend constexpr bool
 	operator==(const expected& __x, const unexpected<_Er2>& __e)
-	noexcept(noexcept(bool(__x.error() == __e.error())))
+	// FIXME: noexcept(noexcept(bool(__x.error() == __e.error())))
 	{ return !__x.has_value() && bool(__x.error() == __e.error()); }
 
       friend constexpr void
diff --git a/libstdc++-v3/include/std/functional b/libstdc++-v3/include/std/functional
index 685a3e167ee..0ed0578a24b 100644
--- a/libstdc++-v3/include/std/functional
+++ b/libstdc++-v3/include/std/functional
@@ -461,6 +461,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   /// @endcond
 
+#if __cplusplus == 201703L && _GLIBCXX_USE_DEPRECATED
+# define _GLIBCXX_VOLATILE_BIND
+// _GLIBCXX_RESOLVE_LIB_DEFECTS
+// 2487. bind() should be const-overloaded, not cv-overloaded
+# define _GLIBCXX_DEPR_BIND \
+      [[deprecated("std::bind does not support volatile in C++17")]]
+#elif __cplusplus < 201703L
+# define _GLIBCXX_VOLATILE_BIND
+# define _GLIBCXX_DEPR_BIND
+#endif
+
   /// Type of the function object returned from bind().
   template<typename _Signature>
     class _Bind;
@@ -497,6 +508,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      );
 	}
 
+#ifdef _GLIBCXX_VOLATILE_BIND
       // Call as volatile
       template<typename _Result, typename... _Args, std::size_t... _Indexes>
 	_Result
@@ -518,6 +530,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
 	      );
 	}
+#endif // volatile
 
       template<typename _BoundArg, typename _CallArgs>
 	using _Mu_type = decltype(
@@ -581,12 +594,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      _Bound_indexes());
 	}
 
-#if __cplusplus > 201402L
-# define _GLIBCXX_DEPR_BIND \
-      [[deprecated("std::bind does not support volatile in C++17")]]
-#else
-# define _GLIBCXX_DEPR_BIND
-#endif
+#ifdef _GLIBCXX_VOLATILE_BIND
       // Call as volatile
       template<typename... _Args,
 	       typename _Result = _Res_type_cv<tuple<_Args...>, add_volatile>>
@@ -610,6 +618,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      std::forward_as_tuple(std::forward<_Args>(__args)...),
 	      _Bound_indexes());
 	}
+#endif // volatile
     };
 
   /// Type of the function object returned from bind<R>().
@@ -645,9 +654,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		      (std::get<_Indexes>(_M_bound_args), __args)...);
 	}
 
+#ifdef _GLIBCXX_VOLATILE_BIND
       // Call as volatile
       template<typename _Res, typename... _Args, std::size_t... _Indexes>
-	_GLIBCXX20_CONSTEXPR
 	_Res
 	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) volatile
 	{
@@ -657,7 +666,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       // Call as const volatile
       template<typename _Res, typename... _Args, std::size_t... _Indexes>
-	_GLIBCXX20_CONSTEXPR
 	_Res
 	__call(tuple<_Args...>&& __args,
 	       _Index_tuple<_Indexes...>) const volatile
@@ -665,6 +673,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return std::__invoke_r<_Res>(_M_f, _Mu<_Bound_args>()
 		      (__volget<_Indexes>(_M_bound_args), __args)...);
 	}
+#endif // volatile
 
     public:
       typedef _Result result_type;
@@ -706,6 +715,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      _Bound_indexes());
 	}
 
+#ifdef _GLIBCXX_VOLATILE_BIND
       // Call as volatile
       template<typename... _Args>
 	_GLIBCXX_DEPR_BIND
@@ -727,7 +737,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      std::forward_as_tuple(std::forward<_Args>(__args)...),
 	      _Bound_indexes());
 	}
+#else
+      template<typename... _Args>
+	void operator()(_Args&&...) const volatile = delete;
+#endif // volatile
     };
+
+#undef _GLIBCXX_VOLATILE_BIND
 #undef _GLIBCXX_DEPR_BIND
 
   /**
diff --git a/libstdc++-v3/include/std/future b/libstdc++-v3/include/std/future
index 3bdbc636f69..6cda28c84cf 100644
--- a/libstdc++-v3/include/std/future
+++ b/libstdc++-v3/include/std/future
@@ -1659,7 +1659,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	explicit
 	_Deferred_state(_Args&&... __args)
 	: _M_result(new _Result<_Res>()),
-	  _M_fn{{std::forward<_Args>(__args)...}}
+	  _M_fn(std::forward<_Args>(__args)...)
 	{ }
 
     private:
@@ -1726,7 +1726,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	explicit
 	_Async_state_impl(_Args&&... __args)
 	: _M_result(new _Result<_Res>()),
-	  _M_fn{{std::forward<_Args>(__args)...}}
+	  _M_fn(std::forward<_Args>(__args)...)
 	{
 	  _M_thread = std::thread{&_Async_state_impl::_M_run, this};
 	}
diff --git a/libstdc++-v3/include/std/memory b/libstdc++-v3/include/std/memory
index 481fa42a618..20a55020a36 100644
--- a/libstdc++-v3/include/std/memory
+++ b/libstdc++-v3/include/std/memory
@@ -60,7 +60,6 @@
  * Smart pointers, etc.
  */
 
-#include <bits/stl_algobase.h>
 #include <bits/allocator.h>
 #include <bits/stl_construct.h>
 #include <bits/stl_uninitialized.h>
diff --git a/libstdc++-v3/include/std/stacktrace b/libstdc++-v3/include/std/stacktrace
index 8e6c79a2f4f..a067d629a16 100644
--- a/libstdc++-v3/include/std/stacktrace
+++ b/libstdc++-v3/include/std/stacktrace
@@ -600,8 +600,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    {
 	      if constexpr (is_same_v<allocator_type, allocator<value_type>>)
 		{
-		  __n *= sizeof(value_type);
-		  void* const __p = _GLIBCXX_OPERATOR_NEW (__n, nothrow_t{});
+		  // For std::allocator we use nothrow-new directly so we
+		  // don't need to handle bad_alloc exceptions.
+		  size_t __nb = __n * sizeof(value_type);
+		  void* const __p = _GLIBCXX_OPERATOR_NEW (__nb, nothrow_t{});
 		  if (__p == nullptr) [[unlikely]]
 		    return nullptr;
 		  _M_frames = static_cast<pointer>(__p);
diff --git a/libstdc++-v3/include/std/type_traits b/libstdc++-v3/include/std/type_traits
index 2572d8edd69..d4e7200123c 100644
--- a/libstdc++-v3/include/std/type_traits
+++ b/libstdc++-v3/include/std/type_traits
@@ -1517,12 +1517,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
 #pragma GCC diagnostic pop
 
-  // is_nothrow_convertible for C++11
-  template<typename _From, typename _To>
-    struct __is_nothrow_convertible
-    : public __is_nt_convertible_helper<_From, _To>::type
-    { };
-
 #if __cplusplus > 201703L
 #define __cpp_lib_is_nothrow_convertible 201806L
   /// is_nothrow_convertible
@@ -2906,7 +2900,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // The primary template is used for invalid INVOKE expressions.
   template<typename _Result, typename _Ret,
 	   bool = is_void<_Ret>::value, typename = void>
-    struct __is_invocable_impl : false_type { };
+    struct __is_invocable_impl
+    : false_type
+    {
+      using __nothrow_type = false_type; // For is_nothrow_invocable_r
+    };
 
   // Used for valid INVOKE and INVOKE<void> expressions.
   template<typename _Result, typename _Ret>
@@ -2914,7 +2912,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			       /* is_void<_Ret> = */ true,
 			       __void_t<typename _Result::type>>
     : true_type
-    { };
+    {
+      using __nothrow_type = true_type; // For is_nothrow_invocable_r
+    };
 
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
@@ -2926,23 +2926,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
     private:
       // The type of the INVOKE expression.
-      // Unlike declval, this doesn't add_rvalue_reference.
-      static typename _Result::type _S_get();
+      // Unlike declval, this doesn't add_rvalue_reference, so it respects
+      // guaranteed copy elision.
+      static typename _Result::type _S_get() noexcept;
 
       template<typename _Tp>
-	static void _S_conv(_Tp);
+	static void _S_conv(_Tp) noexcept;
 
       // This overload is viable if INVOKE(f, args...) can convert to _Tp.
-      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
-	static true_type
+      template<typename _Tp, bool _Check_Noex = false,
+	       typename = decltype(_S_conv<_Tp>(_S_get())),
+	       bool _Noex = noexcept(_S_conv<_Tp>(_S_get()))>
+	static __bool_constant<_Check_Noex ? _Noex : true>
 	_S_test(int);
 
-      template<typename _Tp>
+      template<typename _Tp, bool = false>
 	static false_type
 	_S_test(...);
 
     public:
+      // For is_invocable_r
       using type = decltype(_S_test<_Ret>(1));
+
+      // For is_nothrow_invocable_r
+      using __nothrow_type = decltype(_S_test<_Ret, true>(1));
     };
 #pragma GCC diagnostic pop
 
@@ -3073,15 +3080,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
 
   /// @cond undocumented
-  template<typename _Result, typename _Ret, typename = void>
-    struct __is_nt_invocable_impl : false_type { };
-
   template<typename _Result, typename _Ret>
-    struct __is_nt_invocable_impl<_Result, _Ret,
-				  __void_t<typename _Result::type>>
-    : __or_<is_void<_Ret>,
-	    __is_nothrow_convertible<typename _Result::type, _Ret>>
-    { };
+    using __is_nt_invocable_impl
+      = typename __is_invocable_impl<_Result, _Ret>::__nothrow_type;
   /// @endcond
 
   /// std::is_nothrow_invocable_r
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
index beed396fccb..df0dd08d90a 100644
--- a/libstdc++-v3/include/std/variant
+++ b/libstdc++-v3/include/std/variant
@@ -1730,7 +1730,12 @@ namespace __variant
     {
       // Get the silly case of visiting no variants out of the way first.
       if constexpr (sizeof...(_Variants) == 0)
-	return std::forward<_Visitor>(__visitor)();
+	{
+	  if constexpr (is_void_v<_Result_type>)
+	    return (void) std::forward<_Visitor>(__visitor)();
+	  else
+	    return std::forward<_Visitor>(__visitor)();
+	}
       else
 	{
 	  constexpr size_t __max = 11; // "These go to eleven."
diff --git a/libstdc++-v3/libsupc++/eh_globals.cc b/libstdc++-v3/libsupc++/eh_globals.cc
index 768425c0f40..0aadb692a96 100644
--- a/libstdc++-v3/libsupc++/eh_globals.cc
+++ b/libstdc++-v3/libsupc++/eh_globals.cc
@@ -119,8 +119,13 @@ struct __eh_globals_init
   ~__eh_globals_init()
   {
     if (_S_init)
-      __gthread_key_delete(_M_key);
-    _S_init = false;
+      {
+	/* Set it before the call, so that, should
+	   __gthread_key_delete throw an exception, it won't rely on
+	   the key being deleted.  */
+	_S_init = false;
+	__gthread_key_delete(_M_key);
+      }
   }
 
   __eh_globals_init(const __eh_globals_init&) = delete;
diff --git a/libstdc++-v3/src/c++11/compatibility-condvar.cc b/libstdc++-v3/src/c++11/compatibility-condvar.cc
index ea3e11efeda..45339c58aef 100644
--- a/libstdc++-v3/src/c++11/compatibility-condvar.cc
+++ b/libstdc++-v3/src/c++11/compatibility-condvar.cc
@@ -63,6 +63,24 @@ _GLIBCXX_END_NAMESPACE_VERSION
     && defined(_GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT)
 namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
 {
+namespace
+{
+  // Pointer-to-member for private std::condition_variable::_M_cond member.
+  std::__condvar std::condition_variable::* __base_member;
+
+  template<std::__condvar std::condition_variable::*X>
+    struct cracker
+    { static std::__condvar std::condition_variable::* value; };
+
+  // Initializer for this static member also initializes __base_member.
+  template<std::__condvar std::condition_variable::*X>
+    std::__condvar std::condition_variable::*
+      cracker<X>::value = __base_member = X;
+
+  // Explicit instantiation is allowed to access the private member.
+  template class cracker<&std::condition_variable::_M_cond>;
+}
+
 struct __nothrow_wait_cv : std::condition_variable
 {
   void wait(std::unique_lock<std::mutex>&) noexcept;
@@ -72,7 +90,9 @@ __attribute__((used))
 void
 __nothrow_wait_cv::wait(std::unique_lock<std::mutex>& lock) noexcept
 {
-  this->condition_variable::wait(lock);
+  // In theory this could be simply this->std::condition_variable::wait(lock)
+  // but with uclibc that binds to the @GLIBCXX_3.4.11 symbol, see PR 105730.
+  (this->*__base_member).wait(*lock.mutex());
 }
 } // namespace __gnu_cxx
 
diff --git a/libstdc++-v3/src/c++17/memory_resource.cc b/libstdc++-v3/src/c++17/memory_resource.cc
index bb6334c9694..d6555aa8823 100644
--- a/libstdc++-v3/src/c++17/memory_resource.cc
+++ b/libstdc++-v3/src/c++17/memory_resource.cc
@@ -874,9 +874,11 @@ namespace pmr
       256, 320, 384, 448,
       512, 768,
 #if __SIZE_WIDTH__ > 16
+      // Use bigger pools if size_t has at least 20 bits.
       1024, 1536,
       2048, 3072,
-#if __SIZE_WIDTH__ > 20
+#if __INT_WIDTH__ >= 32
+      // Use even bigger pools if int has at least 32 bits.
       1<<12, 1<<13, 1<<14,
       1<<15, 1<<16, 1<<17,
       1<<20, 1<<21, 1<<22 // 4MB should be enough for anybody
diff --git a/libstdc++-v3/testsuite/20_util/bind/cv_quals.cc b/libstdc++-v3/testsuite/20_util/bind/cv_quals.cc
index 83312397a93..79e3e2fbdb4 100644
--- a/libstdc++-v3/testsuite/20_util/bind/cv_quals.cc
+++ b/libstdc++-v3/testsuite/20_util/bind/cv_quals.cc
@@ -17,6 +17,7 @@
 
 // 20.7.11 Function template bind
 
+// { dg-options "-Wdeprecated-declarations" }
 // { dg-do run { target c++11 } }
 
 #include <functional>
@@ -48,12 +49,12 @@ void test01()
   const auto b1 = std::bind(X());
   VERIFY( b1() == 1 );
 
-#if __cplusplus <= 201402L
+#if __cplusplus <= 201703L
   volatile auto b2 = std::bind(X());
-  VERIFY( b2() == 2 );
+  VERIFY( b2() == 2 ); // { dg-warning "deprecated" "" { target c++17_only } }
 
   const volatile auto b3 = std::bind(X());
-  VERIFY( b3() == 3 );
+  VERIFY( b3() == 3 ); // { dg-warning "deprecated" "" { target c++17_only } }
 #endif
 }
 
@@ -65,12 +66,12 @@ void test02()
   const auto b1 = std::bind<int>(X());
   VERIFY( b1() == 1 );
 
-#if __cplusplus <= 201402L
+#if __cplusplus <= 201703L
   volatile auto b2 = std::bind<int>(X());
-  VERIFY( b2() == 2 );
+  VERIFY( b2() == 2 ); // { dg-warning "deprecated" "" { target c++17_only } }
 
   const volatile auto b3 = std::bind<int>(X());
-  VERIFY( b3() == 3 );
+  VERIFY( b3() == 3 ); // { dg-warning "deprecated" "" { target c++17_only } }
 #endif
 }
 
@@ -82,12 +83,12 @@ void test03()
   const auto b1 = std::bind(X(), _1, 0, _2);
   VERIFY( b1(0, 0) == 1 );
 
-#if __cplusplus <= 201402L
+#if __cplusplus <= 201703L
   volatile auto b2 = std::bind(X(), _1, _2, 0);
-  VERIFY( b2(0, 0) == 2 );
+  VERIFY( b2(0, 0) == 2 ); // { dg-warning "deprecated" "" { target c++17_only } }
 
   const volatile auto b3 = std::bind(X(), _1, 0, _2);
-  VERIFY( b3(0, 0) == 3 );
+  VERIFY( b3(0, 0) == 3 ); // { dg-warning "deprecated" "" { target c++17_only } }
 #endif
 }
 
@@ -99,12 +100,12 @@ void test04()
   const auto b1 = std::bind<int>(X(), _1, 0, _2);
   VERIFY( b1(0, 0) == 1 );
 
-#if __cplusplus <= 201402L
+#if __cplusplus <= 201703L
   volatile auto b2 = std::bind<int>(X(), _1, _2, 0);
-  VERIFY( b2(0, 0) == 2 );
+  VERIFY( b2(0, 0) == 2 ); // { dg-warning "deprecated" "" { target c++17_only } }
 
   const volatile auto b3 = std::bind<int>(X(), _1, 0, _2);
-  VERIFY( b3(0, 0) == 3 );
+  VERIFY( b3(0, 0) == 3 ); // { dg-warning "deprecated" "" { target c++17_only } }
 #endif
 }
 
diff --git a/libstdc++-v3/testsuite/20_util/bind/cv_quals_2.cc b/libstdc++-v3/testsuite/20_util/bind/cv_quals_2.cc
index 7a85568c66a..d2ebad72fdf 100644
--- a/libstdc++-v3/testsuite/20_util/bind/cv_quals_2.cc
+++ b/libstdc++-v3/testsuite/20_util/bind/cv_quals_2.cc
@@ -15,7 +15,9 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-do run { target c++11 } }
+// { dg-options "-Wdeprecated-declarations" }
+// { dg-do run { target { c++11 && c++17_down } } }
+// { dg-do compile { target c++20 } }
 
 #include <functional>
 #include <testsuite_hooks.h>
@@ -33,13 +35,13 @@ void test01()
   const auto b0 = std::bind(X());
   VERIFY( b0() == 0 );
 
-#if __cplusplus <= 201402L
   volatile auto b1 = std::bind(X());
-  VERIFY( b1() == 1 );
+  VERIFY( b1() == 1 ); // { dg-warning "deprecated" "" { target c++17_only } }
+		       // { dg-error "no match" "" { target c++20 } 39 }
 
   const volatile auto b2 = std::bind(X());
-  VERIFY( b2() == 2 );
-#endif
+  VERIFY( b2() == 2 ); // { dg-warning "deprecated" "" { target c++17_only } }
+		       // { dg-error "no match" "" { target c++20 } 43 }
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/20_util/expected/equality.cc b/libstdc++-v3/testsuite/20_util/expected/equality.cc
new file mode 100644
index 00000000000..1862719e73d
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/expected/equality.cc
@@ -0,0 +1,49 @@
+// { dg-options "-std=gnu++23" }
+// { dg-do compile { target c++23 } }
+
+#include <expected>
+#include <testsuite_hooks.h>
+
+template<typename T, typename U>
+concept Eq = requires(T t, U u) { t == u; };
+
+static_assert(Eq<std::expected<int, long>, std::expected<short, unsigned>>);
+static_assert(Eq<std::expected<void, long>, std::expected<void, unsigned>>);
+// static_assert(!Eq<std::expected<void, long>, std::expected<short, unsigned>>);
+static_assert(Eq<std::expected<int, long>, short>);
+static_assert(!Eq<std::expected<void, long>, short>);
+static_assert(Eq<std::expected<int, long>, std::unexpected<short>>);
+static_assert(Eq<std::expected<void, long>, std::unexpected<short>>);
+
+struct NotEqCmp
+{
+  constexpr bool operator==(int) const { return true; }
+  bool operator==(NotEqCmp) const = delete;
+};
+
+constexpr bool
+test_eq()
+{
+  std::expected<NotEqCmp, int> e1;
+  VERIFY(e1 == 1);
+  std::expected<int, int> e2;
+  VERIFY(e2 == e2);
+  VERIFY(e1 == e2);
+  VERIFY(e1 != std::unexpected<int>(1));
+  e1 = std::unexpected<int>(1);
+  VERIFY(e1 == std::unexpected<int>(1));
+  VERIFY(e1 != std::unexpected<int>(2));
+  VERIFY(e1 != e2);
+
+  std::expected<void, int> e3;
+  VERIFY(e3 == e3);
+  VERIFY(e3 != std::unexpected<int>(1));
+  e3 = std::unexpected<int>(1);
+  VERIFY(e3 == e3);
+  VERIFY(e3 == std::unexpected<int>(1));
+  VERIFY(e3 != std::unexpected<int>(2));
+
+  return true;
+}
+
+static_assert( test_eq() );
diff --git a/libstdc++-v3/testsuite/20_util/expected/swap.cc b/libstdc++-v3/testsuite/20_util/expected/swap.cc
index 745db65fc6c..08a110da47c 100644
--- a/libstdc++-v3/testsuite/20_util/expected/swap.cc
+++ b/libstdc++-v3/testsuite/20_util/expected/swap.cc
@@ -4,8 +4,18 @@
 #include <expected>
 #include <testsuite_hooks.h>
 
+struct NonTrivial
+{
+  constexpr NonTrivial(int i) : i(i) { }
+  constexpr NonTrivial(const NonTrivial& x) noexcept(false): i(x.i) { }
+  constexpr ~NonTrivial() { }
+  int i;
+
+  constexpr bool operator==(const NonTrivial&) const = default;
+};
+
 constexpr bool
-test_swap()
+test_swap_obj()
 {
   std::expected<int, int> e1(1), e2(2);
   std::expected<int, int> e3(std::unexpect, 3), e4(std::unexpect, 4);
@@ -27,6 +37,52 @@ test_swap()
   VERIFY( e3.error() == 4 );
   VERIFY( e4.error() == 3 );
 
+  std::expected<int, NonTrivial> e5(1), e6(2);
+  std::expected<int, NonTrivial> e7(std::unexpect, 3), e8(std::unexpect, 4);
+
+  swap(e5, e6);
+  VERIFY( e5.value() == 2 );
+  VERIFY( e6.value() == 1 );
+  swap(e5, e7);
+  VERIFY( ! e5.has_value() );
+  VERIFY( e5.error() == 3 );
+  VERIFY( e7.value() == 2 );
+  swap(e5, e7);
+  VERIFY( ! e7.has_value() );
+  VERIFY( e5.value() == 2 );
+  VERIFY( e7.error() == 3 );
+  swap(e7, e8);
+  VERIFY( ! e7.has_value() );
+  VERIFY( ! e8.has_value() );
+  VERIFY( e7.error() == 4 );
+  VERIFY( e8.error() == 3 );
+
+  std::expected<NonTrivial, int> e9(1), e10(2);
+  std::expected<NonTrivial, int> e11(std::unexpect, 3), e12(std::unexpect, 4);
+
+  swap(e9, e10);
+  VERIFY( e9.value() == 2 );
+  VERIFY( e10.value() == 1 );
+  swap(e9, e11);
+  VERIFY( ! e9.has_value() );
+  VERIFY( e9.error() == 3 );
+  VERIFY( e11.value() == 2 );
+  swap(e9, e11);
+  VERIFY( ! e11.has_value() );
+  VERIFY( e9.value() == 2 );
+  VERIFY( e11.error() == 3 );
+  swap(e11, e12);
+  VERIFY( ! e11.has_value() );
+  VERIFY( ! e12.has_value() );
+  VERIFY( e11.error() == 4 );
+  VERIFY( e12.error() == 3 );
+
+  return true;
+}
+
+constexpr bool
+test_swap_void()
+{
   std::expected<void, int> v1, v2;
   std::expected<void, int> v3(std::unexpect, 3), v4(std::unexpect, 4);
 
@@ -47,11 +103,41 @@ test_swap()
   VERIFY( v3.error() == 4 );
   VERIFY( v4.error() == 3 );
 
+  std::expected<void, NonTrivial> v5, v6;
+  std::expected<void, NonTrivial> v7(std::unexpect, 3), v8(std::unexpect, 4);
+
+  swap(v5, v6);
+  VERIFY( v5.has_value() );
+  VERIFY( v6.has_value() );
+  swap(v5, v7);
+  VERIFY( ! v5.has_value() );
+  VERIFY( v5.error() == 3 );
+  VERIFY( v7.has_value() );
+  swap(v5, v7);
+  VERIFY( ! v7.has_value() );
+  VERIFY( v5.has_value() );
+  VERIFY( v7.error() == 3 );
+  swap(v7, v8);
+  VERIFY( ! v7.has_value() );
+  VERIFY( ! v8.has_value() );
+  VERIFY( v7.error() == 4 );
+  VERIFY( v8.error() == 3 );
+
   return true;
 }
 
+static_assert( std::is_swappable_v<std::expected<int, int>> );
+static_assert( std::is_swappable_v<std::expected<void, int>> );
+
+struct A { A& operator=(A&&) = delete; };
+static_assert( ! std::is_swappable_v<std::expected<A, int>> );
+static_assert( ! std::is_swappable_v<std::expected<int, A>> );
+static_assert( ! std::is_swappable_v<std::expected<void, A>> );
+
 int main()
 {
-  static_assert( test_swap() );
-  test_swap();
+  static_assert( test_swap_obj() );
+  test_swap_obj();
+  static_assert( test_swap_void() );
+  test_swap_void();
 }
diff --git a/libstdc++-v3/testsuite/20_util/expected/unexpected.cc b/libstdc++-v3/testsuite/20_util/expected/unexpected.cc
index d4cbeadf674..050f8e3e81f 100644
--- a/libstdc++-v3/testsuite/20_util/expected/unexpected.cc
+++ b/libstdc++-v3/testsuite/20_util/expected/unexpected.cc
@@ -73,6 +73,10 @@ test()
   return true;
 }
 
+static_assert( std::is_swappable_v<std::unexpected<int>> );
+struct A { A& operator=(A&&) = delete; };
+static_assert( ! std::is_swappable_v<std::unexpected<A>> );
+
 int main()
 {
   static_assert( test() );
diff --git a/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value.cc b/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value.cc
index e9aded73624..a2686285052 100644
--- a/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value.cc
+++ b/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value.cc
@@ -21,9 +21,7 @@
 #include <type_traits>
 #include <testsuite_tr1.h>
 
-#ifndef IS_NT_CONVERTIBLE_DEFINED
 using std::is_nothrow_convertible;
-#endif
 
 void test01()
 {
diff --git a/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value_ext.cc b/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/91456.cc
similarity index 59%
rename from libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value_ext.cc
rename to libstdc++-v3/testsuite/20_util/is_nothrow_invocable/91456.cc
index 0f896428537..abbbd1aade4 100644
--- a/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value_ext.cc
+++ b/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/91456.cc
@@ -15,14 +15,21 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-do compile { target c++11 } }
+// { dg-do compile { target c++17 } }
+
+// PR 91456
+// std::function and std::is_invocable_r do not understand guaranteed elision
 
 #include <type_traits>
 
-// Test the non-standard __is_nothrow_convertible trait
+#include <functional>
 
-template<typename From, typename To>
-  using is_nothrow_convertible = std::__is_nothrow_convertible<From, To>;
+struct Immovable {
+  Immovable() = default;
+  Immovable(const Immovable&) = delete;
+  Immovable& operator=(const Immovable&) = delete;
+};
 
-#define IS_NT_CONVERTIBLE_DEFINED
-#include "value.cc"
+static_assert(std::is_nothrow_invocable_r_v<Immovable, Immovable(*)() noexcept>);
+static_assert(std::is_nothrow_invocable_r_v<const Immovable, Immovable(*)() noexcept>);
+static_assert(std::is_nothrow_invocable_r_v<Immovable, const Immovable(*)() noexcept>);
diff --git a/libstdc++-v3/testsuite/20_util/move_only_function/call.cc b/libstdc++-v3/testsuite/20_util/move_only_function/call.cc
index 9ca0a60a24e..0c7f58d77a0 100644
--- a/libstdc++-v3/testsuite/20_util/move_only_function/call.cc
+++ b/libstdc++-v3/testsuite/20_util/move_only_function/call.cc
@@ -190,10 +190,21 @@ test04()
   VERIFY( std::move(std::as_const(f5))() == 3 );
 }
 
+struct Incomplete;
+
+void
+test_params()
+{
+  std::move_only_function<void(Incomplete)> f1;
+  std::move_only_function<void(Incomplete&)> f2;
+  std::move_only_function<void(Incomplete&&)> f3;
+}
+
 int main()
 {
   test01();
   test02();
   test03();
   test04();
+  test_params();
 }
diff --git a/libstdc++-v3/testsuite/20_util/tuple/swap.cc b/libstdc++-v3/testsuite/20_util/tuple/swap.cc
index c086a4f1a8e..30c8322f01c 100644
--- a/libstdc++-v3/testsuite/20_util/tuple/swap.cc
+++ b/libstdc++-v3/testsuite/20_util/tuple/swap.cc
@@ -38,7 +38,7 @@ struct MoveOnly
   MoveOnly(MoveOnly const&) = delete;
   MoveOnly& operator=(MoveOnly const&) = delete;
 
-  bool operator==(MoveOnly const& m)
+  bool operator==(MoveOnly const& m) const
   { return i == m.i; }
 
   void swap(MoveOnly& m)
diff --git a/libstdc++-v3/testsuite/20_util/variant/visit_r.cc b/libstdc++-v3/testsuite/20_util/variant/visit_r.cc
index 712459f25e3..c77b259c386 100644
--- a/libstdc++-v3/testsuite/20_util/variant/visit_r.cc
+++ b/libstdc++-v3/testsuite/20_util/variant/visit_r.cc
@@ -54,10 +54,18 @@ void test02()
   std::visit<const void>(Visitor(), v);
 }
 
+void test03()
+{
+  // PR libstdc++/106589 - visit<void> rejects lambdas that do not return void
+  auto visitor = []{ return 0; };
+  std::visit<void>(visitor);
+  std::visit<void>(static_cast<int(*)()>(visitor));
+}
 
 int
 main()
 {
   test01();
   test02();
+  test03();
 }
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/87641.cc b/libstdc++-v3/testsuite/26_numerics/valarray/87641.cc
index 38c35851716..4a6e402831d 100644
--- a/libstdc++-v3/testsuite/26_numerics/valarray/87641.cc
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/87641.cc
@@ -39,7 +39,7 @@ struct X
   X() : val(1) { }
 
   X& operator+=(const X& x) { val += x.val; return *this; }
-  bool operator==(const X& x) { return val == x.val; }
+  bool operator==(const X& x) const { return val == x.val; }
 
   int val;
 };
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/106201.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/106201.cc
new file mode 100644
index 00000000000..c5fefd9ac3f
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/106201.cc
@@ -0,0 +1,14 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+// { dg-require-filesystem-ts "" }
+
+// PR libstdc++/106201 constraint recursion in path(Source const&) constructor.
+
+#include <filesystem>
+#include <iterator>
+#include <concepts>
+namespace fs = std::filesystem;
+using I = std::counted_iterator<fs::directory_iterator>;
+static_assert( std::swappable<I> );
+using R = std::counted_iterator<fs::recursive_directory_iterator>;
+static_assert( std::swappable<R> );
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/lwg3719.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/lwg3719.cc
new file mode 100644
index 00000000000..c19cddc74f9
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/lwg3719.cc
@@ -0,0 +1,39 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do run { target c++20 } }
+// { dg-require-filesystem-ts "" }
+
+#include <filesystem>
+#include <iterator>
+#include <testsuite_hooks.h>
+
+// LWG 3719. Directory iterators should be usable with default sentinel
+
+void
+test_dir_iter()
+{
+  std::filesystem::directory_iterator d0;
+  VERIFY( d0 == std::default_sentinel );
+  std::filesystem::directory_iterator d1(".");
+  VERIFY( d1 != std::default_sentinel );
+
+  static_assert( noexcept(d0 == std::default_sentinel) );
+  static_assert( noexcept(d0 != std::default_sentinel) );
+}
+
+void
+test_recursive_dir_iter()
+{
+  std::filesystem::recursive_directory_iterator d0;
+  VERIFY( d0 == std::default_sentinel );
+  std::filesystem::recursive_directory_iterator d1(".");
+  VERIFY( d1 != std::default_sentinel );
+
+  static_assert( noexcept(d0 == std::default_sentinel) );
+  static_assert( noexcept(d0 != std::default_sentinel) );
+}
+
+int main()
+{
+  test_dir_iter();
+  test_recursive_dir_iter();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/construct/95048.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/95048.cc
new file mode 100644
index 00000000000..c1a382d1420
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/95048.cc
@@ -0,0 +1,45 @@
+// { dg-do run { target c++17 } }
+
+// C++17 30.10.8.4.1 path constructors [fs.path.construct]
+
+#include <filesystem>
+#include <testsuite_hooks.h>
+
+using std::filesystem::path;
+
+#define CHECK(E, S) (path(E##S) == path(u8##S))
+
+void
+test_wide()
+{
+  VERIFY( CHECK(L, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(L, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(L, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(L, "\U0001F4C4") ); // filing cabient
+}
+
+void
+test_u16()
+{
+  VERIFY( CHECK(u, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(u, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(u, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(u, "\U0001F4C4") ); // filing cabient
+}
+
+void
+test_u32()
+{
+  VERIFY( CHECK(U, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(U, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(U, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(U, "\U0001F4C4") ); // filing cabient
+}
+
+int
+main()
+{
+  test_wide();
+  test_u16();
+  test_u32();
+}
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/106607.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/106607.cc
new file mode 100644
index 00000000000..f8e7fb2364d
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/106607.cc
@@ -0,0 +1,25 @@
+// { dg-do run { target c++11 } }
+
+#include <regex>
+#include <string>
+#include <climits>
+#include <testsuite_hooks.h>
+
+// PR libstdc++/106607 - Regex integer overflow on large backreference value
+
+int main()
+{
+  std::regex r("(.)\\1"); // OK
+
+  try
+  {
+    long long n = (unsigned)-1 + 2LL;          // 4294967297 for 32-bit int
+    VERIFY( (int)n == 1 );                     // 4294967297 % 2^32 == 1
+    std::regex r("(.)\\" + std::to_string(n)); // Invalid back reference.
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+    VERIFY( e.code() == std::regex_constants::error_backref );
+  }
+}
diff --git a/libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/lwg3719.cc b/libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/lwg3719.cc
new file mode 100644
index 00000000000..e8c8f79364a
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/lwg3719.cc
@@ -0,0 +1,29 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do run { target c++20 } }
+
+#include <regex>
+#include <iterator>
+#include <testsuite_hooks.h>
+
+// LWG 3719. Directory iterators should be usable with default sentinel
+
+void
+test_iter()
+{
+  std::sregex_token_iterator r0;
+  VERIFY( r0 == std::default_sentinel );
+  std::string haystack = "a needle in a haystack";
+  std::regex needle("needle");
+  std::sregex_iterator r1(haystack.begin(), haystack.end(), needle);
+  VERIFY( r1 != std::default_sentinel );
+  ++r1;
+  VERIFY( r1 == std::default_sentinel );
+
+  static_assert( noexcept(r0 == std::default_sentinel) ); // GCC extension
+  static_assert( noexcept(r0 != std::default_sentinel) ); // GCC extension
+}
+
+int main()
+{
+  test_iter();
+}
diff --git a/libstdc++-v3/testsuite/28_regex/iterators/regex_token_iterator/lwg3719.cc b/libstdc++-v3/testsuite/28_regex/iterators/regex_token_iterator/lwg3719.cc
new file mode 100644
index 00000000000..5c36acead74
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/iterators/regex_token_iterator/lwg3719.cc
@@ -0,0 +1,29 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do run { target c++20 } }
+
+#include <regex>
+#include <iterator>
+#include <testsuite_hooks.h>
+
+// LWG 3719. Directory iterators should be usable with default sentinel
+
+void
+test_iter()
+{
+  std::sregex_iterator r0;
+  VERIFY( r0 == std::default_sentinel );
+  std::string haystack = "a needle in a haystack";
+  std::regex needle("needle");
+  std::sregex_iterator r1(haystack.begin(), haystack.end(), needle);
+  VERIFY( r1 != std::default_sentinel );
+  ++r1;
+  VERIFY( r1 == std::default_sentinel );
+
+  static_assert( noexcept(r0 == std::default_sentinel) ); // GCC extension
+  static_assert( noexcept(r0 != std::default_sentinel) ); // GCC extension
+}
+
+int main()
+{
+  test_iter();
+}
diff --git a/libstdc++-v3/testsuite/30_threads/async/106695.cc b/libstdc++-v3/testsuite/30_threads/async/106695.cc
new file mode 100644
index 00000000000..74996342dc7
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/async/106695.cc
@@ -0,0 +1,29 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-gthreads "" }
+
+// PR libstdc++/106695
+// Explicit copy constructor does not work for a parameter passed via std::async
+
+#include <future>
+
+struct A {
+  A() = default;
+  explicit A(const A&) = default;
+};
+
+void func(const A&) { }
+
+void
+test_async()
+{
+  (void) std::async(std::launch::async, func, A{});
+  (void) std::async(std::launch::deferred, func, A{});
+  (void) std::async(func, A{});
+}
+
+void
+test_task()
+{
+  std::packaged_task<void(const A&)> task(func);
+  task(A{});
+}
diff --git a/libstdc++-v3/testsuite/30_threads/thread/106695.cc b/libstdc++-v3/testsuite/30_threads/thread/106695.cc
new file mode 100644
index 00000000000..97e9e922d8e
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/thread/106695.cc
@@ -0,0 +1,21 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-gthreads "" }
+
+// PR libstdc++/106695
+// Explicit copy constructor does not work for a parameter passed via std::async
+
+#include <thread>
+
+struct A {
+  A() = default;
+  explicit A(const A&) = default;
+};
+
+void func(const A&) { }
+
+void
+test_thread()
+{
+  std::thread t(func, A{});
+  t.join();
+}
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/iterators/106201.cc b/libstdc++-v3/testsuite/experimental/filesystem/iterators/106201.cc
new file mode 100644
index 00000000000..017b72ef5f6
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/filesystem/iterators/106201.cc
@@ -0,0 +1,14 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+// { dg-require-filesystem-ts "" }
+
+// PR libstdc++/106201 constraint recursion in path(Source const&) constructor.
+
+#include <experimental/filesystem>
+#include <iterator>
+#include <concepts>
+namespace fs = std::experimental::filesystem;
+using I = std::counted_iterator<fs::directory_iterator>;
+static_assert( std::swappable<I> );
+using R = std::counted_iterator<fs::recursive_directory_iterator>;
+static_assert( std::swappable<R> );
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc b/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc
index f005b7d5293..aabed14679c 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc
@@ -29,35 +29,44 @@
 
 int choice;
 
-struct dirent global_dirent;
-
 extern "C" struct dirent* readdir(DIR*)
 {
+  // On some targets dirent::d_name is very small, but the OS allocates
+  // a trailing char array after the dirent struct. Emulate that here.
+  union State
+  {
+    struct dirent d;
+    char buf[sizeof(struct dirent) + 16] = {};
+  };
+
+  static State state;
+  char* d_name = state.buf + offsetof(struct dirent, d_name);
+
   switch (choice)
   {
   case 1:
-    global_dirent.d_ino = 999;
+    state.d.d_ino = 999;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_REG
-    global_dirent.d_type = DT_REG;
+    state.d.d_type = DT_REG;
 #endif
-    global_dirent.d_reclen = 0;
-    std::char_traits<char>::copy(global_dirent.d_name, "file", 5);
+    state.d.d_reclen = 0;
+    std::char_traits<char>::copy(d_name, "file", 5);
     choice = 0;
-    return &global_dirent;
+    return &state.d;
   case 2:
-    global_dirent.d_ino = 111;
+    state.d.d_ino = 111;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_DIR
-    global_dirent.d_type = DT_DIR;
+    state.d.d_type = DT_DIR;
 #endif
-    global_dirent.d_reclen = 60;
-    std::char_traits<char>::copy(global_dirent.d_name, "subdir", 7);
+    state.d.d_reclen = 60;
+    std::char_traits<char>::copy(d_name, "subdir", 7);
     choice = 1;
-    return &global_dirent;
+    return &state.d;
   default:
     errno = EIO;
     return nullptr;
   }
-  return &global_dirent;
+  return &state.d;
 }
 
 void
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/path/construct/95048.cc b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/95048.cc
new file mode 100644
index 00000000000..b7a93f3c985
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/95048.cc
@@ -0,0 +1,47 @@
+// { dg-options "-lstdc++fs" }
+// { dg-do run { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+// 8.4.1 path constructors [path.construct]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+#define CHECK(E, S) (path(E##S) == path(u8##S))
+
+void
+test_wide()
+{
+  VERIFY( CHECK(L, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(L, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(L, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(L, "\U0001F4C4") ); // filing cabient
+}
+
+void
+test_u16()
+{
+  VERIFY( CHECK(u, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(u, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(u, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(u, "\U0001F4C4") ); // filing cabient
+}
+
+void
+test_u32()
+{
+  VERIFY( CHECK(U, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(U, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(U, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(U, "\U0001F4C4") ); // filing cabient
+}
+
+int
+main()
+{
+  test_wide();
+  test_u16();
+  test_u32();
+}
diff --git a/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc b/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
index 8986f718229..530ab6663b5 100644
--- a/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
+++ b/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
@@ -205,6 +205,18 @@ test12()
   }();
 }
 
+void
+test13()
+{
+  // PR libstdc++/106320
+  auto l = std::views::transform([](auto x) {
+    return x | std::views::transform([i=0](auto y) {
+      return y;
+    });
+  });
+  std::vector<std::vector<int>> v{{5, 6, 7}};
+  v | l | std::views::join;
+}
 int
 main()
 {
@@ -220,4 +232,5 @@ main()
   test10();
   test11();
   test12();
+  test13();
 }
diff --git a/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc b/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc
index 31dd1b2a8f3..24ac80d3c81 100644
--- a/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc
+++ b/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc
@@ -59,5 +59,57 @@ constexpr_hh_mm_ss()
 
   static_assert(seconds{hh_mm_ss{100min}} == 100min);
 
-  // TODO: treat_as_floating_point_v
+  // treat_as_floating_point_v
+  using fseconds = duration<double, ratio<1>>;
+  constexpr hh_mm_ss<fseconds> fsec{0x123.0004p5s};
+  static_assert(std::is_same_v<hh_mm_ss<fseconds>::precision, fseconds>);
+  static_assert(fsec.hours() == 2h);
+  static_assert(fsec.minutes() == 35min);
+  static_assert(fsec.seconds() == 12s);
+  static_assert(fsec.subseconds() == 0x.0004p5s);
+  static_assert(!fsec.is_negative());
+  static_assert(fsec.to_duration() == 0x123.0004p5s);
+
+  using fminutes = duration<double, ratio<60>>;
+  constexpr hh_mm_ss<fminutes> fmin{-0x1.23p4min};
+  static_assert(std::is_same_v<hh_mm_ss<fminutes>::precision, fseconds>);
+  static_assert(fmin.hours() == 0h);
+  static_assert(fmin.minutes() == 18min);
+  static_assert(fmin.seconds() == 11s);
+  static_assert(fmin.subseconds() == 0.25s);
+  static_assert(fmin.is_negative());
+  static_assert(fmin.to_duration() == -0x1.23p4min);
+}
+
+constexpr void
+default_construction()
+{
+  using namespace std::chrono;
+
+  constexpr hh_mm_ss<seconds> s1;
+  static_assert(s1.to_duration() == s1.to_duration().zero());
+  constexpr hh_mm_ss<duration<char>> s2;
+  static_assert(s2.to_duration() == s2.to_duration().zero());
+  constexpr hh_mm_ss<duration<int, std::centi>> s3;
+  static_assert(s3.to_duration() == s3.to_duration().zero());
+  constexpr hh_mm_ss<duration<long long, std::femto>> s4;
+  static_assert(s4.to_duration() == s4.to_duration().zero());
+  constexpr hh_mm_ss<duration<double>> s5;
+  static_assert(s5.to_duration() == s5.to_duration().zero());
+}
+
+constexpr void
+unsigned_rep()
+{
+  using namespace std::chrono;
+
+  constexpr duration<unsigned, std::milli> ms(3690001);
+
+  constexpr hh_mm_ss hms(ms); // PR libstdc++/108265
+  static_assert( ! hms.is_negative() );
+  static_assert( hms.to_duration() == milliseconds(ms.count()) );
+  static_assert( hms.hours() == 1h );
+  static_assert( hms.minutes() == 1min );
+  static_assert( hms.seconds() == 30s );
+  static_assert( hms.subseconds() == 1ms );
 }
